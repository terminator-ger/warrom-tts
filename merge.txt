----#include utils/debug
logStyle('debug', 'Grey')
logStyle('warn', 'Red')

function debug(...) if Global.getVar('Debug') then log(table.concat{'[DEBUG] ', ...}, '', 'debug') end end
function warn(...) if Global.getVar('Debug') then log(table.concat{'[WARNING] ', ...}, '', 'warn') end end

function alert(...)
    if AlertID then printToAll(table.concat(table.pack('(', AlertID, ') ', ...))) else printToAll(...) end
end

function loadOrdersJSON(url)
    WebRequest.get(url, function (req) if not req.is_error then
        for nation, moves in pairs(JSON.decode(req.text)) do
            for i, move in ipairs(moves) do
                Orders[nation]:updateCommand(i, move.command)
                Orders[nation]:updateTarget(i, move.target)
        end end
    end end)
end

----#include utils/debug
----#include utils/exports
function wrapper(T) return {__index = |t, k| T[k] or t.obj[k]} end

function wrap(T, obj)
    local w = {obj = obj}
    setmetatable(w, T.__meta)
    return w
end

function constructor(fn) return function (T, obj, ...)
    local t = wrap(T, obj)
    return fn and fn(t, ...) or t
end end

function Wrapper(fn)
    local W = {}
    W.__meta = wrapper(W)
    setmetatable(W, {__call = constructor(fn)})
    return W
end

function bind(obj, T)
    T = T or {}
    setmetatable(T, {__index = function (t, k)
        local ok, v = pcall(|| obj[k])
        if ok then return v
        else return rpc(t, obj, k) end
    end})
    return T
end

function import(lib)
    local T = {path = lib}
    setmetatable(T, {__index = |t, k| rpc(t, Global, k)})
    return T
end

function rpc(parent, obj, path)
    local T = {obj = obj, path = path}
    if rawget(parent, 'path') then T.path = parent.path .. '.' .. T.path end
    setmetatable(T, {
        __call = function (t, ...)
            local args = table.pack(...)
            if args[1] == parent then args[1] = t.path:gsub('%.([^%.]+)$', ':%1')
            else table.insert(args, 1, t.path) end
            local ok, result = t.obj.call('resolve', args)
            if ok then return table.unpack(result, 1, result.n) else error(result) end
        end,
        __index = |t, k| rpc(t, t.obj, k)
    })
    return T
end

function resolve(args)
    local path = table.remove(args, 1)
    local f, ok, result = _G
    for step, delimiter in path:gmatch('([^%.:]+)([%.:]?)') do
        ok, f = pcall(|| f[step] or self[step])
        if not ok then return false, string.format('Couldn\'t resolve path %s on %s', path, tostring(self)) end
        if delimiter == ':' then table.insert(args, 1, f) end
    end
    ok, result = pcall(|| table.pack(f(table.unpack(args, 1, args.n))))
    if not ok then
        return false, string.format('Error while executing %s on %s: %s', path, tostring(self), result)
    else return ok, result end
end

----#include utils/exports
----#include utils/promise
Promise = {}
setmetatable(Promise, {__call = function (t, arg)
    local p = {}
    local s = tostring(p):gsub('table', 'promise')
    setmetatable(p, {__index = t, __tostring = || s})
    if type(arg) ~= 'nil' then return p:resolve(arg) else return p end
end})

function Promise.time(t, ...)
    local p, args = Promise(), table.pack(...)
    Wait.time(|| p:resolve(table.unpack(args, 1, args.n)), t)
    return p
end

function Promise.frames(f, ...)
    local p, args = Promise(), table.pack(...)
    Wait.frames(|| p:resolve(table.unpack(args, 1, args.n)), f)
    return p
end

function Promise.condition(fun, ...)
    local p, args, pid = Promise(), table.pack(...)
    pid = Wait.condition(|| p:resolve(table.unpack(args, 1, args.n)), function ()
        local ok, result = pcall(fun)
        if not ok then
            if pid then Wait.stop(pid) end
            p:reject(result)
        else return result end
    end)
    return p
end

function Promise.all(...)
    local p, t, pid = Promise(), {...}
    if #t == 1 and type(t[1]) == 'table' then t = t[1] end
    pid = Wait.condition(function ()
        local results = {}
        for _, q in ipairs(t) do
            if q.resolved then for _, result in ipairs(q.result) do table.insert(results, result) end
            elseif q.rejected then p:reject(q.error) break end
        end
        if not p.rejected then p:resolve(table.unpack(results)) end
    end, function () if p.resolved or p.rejected then
        Wait.stop(pid)
        return false
    else
        local resolved, rejected = true, false
        for _, q in ipairs(t) do resolved, rejected = q.resolved and resolved, q.rejected or rejected end
        return resolved or rejected
    end end)
    return p
end

function Promise.isPromise(p)
    if type(p) == 'table' then
        local mt = getmetatable(p)
        return mt ~= nil and mt.__index == Promise
    else return false end
end

function Promise:resolve(...)
    if not (self.resolved or self.rejected) then self.resolved, self.result = true, table.pack(...) end
    return self
end

function Promise:reject(error)
    warn('Rejected ', tostring(self), ': ', error)
    if not (self.resolved or self.rejected) then self.rejected, self.error = true, error end
    return self
end

function Promise:delay(time) return self:next(|...| Promise.time(time, ...)) end
function Promise:skip(frames) return self:next(|...| Promise.frames(frames, ...)) end
function Promise:when(fun) return self:next(|...| Promise.condition(fun, ...)) end

function Promise:next(resolve_fun, reject_fun)
    local p = Promise()
    Wait.condition(function ()
        local ok, result
        if self.resolved then
            if type(resolve_fun) == 'function' then
                ok, result = pcall(|| table.pack(resolve_fun(self:unpack())))
            elseif Promise.isPromise(resolve_fun) then
                resolve_fun:resolve(self:unpack())
                ok, result = true, self.result
            end
        elseif reject_fun then
            if type(reject_fun) == 'function' then
                ok, result = pcall(|| table.pack(reject_fun(self.error)))
            elseif Promise.isPromise(reject_fun) then
                reject_fun:reject(self.error)
                ok, result = false, self.error
            end
        else result = self.error end
        if ok then if result.n == 1 and Promise.isPromise(result[1]) then Wait.condition(
            || result[1].resolved and p:resolve(result[1]:unpack()) or p:reject(result[1].error),
            || result[1].resolved == true or result[1].rejected == true
        ) else p:resolve(table.unpack(result, 1, result.n)) end
        else p:reject(result) end
    end, || self.resolved == true or self.rejected == true)
    return p
end

function Promise:catch(reject_fun) return self:next(|| nil, reject_fun) end

function Promise:finally(fun) return self:next(|...| fun(false, ...), |...| fun(true, ...)) end

function Promise:unpack() return table.unpack(self.result, 1, self.result.n) end

----#include utils/promise
----#include utils/colors
function Color.fromHex(hex) return color(
    tonumber(hex:sub(1, 2), 16) / 255,
    tonumber(hex:sub(3, 4), 16) / 255,
    tonumber(hex:sub(5, 6), 16) / 255,
    #hex == 8 and tonumber(hex:sub(7, 8), 16) / 255 or nil
) end

function Color:toXml(includeAlpha) return '#' .. self:toHex(includeAlpha) end

Colors = {
    axis = 'c08080', allies = 'a0a0ff', neutral = 'e8e8e8',
    uk = 'bd9d6d', ussr = 'b77969', usa = '829d63', china = 'fcc80b',
    germany = '7f7f7f', italy = 'b9c834', japan = 'd97f3a',
    sea = 'd6eaf8', medal = 'f8b938', cg = '9bbc62',
    oil = 'red', iron = 'blue', osr = 'yellow',
    infantry = 'yellow', artillery = 'blue', armor = 'green',
    fighter = 'green', cfighter = 'd0d0d0', bomber = 'red',
    submarine = 'yellow', cruiser = 'blue', carrier = 'green', battleship = 'red',
    yellow = 'ddb426', blue = '4276bb', green = '558f3a',
    red = '9a2829', black = '000000', white = 'ffffff'
}

for k, clr in pairs(Colors) do if type(clr) == 'string' then
    local name = k
    if Color[k] then name = '_' .. name
    elseif Colors[clr] then clr = Colors[clr] end
    Color.Add(name, Color.fromHex(clr))
end end

----#include utils/colors
----#include utils/builtins
function string:proper() return self:sub(1, 1):upper() .. self:sub(2) end

function string:colorize(clr) return string.format('[%s]%s[-]', (type(clr) == 'string' and Color[clr] or clr):toHex(false), self) end

function math.round(value)
    if value - math.floor(value) > 0.5 then
        return math.ceil(value)
    else return math.floor(value) end
end

function table.each(t, fun)
    for _, i in ipairs(t) do fun(i) end
end

----#include utils/builtins
----#include utils/effects
function setBlinker(obj, hcolor, on_time, delay)
    hcolor, on_time, delay = hcolor and colorTable(hcolor) or {1, 1, 1}, on_time or 0.5, delay or 1
    local id
    obj.highlightOn(hcolor, on_time)
    id = Wait.time(|| obj ~= nil and obj.highlightOn(hcolor, on_time) or Wait.stop(id), delay, -1)
    obj.setVar('blinker', id)
end

function stopBlinker(obj) if obj.getVar('blinker') then Wait.stop(obj.getVar('blinker')) end end

function setGlow(obj, clr)
    clr = clr or Color.white
    local i, id = 0
    id = Wait.time(function () if obj ~= nil then
        obj.highlightOn(clr:copy():setAt('a', 0):lerp(clr, (i > 10 and 20 - i or i) / 10))
        i = (i + 1) % 20
    else Wait.stop(id) end end, 0.08, -1)
    obj.setVar('glow', id)
    return obj
end

function stopGlow(obj) if obj.getVar('glow') then
    obj.highlightOff()
    Wait.stop(obj.getVar('glow'))
    return obj
end end

function setPulse(obj, clr2)
    clr2 = clr2 or color(0.5, 0.5, 0.5)
    local clr1, i, id = obj.getColorTint(), 0
    id = Wait.time(function () if obj ~= nil then
        obj.setColorTint(clr1:lerp(clr2, (i > 10 and 20 - i or i) / 10))
        i = (i + 1) % 20
    else Wait.stop(id) end end, 0.08, -1)
    obj.setVar('pulse', id)
    return obj
end

function stopPulse(obj, clr) if obj.getVar('pulse') then
    obj.setColorTint(clr or Color.white)
    Wait.stop(obj.getVar('pulse'))
    return obj
end end

function fadeOut(obj, delay)
    delay = delay or 1
    local i, p = delay * 10 - 1, Promise()
    Wait.time(function () if i > 0 then
        obj.setColorTint(Color.white:setAt('a', 0.1 * i / delay))
        i = i - 1
    else
        obj.destruct()
        p:resolve()
    end end, 0.1, delay * 10)
    return p
end

----#include utils/effects
----#include utils/tags
Tags = {}

function Tags.getAllObjects(tags)
    if type(tags) == 'table' then return getObjectsWithAllTags(tags)
    else return getObjectsWithTag(tags) end
end

function Tags.getObject(tags) return Tags.getAllObjects(tags)[1] end
function Tags.forAllObjects(tags) return ipairs(Tags.getAllObjects(tags)) end

----#include utils/tags

----#include config/help
HelpText = {
    setup =
[[Please wait while all game components are placed in their starting positions.]],
    start =
[[Click the 'Start round' button to begin a new round.]],
    orders =
[[Each nation writes secret orders on their orders chart. The orders are not visible to any player on the opposing team, but allied players can see them.

For each set of orders, enter the command number in the upper text field and the destination region in the lower text field. Unidentifiable commands or regions, as well as oil bids which exceed your oil supply, will be highlighted in red. You will be unable to submit your orders until these errors are corrected.

Press the 'Ready' button to lock in your orders once you are ready. You may click the button again to unlock them and make changes as long as other players are still working, but once the last player clicks 'Ready' the game will immediately proceed to turn order selection.]],
    turn_order =
[[Each nation chooses a turn in order of oil bid, with ties automatically broken randomly.
To select your turn order, pick up the flashing turn token and drop it on one of the open positions on the turn order track.

WARNING: Once a token has been placed, you cannot change your turn order! Any changes after the initial placement will not be recognized by the game script, so choose carefully.]],
    movement =
[[In turn order, each nation executes their movement orders in sequence. The current movement order is displayed in the center of the screen.

To execute an order as written, move the command to the destination region and then click the 'Resolved' button on your orders chart. To cancel an order, leave the command as is and click the 'Canceled' button.

If an order is invalid, or a command is fully pinned, the 'Resolved' button will be unavailable and the order must be canceled.

If an order would break the Soviet-Japanese Pact, the 'Resolved' button will change to indicate this and, if clicked, will immediately break the pact and apply 6 stress to the offending party.

NOTE: Landing arrows will automatically be placed on any air commands that have moved or participate in combat, so there is no need to place these manually.

WARNING: The script evaluates movement orders based on where the command is physically located on the map. To avoid unexpected script issues, avoid moving commands before their movement orders have appeared, and only click 'Resolved' once the command has been moved to its final destination.]],
    cfighters =
[[Each nation with carrier units now deploys carrier fighters. Carrier fighters have been placed on top of naval commands which contain carrier units, and each fighter is highlighted with the color of the controlling nation to avoid confusion.

Once you have finished deploying carrier fighters, click the 'Ready' button on your orders chart to continue.]],
    combat =
[[In turn order, each nation chooses a hotspot to resolve. The status bar indicates the number of remaining hotspots for the active player. Hover over an eligible hotspot to highlight all participating commands, and press the 'R' key to resolve it.

BATTLES: All units will automatically move to an open battle board. Most aspects of combat are fully automated and self-explanatory--just click the 'Ready' buttons when done choosing stances, and click 'Roll' to start throwing dice.

After naval combat, any escaped subs will be highlighted in blue and must be given orders. To dive in an adjacent region, move the sub(s) to that region and select 'Form dived command' from the right-click menu. If the sub will remain in the original region, just merge it into a new or existing command.

RAIDS: Convoy raids and undefended strategic bombing are rolled directly on the map. If multiple convoys are available to raid, then orange lines will be drawn to indicate the closest raid target for each command. To change targets, just move the command close to the desired target. Hover over the hotspot and press 'R' again to confirm your choices and start rolling.

BOMBING: Resources and units under construction in the target region will automatically be detected and buttons will appear to assign each die to an eligible target. When bombing undefended territories, the dice will be rolled directly on the map.

When capturing territory, if multiple nations participated then buttons will appear above the hotspot after combat to choose which nation gains control and which nation receives the medal(s).

Once the final hotspot has been resolved, the game will automatically proceed to the next phase.]],
    landing =
[[Air commands which moved or participated in combat must land in a friendly territory now. All commands which are eligible to land are highlighted in their owner's color.

Click the 'Ready' button on your orders chart when you have finished.]],
    deploy =
[[Newly deployed units should be added to existing or new command stacks at this time. As a shortcut, new commands will be automatically be created for any loose unit stacks when you click 'Ready'.

If the number of new units exceeds the production capacity in a region (due to recent bombing), then the stack will be highlighted in red. To proceed, right-click the stack and choose the menu options to destroy units, one at a time, until the production capacity is no longed exceeded.

Also, commands may be combined or split at this time. To split a command stack, right-click it and select 'Break stack'. To form a new stack, simply place a command token on top of a stack of units, or select a group of units and a command token. Then, right click the command token and select 'Form stack'. To combine two or more stacks (with a maximum of 8 units), select all of them and then right-click one and select 'Combine stacks'.]],
    casualties =
[[Click the 'Casualty to Stress Conversion' button on the Morale Board to automatically count casualties and apply stress.
Each nation will receive a number of stress points that corresponds to the total casualty value of their destroyed units.

Once you have finished assessing the damage, click the 'Medals & Civ. Goods' button to continue.]],
    medals =
[[Any nation with medals (or consumer goods) may use them to remove stress. Each medal removes one stress point.
To use a medal, click the 'Spend' button on the medal you wish to use.
Click 'Done' when you are finished.

Then, each nation that has exceeded its stress threshold will advance along the Homeland Status track. Each nation that is not in the white zone may now pay an amount of medals and/or consumer goods equal to their stress threshold to relieve stress and recover one zone along the Homeland Status Track.
To use medals, click the 'Spend' button as above, or 'Done' when you are finished.]],
    stress =
[[Each nation that is experiencing homeland stress must now incur the cumulative stress penalties corresponding to their stress zone.
Nations in the blue zone or higher must lose any 3 resources.
Nations in the black zone must destroy a number of units equal to their current stress.
(All other penalties are automatically assessed during the game round, as appropriate)

Once you have finished taking penalties, click the 'Ready' button on your orders chart.]],
    production =
[[Each nation writes secret production orders on their orders chart. The orders are not visible to any player on the opposing alliance, but allied players can see them.

Click the '+' and '-' buttons in the trade section to make a resource trade. Valid trade routes are automatically detected, and resources are adjusted only after you've selected both sides of the trade. You can always change your mind and select a different trade before finalizing your orders.

To purchase consumer goods, enter the amount of each resource you'd like to spend and the total quantity will be automatically calculated. For units, just enter the desired quantity. If the total cost of your produced units exceeds your available resources, or you did not spend an even multiple of 5 on consumer goods, you will not be able to finalize your orders.

Click the 'Ready' button to lock in your production orders once ready. You may click the button again to unlock them and make changes as long as other players are still working, but once the last player clicks 'Ready' the game will immediately reveal all orders.]],
    transfer =
[[Each nation places all new units in industrial territories they control. Newly purchased units will be highlighted in their owner's color to avoid confusion.
The units need not be stacked, and there is no need to place industry tokens.

Once you are satisfied with your placement, click the 'Ready' button. If you exceed production limits or otherwise place units incorrectly, the units will flash red to indicate there is a problem. Otherwise, the units will be collected into stacks and topped with an industry token. For China, infantry placed in mobilization territories will automatically be formed into new commands (if placed on the map), or merged directly into existing commands if placed on top of them.]]
}

----#include config/help
----#include config/nations
Nation = {}
setmetatable(Nation, {__call = function (t, data)
    data.other = Nations.other[data.side]
    setmetatable(data, {__index = t})
    return data
end})

function Nation:isAxis() return self.side == 'axis' end

function Nation:shortName() return #self.id < 5 and self.id:upper() or self.id:proper() end

function Nation:colorized() return self:shortName():colorize(self.id) end

Nations = {
    n = 'neutral', g = 'germany', t = 'italy', j = 'japan',
    c = 'china', b = 'uk', u = 'usa', r = 'ussr',
    neutral = {prefix = 'n', side = 'neutral'},
    other = {axis = 'allies', allies = 'axis'}
}
setmetatable(Nations, {__pairs = function (T, k) return function (t, k)
    local v
    repeat k, v = next(t, k)
    until v == nil or #k > 1 and getmetatable(v)
    if v ~= nil then return k, v end
end, T, nil end})

Nations.usa = Nation({id = 'usa', player = 'Blue',
    order = 4, prefix = 'u', name = 'United States of America', side = 'allies',
    morale = {5, 4}})
Nations.germany = Nation({id = 'germany', player = 'White',
    order = 5, prefix = 'g', name = 'Germany', side = 'axis',
    morale = {6, 6}})
Nations.italy = Nation({id = 'italy', player = 'Green',
    order = 6, prefix = 't', name = 'Kingdom of Italy', side = 'axis',
    morale = {4, 4}})
Nations.uk = Nation({id = 'uk', player = 'Brown',
    order = 2, prefix = 'b', name = 'British Commonwealth', side = 'allies',
    morale = {6, 4}})
Nations.ussr = Nation({id = 'ussr', player = 'Red',
    order = 3, prefix = 'r', name = 'Soviet Union', side = 'allies', pact = 'japan',
    morale = {6, 5}})
Nations.china = Nation({id = 'china', player = 'Yellow',
    order = 1, prefix = 'c', name = 'China', side = 'allies',
    morale = {4, 4}})
Nations.japan = Nation({id = 'japan', player = 'Orange',
    order = 7, prefix = 'j', name = 'Imperial Japan', side = 'axis', pact = 'ussr',
    morale = {7, 6}})

function Nations:inOrder()
    local t = {}
    for nation, _ in pairs(self) do table.insert(t, nation) end
    return t
end

function Nations:moraleOrder()
    local t = {}
    for nation, data in pairs(self) do t[data.order] = nation end
    return t
end

function Nations:byPlayer(player)
    for _, nation in pairs(self) do if nation.player == player then return nation end end
end

----#include config/nations
----#include config/scenario
Scenarios = {
    global = {
        label = 'Global War',
        nations = {germany = 9, italy = 6, japan = 9, uk = 9, ussr = 9, usa = 9, china = 6},
        capitals = {'b1', 'g1', 'j1', 'j4', 'r1', 't1', 'u1'}
    },
    europe = {
        label = 'War in Europe',
        decal = '1680367392274693386/B727DE60ADF193B136B27A731D99E7E1FABDCF9E',
        nations = {uk = 6, germany = 9, italy = 6, ussr = 9, usa = 6},
        capitals = {'b1', 'g1', 'r1', 't1', 'u1'}
    },
    pacific = {
        label = 'War in the Pacific',
        decal = '1680367304175510428/DF165237A2F137999172A19DB65D44EF5A46DFEE',
        nations = {uk = 6, china = 6, japan = 9, usa = 6},
        capitals = {'b18', 'b24', 'j1', 'j4', 'u3', 'u4', 'u6'}
    },
    nafrica = {
        label = 'North Africa',
        decal = '1692773056648512899/81315949A25C99C3CCF0AFA9A3B14C843144E692',
        nations = {uk = 6, germany = 6, italy = 6, usa = 6},
        capitals = {'b1', 't1', 'u1'}
    },
    eastern = {
        label = 'Eastern Front',
        decal = '1680367392274692702/4E0B679347DBE0E2CB659E7DBDD0AF5F7F5DECC1',
        nations = {germany = 9, ussr = 9},
        capitals = {'g1', 'r1'}
    }
}

----#include config/scenario
----#include config/commands
CommandSetup = {
    china = {
        [101] = {region = 'c1', position = {x = -3.7, z = 0.6}, units = {infantry = 3, artillery = 1}},
        [102] = {region = 'c2', position = {x = -4, z = 1.1}, units = {infantry = 3, artillery = 1}},
        [103] = {region = 'c3', position = {x = -3.3, z = 1.5}, units = {infantry = 2, artillery = 1}},
        [104] = {region = 'c4', position = {x = -2.8, z = 0.9}, units = {infantry = 3, artillery = 1}},
        [105] = {region = 'c5', position = {x = -2, z = 1.1}, units = {infantry = 2}},
    },
    germany = {
        [1] = {region = 'a5', position = {x = 3.3, z = 0.4}, units = {submarine = 1, cruiser = 2}},
        [3] = {region = 'a13', position = {x = 6, z = -3}, units = {submarine = 2}},
        [5] = {region = 'a15', position = {x = 6.7, z = 0.1}, units = {submarine = 3}},
        [11] = {region = 'g1', position = {x = 3.6, z = 0.8}, units = {fighter = 2, bomber = 1}},
        [12] = {region = 'g10', position = {x = 3.4, z = -1}, units = {fighter = 2, bomber = 1}},
        [13] = {region = 'g3', position = {x = 5.2, z = 0.2}, units = {fighter = 2, bomber = 1}},
        [14] = {region = 'g4', position = {x = 3.2, z = 1.7}, units = {fighter = 2}},
        [15] = {region = 'g5', position = {x = 2.8, z = 2.2}, units = {fighter = 2}},
        [16] = {region = 'g6', position = {x = 2.5, z = 1.5}, units = {fighter = 2}},
        [17] = {region = 't5', position = {x = 3.5, z = 4.1}, units = {fighter = 2}},
        [22] = {region = 'g8', position = {x = 2.6, z = 0.5}, units = {infantry = 2, artillery = 2, armor = 1}},
        [33] = {region = 'g5', position = {x = 3.1, z = 2.3}, units = {infantry = 2, artillery = 1, armor = 1}},
        [37] = {region = 'g7', position = {x = 2, z = 0.8}, units = {infantry = 2, artillery = 1, armor = 1}},
        [38] = {region = 'g2', position = {x = 3.8, z = -0.1}, units = {infantry = 2, artillery = 1, armor = 1}},
        [40] = {region = 'g9', position = {x = 2.4, z = -0.6}, units = {infantry = 2, artillery = 1, armor = 1}},
        [48] = {region = 'g1', position = {x = 4.2, z = 0.4}, units = {infantry = 3, artillery = 2, armor = 2}},
        [49] = {region = 't5', position = {x = 3.6, z = 4.4}, units = {infantry = 2, artillery = 1, armor = 1}},
        [55] = {region = 'g10', position = {x = 3.8, z = -0.7}, units = {infantry = 2, artillery = 3, armor = 1}},
        [56] = {region = 'g4', position = {x = 3.5, z = 1.5}, units = {infantry = 2, artillery = 1, armor = 1}},
        [59] = {region = 'g13', position = {x = 5, z = 3.3}, units = {infantry = 1, artillery = 1, armor = 1}},
        [61] = {region = 'g6', position = {x = 1.8, z = 1.6}, units = {infantry = 2, artillery = 2, armor = 2}},
        [72] = {region = 'g3', position = {x = 4.8, z = 0.3}, units = {infantry = 2, artillery = 3, armor = 2}},
    },
    italy = {
        [1] = {region = 'm2', position = {x = 4.1, z = 3.1}, units = {submarine = 1, cruiser = 1, battleship = 1}},
        [11] = {region = 't1', position = {x = 4.3, z = 2.3}, units = {fighter = 1, bomber = 1}},
        [12] = {region = 't2', position = {x = 3.6, z = 2.8}, units = {fighter = 2}},
        [112] = {region = 't4', position = {x = 4.6, z = 2.7}, units = {infantry = 1}},
        [113] = {region = 't5', position = {x = 3.9, z = 4.2}, units = {infantry = 2, artillery = 1}},
        [114] = {region = 't1', position = {x = 4.4, z = 1.9}, units = {infantry = 3, artillery = 1, armor = 1}},
        [115] = {region = 't4', position = {x = 3.6, z = 2.5}, units = {infantry = 2, artillery = 1, armor = 1}},
    },
    japan = {
        [1] = {region = 'p1', position = {x = -4.7, z = -1}, units = {submarine = 1, cruiser = 1, carrier = 1, battleship = 1}},
        [3] = {region = 'p13', position = {x = -5.7, z = -1.8}, units = {submarine = 1, cruiser = 1, carrier = 1, battleship = 1}},
        [4] = {region = 'p14', position = {x = -5.3, z = 0.4}, units = {submarine = 1, cruiser = 2}},
        [5] = {region = 'p15', position = {x = -5.25, z = 3.1}, units = {cruiser = 1, battleship = 1}},
        [9] = {region = 'i9', position = {x = -4.7, z = 4.7}, units = {cruiser = 1, carrier = 1}},
        [11] = {region = 'j1', position = {x = -4.1, z = -0.9}, units = {fighter = 2, bomber = 1}},
        [12] = {region = 'j22', position = {x = -5.6, z = -1.1}, units = {fighter = 1, bomber = 1}},
        [13] = {region = 'j3', position = {x = -2.5, z = -0.7}, units = {fighter = 2, bomber = 1}},
        [14] = {region = 'j14', position = {x = -5.5, z = 0.9}, units = {fighter = 1, bomber = 1}},
        [15] = {region = 'j5', position = {x = -4.4, z = 0.9}, units = {fighter = 2}},
        [16] = {region = 'j16', position = {x = -4.7, z = 0.3}, units = {fighter = 1}},
        [17] = {region = 'j7', position = {x = -4.2, z = 2.5}, units = {fighter = 2}},
        [24] = {region = 'j4', position = {x = -3, z = 0}, units = {infantry = 2, artillery = 1, armor = 1}},
        [25] = {region = 'j12', position = {x = -5.8, z = 2.2}, units = {infantry = 1}},
        [30] = {region = 'j8', position = {x = -3.3, z = 2.5}, units = {infantry = 2, artillery = 1}},
        [39] = {region = 'j22', position = {x = -5.7, z = -0.8}, units = {infantry = 1, artillery = 1}},
        [44] = {region = 'j1', position = {x = -4.1, z = -1.2}, units = {infantry = 2, artillery = 2, armor = 2}},
        [46] = {region = 'j6', position = {x = -4.1, z = 2.1}, units = {infantry = 1, artillery = 1}},
        [52] = {region = 'j20', position = {x = -4.8, z = -1.7}, units = {infantry = 1, artillery = 1}},
        [54] = {region = 'j11', position = {x = -6.3, z = 3.3}, units = {infantry = 1}},
        [62] = {region = 'j2', position = {x = -3.7, z = -0.5}, units = {infantry = 1}},
        [65] = {region = 'j3', position = {x = -2.8, z = -0.7}, units = {infantry = 2, artillery = 1, armor = 1}},
        [76] = {region = 'j24', position = {x = -6.2, z = -0.6}, units = {infantry = 1, artillery = 1}},
        [77] = {region = 'j14', position = {x = -5.3, z = 1.1}, units = {infantry = 2, artillery = 1}},
        [78] = {region = 'j10', position = {x = -5.6, z = 3.6}, units = {infantry = 1}},
        [81] = {region = 'j5', position = {x = -4, z = 0.3}, units = {infantry = 2, artillery = 1, armor = 1}},
        [85] = {region = 'j9', position = {x = -4.9, z = 3.5}, units = {infantry = 1, artillery = 1}},
        [87] = {region = 'j23', position = {x = -6.3, z = -1.7}, units = {infantry = 1}},
        [89] = {region = 'j17', position = {x = -4.8, z = -0.4}, units = {infantry = 1, artillery = 1}},
        [92] = {region = 'j25', position = {x = -6.7, z = -2}, units = {infantry = 1, artillery = 1}},
        [95] = {region = 'j7', position = {x = -3.9, z = 2.6}, units = {infantry = 1, artillery = 1}},
    },
    uk = {
        [2] = {region = 'i2', position = {x = -1, z = 5.4}, units = {cruiser = 1, carrier = 1}},
        [3] = {region = 'm3', position = {x = 2.6, z = 3.8}, units = {submarine = 1, cruiser = 1}},
        [6] = {region = 'a6', position = {x = 4.3, z = -0.4}, units = {cruiser = 1, battleship = 1}},
        [7] = {region = 'a7', position = {x = 5.2, z = -1.8}, units = {cruiser = 1, battleship = 1}},
        [8] = {region = 'p18', position = {x = -7.4, z = -1.7}, units = {submarine = 1, cruiser = 1}},
        [9] = {region = 'a19', position = {x = 2.7, z = 7.6}, units = {submarine = 1, cruiser = 1}},
        [11] = {region = 'b1', position = {x = 4.8, z = -1}, units = {fighter = 3, bomber = 1}},
        [12] = {region = 'b22', position = {x = -7.3, z = 0.3}, units = {fighter = 2}},
        [13] = {region = 'b3', position = {x = 6.3, z = 1.3}, units = {fighter = 2}},
        [14] = {region = 'b29', position = {x = 2.7, z = -3.7}, units = {fighter = 1}},
        [15] = {region = 'b5', position = {x = 2.5, z = 4.6}, units = {fighter = 1}},
        [16] = {region = 'b18', position = {x = -1.6, z = 2.9}, units = {fighter = 2}},
        [36] = {region = 'b24', position = {x = -7.6, z = -0.7}, units = {infantry = 1, artillery = 1, armor = 1}},
        [45] = {region = 'b29', position = {x = 2.5, z = -3.9}, units = {infantry = 1, artillery = 1, armor = 1}},
        [47] = {region = 'b5', position = {x = 3.1, z = 4.5}, units = {infantry = 1, artillery = 2, armor = 2}},
        [53] = {region = 'b1', position = {x = 5, z = -0.4}, units = {infantry = 1, artillery = 1, armor = 1}},
        [60] = {region = 'b18', position = {x = -2.3, z = 3}, units = {infantry = 3, artillery = 1, armor = 1}},
        [63] = {region = 'b16', position = {x = 1.7, z = 3.7}, units = {infantry = 1, artillery = 1}},
        [68] = {region = 'b22', position = {x = -7.5, z = 0.5}, units = {infantry = 1}},
        [71] = {region = 'b25', position = {x = -6.5, z = -0.7}, units = {infantry = 1, artillery = 1}},
        [75] = {region = 'b10', position = {x = 3.9, z = 6.9}, units = {infantry = 1, artillery = 1}},
        [80] = {region = 'b23', position = {x = -8, z = 0.5}, units = {infantry = 1, artillery = 1}},
        [90] = {region = 'b28', position = {x = 1.1, z = -4.8}, units = {infantry = 1, artillery = 1}}
    },
    usa = {
        [1] = {region = 'a10', position = {x = 3.7, z = -4.9}, units = {cruiser = 1, battleship = 1}},
        [2] = {region = 'p5', position = {x = -0.2, z = -7}, units = {submarine = 1, cruiser = 1, battleship = 1}},
        [3] = {region = 'p9', position = {x = -1.9, z = -7.2}, units = {submarine = 1, cruiser = 1, carrier = 1}},
        [4] = {region = 'p19', position = {x = -6.8, z = -3.5}, units = {submarine = 1, cruiser = 2, carrier = 1}},
        [11] = {region = 'u1', position = {x = 3, z = -4.7}, units = {fighter = 2, bomber = 1}},
        [12] = {region = 'u2', position = {x = 1.7, z = -5.2}, units = {fighter = 2, bomber = 1}},
        [13] = {region = 'u3', position = {x = 0.2, z = -5.8}, units = {fighter = 2, bomber = 1}},
        [14] = {region = 'b1', position = {x = 4.6, z = -1.3}, units = {fighter = 1, bomber = 1}},
        [15] = {region = 'u10', position = {x = -7.2, z = -2.9}, units = {fighter = 1, bomber = 1}},
        [16] = {region = 'u6', position = {x = -2.2, z = -6.3}, units = {fighter = 2, bomber = 1}},
        [17] = {region = 'u7', position = {x = -2.6, z = -5.6}, units = {fighter = 2}},
        [27] = {region = 'u2', position = {x = 1.8, z = -6.1}, units = {infantry = 1, armor = 1}},
        [31] = {region = 'u5', position = {x = -2, z = -4}, units = {infantry = 1, artillery = 1}},
        [35] = {region = 'u4', position = {x = -1.2, z = -4.1}, units = {infantry = 1, artillery = 1}},
        [43] = {region = 'j25', position = {x = -6.8, z = -2.2}, units = {infantry = 1, artillery = 1}},
        [50] = {region = 'b27', position = {x = -6.9, z = -4.2}, units = {infantry = 1, artillery = 1}},
        [51] = {region = 'u1', position = {x = 3, z = -5.6}, units = {infantry = 2, artillery = 1, armor = 2}},
        [64] = {region = 'u6', position = {x = -2.1, z = -6.6}, units = {infantry = 2, artillery = 1}},
        [69] = {region = 'u3', position = {x = 1.1, z = -6.1}, units = {infantry = 2, artillery = 2, armor = 1}},
        [73] = {region = 'u10', position = {x = -7.4, z = -3}, units = {infantry = 1, artillery = 1}},
        [82] = {region = 'b1', position = {x = 5.1, z = -0.6}, units = {infantry = 2, armor = 1}},
    },
    ussr = {
        [1] = {region = 'a4', position = {x = 1.2, z = -0.7}, units = {submarine = 1, cruiser = 1}},
        [11] = {region = 'r1', position = {x = 0.4, z = 0.5}, units = {fighter = 2, bomber = 1}},
        [13] = {region = 'r3', position = {x = 2, z = -0.9}, units = {fighter = 2}},
        [15] = {region = 'r5', position = {x = 1.4, z = 0.7}, units = {fighter = 2}},
        [21] = {region = 'r7', position = {x = 1.1, z = 1.5}, units = {infantry = 3, armor = 1}},
        [23] = {region = 'r5', position = {x = 1, z = 0.8}, units = {infantry = 4, artillery = 1, armor = 2}},
        [26] = {region = 'r1', position = {x = 0.1, z = 0.9}, units = {infantry = 2, artillery = 2, armor = 2}},
        [29] = {region = 'r4', position = {x = 1.8, z = 0.3}, units = {infantry = 4, artillery = 2}},
        [34] = {region = 'r14', position = {x = -1.9, z = -0.3}, units = {infantry = 2, artillery = 1, armor = 1}},
        [57] = {region = 'r6', position = {x = 0.9, z = 2.6}, units = {infantry = 4, artillery = 1}},
        [58] = {region = 'r16', position = {x = -2.7, z = -1.3}, units = {infantry = 2, artillery = 1}},
        [66] = {region = 'r2', position = {x = 0.6, z = 0}, units = {infantry = 2, artillery = 1}},
        [67] = {region = 'r3', position = {x = 1.7, z = -0.5}, units = {infantry = 3, artillery = 1}},
    }
}

----#include config/commands

----#include components/map
----#include ../config/map
Map = {
    center = vector(-0.0325, 0.5925, -2.2025),
    regions = {
        a1 = {
            scenarios = {pacific = false, eastern = false},
            points = {{1.547, -2.9}, {2.667, -3.354}, {1.685, -3.725}, {2.239, -4.363}, {1.519, -4.367}, {1.202, -4.355},
                    {1.157, -4.083}, {1.629, -3.571}, {2.026, -3.401}, {1.759, -3.06}, {1.432, -3.086}},
            adjacent = {'a2', 'b28', 'b29'}
        },
        a2 = {
            scenarios = {pacific = false, eastern = false},
            points = {{3.5, -1.85}, {3.54, -2.25}, {3.436, -3.015}, {3.223, -3.828}, {2.84, -3.928}, {3.019, -3.249},
                    {2.667, -3.354}, {1.547, -2.9}, {1.56, -2.83}, {2.518, -2.988}, {2.81, -2.731},
                    {2.37, -2.509}, {2.123, -2.038}},
            islands = true,
            adjacent = {'a1', 'a3', 'a7', 'a8', 'a9', 'b29', 'n7', 'n8'}
        },
        a3 = {
            scenarios = {pacific = false, nafrica = false},
            points = {{1.811, -0.861}, {1.853, -1.091}, {2.15, -1.345}, {2.524, -1.487}, {3.359, -1.118}, {3.468, -1.64}, {3.5, -1.85},
                    {2.123, -2.038}, {1.66, -1.895}, {1.354, -1.182}},
            adjacent = {'a2', 'a4', 'a6', 'a7', 'g9', 'g10', 'n7', 'r3'},
            convoys = {{['u1-r2'] = {oil = 1, osr = 1, x = 1.68, z = -1.57}}}
        },
        a4 = {
            scenarios = {pacific = false, nafrica = false},
            points = {{1.595, -0.125}, {1.8, -0.414}, {1.509, -0.303}, {1.402, -0.397}, {1.513, -0.639}, {1.811, -0.861},
                    {1.354, -1.182}, {0.904, -0.684}, {0.154, -0.475}, {0.262, -0.382}, {1.01, -0.227}, {1.194, -0.454},
                    {1.4, -0.151}},
            adjacent = {'a3', 'r2$', 'r3$', 'r12'},
            convoys = {{r2 = {osr = 1, x = 1.22, z = -0.2}, r3 = {iron = 1, x = 1.66, z = -0.72}}}
        },
        a5 = {
            scenarios = {pacific = false, nafrica = false},
            points = {{3.142, 0.582}, {3.737, 0.535}, {3.964, 0.154}, {3.668, 0.276}, {3.036, -0.109}, {2.983, -0.589},
                    {2.479, -0.846}, {2.854, -0.134}, {2.464, 0.034}, {2.783, 0.075}},
            adjacent = {'a6@', 'g1$', 'g2', 'g8', 'g9$', 'g10$', 'n10$', 'r4$'},
            canals = {a6 = {'g2', 'g10'}},
            convoys = {{g1 = {oil = 1, iron = 1, osr = 1, x = 3.81, z = 0.4}}, {g9 = {iron = 1, x = 2.75, z = -0.18}}, {g10 = {iron = 1, x = 3.77, z = -0.52}}}
        },
        a6 = {
            scenarios = {pacific = false, nafrica = false},
            points = {{4.064, 0.106}, {4.325, 0.029}, {4.9, 0.041}, {5.577, -0.246}, {5.648, -0.5}, {5.491, -0.563},
                    {4.876, -0.211}, {4.538, -0.475}, {4.627, -0.897}, {4.43, -1.207}, {4.379, -1.453}, {3.468, -1.64},
                    {3.359, -1.118}, {3.78, -1.091}, {3.938, -0.5}},
            adjacent = {'a3', 'a5@', 'a7', 'a15', 'b1$', 'g1', 'g2', 'g3', 'g10'},
            canals = {a5 = {'g2', 'g10'}}
        },
        a7 = {
            scenarios = {pacific = false, eastern = false},
            points = {{5.648, -0.5}, {5.726, -0.701}, {5.897, -1.596}, {5.914, -2.25}, {5.409, -2.25}, {3.54, -2.25},
                    {3.5, -1.85}, {3.468, -1.64}, {4.379, -1.453}, {4.627, -1.561}, {4.894, -1.248}, {5.032, -1.338},
                    {5.371, -1.395}, {5.664, -1.048}, {5.242, -0.803}, {5.491, -0.563}},
            islands = true,
            adjacent = {'a2', 'a3', 'a6', 'a8', 'a13', 'a14', 'b1$', 'n8', 'n9'},
            convoys = {{b1 = {iron = 1, osr = 1, x = 5.24, z = -0.78}}}
        },
        a8 = {
            scenarios = {pacific = false, eastern = false},
            points = {{3.54, -2.25}, {5.409, -2.25}, {5.242, -3.488}, {3.436, -3.015}},
            islands = true,
            adjacent = {'a2', 'a7', 'a9', 'a13', 'n8'},
            convoys = {{['b29-b1'] = {oil = 1, iron = 1, osr = 1, x = 4.21, z = -2.78}}}
        },
        a9 = {
            scenarios = {pacific = false, eastern = false},
            points = {{3.436, -3.015}, {5.242, -3.488}, {5.161, -3.741}, {4.629, -4.93}, {3.136, -4.064}, {3.315, -4.025},
                    {3.35, -3.695}, {3.223, -3.828}},
            adjacent = {'a2', 'a8', 'a10', 'a12', 'a13', 'b29$'},
            convoys = {{['u1-b1'] = {oil = 1, iron = 1, osr = 3, x = 4.13, z = -3.89}}, {b29 = {iron = 1, x = 3.32, z = -3.84}}}
        },
        a10 = {
            scenarios = {pacific = false, eastern = false},
            points = {{3.136, -4.064}, {4.629, -4.93}, {4.081, -5.707}, {3.48, -6.27}, {3.075, -5.777}, {3.176, -5.71},
                    {3.558, -5.813}, {3.583, -5.675}, {3.201, -5.479}, {3.326, -4.965}, {3.174, -4.834}},
            islands = true,
            adjacent = {'a9', 'a11', 'a12', 'n3', 'u1$', 'n3'},
            convoys = {{u1 = {oil = 1, iron = 1, osr = 1, x = 3.21, z = -4.84}}}
        },
        a11 = {
            scenarios = {pacific = false, eastern = false},
            points = {{3.075, -5.777}, {3.48, -6.27}, {3.6, -6.416}, {3.411, -6.595}, {3.294, -6.478}, {3.277, -6.277},
                    {2.994, -6.477}, {2.975, -6.632}, {2.589, -6.854}, {2.363, -6.734}, {2.282, -6.548}, {2.195, -6.364},
                    {2.719, -6.03}},
            adjacent = {'a10', 'a12', 'n1$', 'n2', 'u1', 'u2$'},
            convoys = {{u2 = {oil = 1, iron = 1, osr = 1, x = 2.63, z = -6.12}}}
        },
        a12 = {
            scenarios = {pacific = false, eastern = false},
            points = {{5.161, -3.741}, {6.143, -4.051}, {6.088, -4.374}, {5.955, -4.21}, {5.501, -4.542}, {5.417, -4.778},
                    {4.83, -5.542}, {4.567, -6.074}, {4.653, -6.237}, {4.102, -6.588}, {3.779, -6.34}, {3.6, -6.416},
                    {3.48, -6.27}, {4.081, -5.707}, {4.629, -4.93}},
            islands = true,
            adjacent = {'a9', 'a10', 'a11', 'a13', 'b30', 'n2', 'n3', 'n4$', 'n5$', 'n6', 'p7@'},
            canals = {p7 = {'n2'}}
        },
        a13 = {
            scenarios = {pacific = false, eastern = false},
            points = {{5.914, -2.25}, {7.484, -2.25}, {7.967, -2.25}, {7.57, -3.354}, {6.92, -2.995}, {6.143, -4.051},
                    {5.161, -3.741}, {5.242, -3.488}, {5.409, -2.25}},
            adjacent = {'a7', 'a8', 'a9', 'a12', 'a14', 'a16', 'n6$'}
        },
        a14 = {
            scenarios = {pacific = false, eastern = false},
            points = {{7.437, -0.238}, {7.536, -1.148}, {7.484, -2.25}, {5.914, -2.25}, {5.897, -1.596}, {5.726, -0.701}},
            islands = true,
            adjacent = {'a7', 'a13', 'a15', 'a16', 'b2'}
        },
        a15 = {
            scenarios = {pacific = false, eastern = false},
            points = {{6.626, 1.96}, {7.181, 0.747}, {7.437, -0.238}, {5.726, -0.701}, {5.648, -0.5}, {5.577, -0.246}, {5.37, 0.31},
                    {5.57, 0.538}, {6.18, 0.17}, {6.351, 0.343}, {6.719, 1.051}, {6.476, 1.19}, {6.401, 1.564}},
            islands = true,
            adjacent = {'a6', 'a7', 'a14', 'a16', 'b2', 'b3', 'g3$', 'g11$', 'n11', 'n12', 'm1@'},
            canals = {m1 = {'b3'}},
            convoys = {{g3 = {iron = 1, osr = 1, x = 5.5, z = -0.09}}, {g11 = {oil = 1, osr = 1, x = 6.58, z = 1.79}}}
        },
        a16 = {
            scenarios = {pacific = false, eastern = false},
            points = {{7.609, 3.287}, {8.083, 1.813}, {8.286, 0.258}, {8.206, -1.173}, {7.967, -2.25}, {7.484, -2.25},
                    {7.536, -1.148}, {7.437, -0.238}, {7.181, 0.747}, {6.626, 1.96}, {6.743, 2.2}, {6.783, 2.687}},
            adjacent = {'a13', 'a14', 'a15', 'a17', 'g11'}
        },
        a17 = {
            scenarios = {pacific = false, eastern = false},
            points = {{6.387, 5.291}, {7.097, 4.296}, {7.609, 3.287}, {6.783, 2.687}, {6.602, 3.254}, {6.504, 3.571}, {6.304, 3.973},
                    {5.817, 4.618}},
            adjacent = {'a16', 'a18', 'b15', 'g15$', 'g12^'},
            convoys = {{g15 = {osr = 1, x = 6.56, z = 3.39}}}
        },
        a18 = {
            scenarios = {pacific = false, eastern = false},
            points = {{4.758, 6.794}, {5.717, 6.011}, {6.387, 5.291}, {5.817, 4.618}, {5.196, 4.979}, {4.647, 5.475},
                    {4.549, 5.795}, {4.323, 5.96}},
            adjacent = {'a17', 'a19', 'b11$', 'b12', 'b13$', 'b14$'},
            convoys = {{b11 = {osr = 1, x = 4.39, z = 5.95}}, {b13 = {iron = 1, x = 5.1, z = 5.1}}, {b14 = {osr = 1, x = 5.67, z = 4.71}}}
        },
        a19 = {
            scenarios = {pacific = false, eastern = false},
            points = {{2.325, 7.962}, {3.911, 7.318}, {4.758, 6.794}, {4.323, 5.96}, {4.257, 6.164}, {4.351, 6.414},
                    {3.962, 7.147}, {3.458, 7.328}, {2.893, 7.232}, {2.1, 7}},
            adjacent = {'a18', 'b10$', 'i4', 'n16', 'n17'},
            convoys = {{b10 = {iron = 1, osr = 1, x = 3.94, z = 7.13}}}
        },
        b1 = {
            scenarios = {pacific = false, eastern = false},
            name = 'Great Britain',
            points = {{4.876, -0.211}, {5.491, -0.563}, {5.242, -0.803}, {5.032, -1.338}, {4.894, -1.248}, {4.627, -1.561}, {4.379, -1.453},
                    {4.43, -1.207}, {4.627, -0.897}, {4.538, -0.475}},
            adjacent = {'a6$', 'a7$', 'n9'},
            sv = 8,
            industry = 8,
            resources = {iron = 1, osr = 2}
        },
        b2 = {
            scenarios = {pacific = false, eastern = false},
            name = 'Azores',
            circle = {c = {7.094, -0.265}, r = 0.25},
            adjacent = {'a14', 'a15'}
        },
        b3 = {
            scenarios = {pacific = false, eastern = false},
            name = 'Gibraltar',
            circle = {c = {6.25, 1.305}, r = 0.21},
            adjacent = {'a15', 'm1$', 'n11'},
            sv = 1
        },
        b4 = {
            scenarios = {pacific = false, eastern = false},
            name = 'Malta',
            circle = {c = {4.53, 3.1}, r = 0.2},
            adjacent = {'m2'},
            sv = 1
        },
        b5 = {
            scenarios = {pacific = false, eastern = false},
            name = 'Egypt',
            points = {{2.28, 4.8}, {3.205, 4.642}, {3.355, 4.57}, {3.29, 3.88}, {2.422, 4.09}, {2.235, 3.948},
                    {2.112, 4.11}, {2.26, 4.26}, {2.097, 4.686}},
            adjacent = {'b6', 'b16', 'm3$', 'm5', 't5', 'b13^'},
            sv = 3,
            resources = {oil = 1}
        },
        b6 = {
            scenarios = {pacific = false, eastern = false},
            name = 'Sudan',
            points = {{2.762, 5.807}, {3.205, 5.639}, {3.67, 5.114}, {3.205, 4.642}, {2.28, 4.8}, {2.097, 4.686},
                    {1.81, 5.057}, {2.5, 5.591}, {2.29, 5.803}},
            adjacent = {'b5', 'b7', 'b8', 'b11', 'b12', 'm5'},
            sv = 1
        },
        b7 = {
            scenarios = {pacific = false, eastern = false},
            name = 'Horn of Africa',
            points = {{1.694, 6.261}, {1.704, 6.032}, {2.29, 5.803}, {2.5, 5.591}, {1.81, 5.057}, {1.3374, 5.546},
                    {0.762, 5.6}, {0.42, 5.57}, {0.786, 5.925}},
            adjacent = {'b6', 'b8', 'i2', 'i3', 'm5'},
            sv = 1
        },
        b8 = {
            scenarios = {pacific = false, eastern = false},
            name = 'British East Africa',
            points = {{2.043, 6.7}, {2.578, 6.589}, {2.941, 6.366}, {2.762, 5.807}, {2.29, 5.803}, {1.704, 6.032},
                    {1.694, 6.261}, {2.022, 6.42}},
            adjacent = {'b6', 'b7', 'b9#', 'b11', 'i3', 'n17'},
            sv = 1,
            resources = {osr = 1}
        },
        b9 = {
            scenarios = {pacific = false, eastern = false},
            name = 'Rhodesia',
            points = {{2.887, 7.122}, {3.605, 6.692}, {3.515, 6.416}, {3.11, 6.575}, {2.941, 6.366}, {2.578, 6.589}},
            adjacent = {'b8#', 'b10#', 'b11', 'n16', 'n17'},
            sv = 1,
            resources = {osr = 1}
        },
        b10 = {
            scenarios = {pacific = false, eastern = false},
            name = 'South Africa',
            points = {{3.458, 7.328}, {3.962, 7.147}, {4.351, 6.414}, {3.605, 6.692}, {2.887, 7.122}, {2.893, 7.232}},
            adjacent = {'a19$', 'b9#', 'n16', 'n17'},
            sv = 3,
            industry = 3,
            resources = {iron = 1, osr = 1}
        },
        b11 = {
            scenarios = {pacific = false, eastern = false},
            name = 'Belgian Congo',
            points = {{3.11, 6.575}, {3.515, 6.416}, {4.323, 5.96}, {4.004, 5.829}, {3.852, 5.604}, {3.205, 5.639},
                    {2.762, 5.807}, {2.941, 6.366}},
            adjacent = {'a18$', 'b6', 'b8', 'b9', 'b12', 'n16'},
            sv = 1,
            resources = {osr = 1}
        },
        b12 = {
            scenarios = {pacific = false, eastern = false},
            name = 'French Equatorial Africa',
            points = {{4.323, 5.96}, {4.549, 5.795}, {4.647, 5.475}, {4.26, 5.531}, {4.286, 5.099}, {4.498, 4.709}, {3.67, 5.114},
                    {3.205, 5.639}, {3.852, 5.604}, {4.004, 5.829}},
            adjacent = {'a18', 'b6', 'b11', 'b13', 't5^'}
        },
        b13 = {
            scenarios = {pacific = false, eastern = false},
            name = 'Nigeria Cameroon',
            points = {{4.26, 5.531}, {4.647, 5.475}, {5.196, 4.979}, {5.071, 4.564}, {4.498, 4.709}, {4.286, 5.099}},
            adjacent = {'a18$', 'b12', 'b14', 'b5^', 'g12^', 'g13^', 't5^'},
            sv = 1,
            resources = {iron = 1}
        },
        b14 = {
            scenarios = {pacific = false, eastern = false},
            name = 'Gold Coast',
            points = {{5.196, 4.979}, {5.817, 4.618}, {5.665, 4.237}, {5.071, 4.564}},
            adjacent = {'a18$', 'b13', 'g15', 'g12^', 'g13^', 't5^'},
            sv = 1,
            resources = {osr = 1}
        },
        b15 = {
            scenarios = {pacific = false, eastern = false},
            name = 'Sierra Leone',
            points = {{6.304, 3.973}, {6.504, 3.571}, {6.27, 3.557}, {6.149, 3.815}},
            adjacent = {'a17', 'g15'},
            sv = 1
        },
        b16 = {
            scenarios = {pacific = false, eastern = false},
            name = 'Middle East',
            points = {{2.112, 4.11}, {2.235, 3.948}, {1.969, 3.782}, {1.876, 3.447}, {0.881, 3.154}, {0.542, 3.612}, {0.733, 3.826},
                    {1.618, 3.828}, {1.575, 3.971}},
            adjacent = {'b5', 'b17#', 'i1$', 'm3', 'm5', 'n14#', 'n15'},
            sv = 3,
            resources = {oil = 2}
        },
        b17 = {
            scenarios = {eastern = false},
            name = 'Iran',
            points = {{-0.227, 3.863}, {0.542, 3.612}, {0.881, 3.154}, {0.917, 2.925}, {0.625, 2.9}, {0.145, 2.867},
                    {-0.419, 2.861}, {-0.519, 3.411}, {-0.646, 3.76}},
            adjacent = {'b16#', 'b18#', 'i1$', 'm6', 'n14', 'n18', 'r6', 'r9'},
            sv = 2,
            resources = {oil = 1}
        },
        b18 = {
            scenarios = {europe = false, eastern = false},
            name = 'India',
            points = {{-2.245, 4.873}, {-2.052, 4.7}, {-1.478, 3.891}, {-0.962, 3.648}, {-0.646, 3.76}, {-0.519, 3.411},
                    {-1.002, 3.148}, {-1.28, 2.275}, {-1.504, 2.137}, {-1.755, 2.273}, {-1.961, 2.704}, {-2.951, 2.22}, {-2.957, 2.814}, {-2.63, 3.09},
                    {-2.301, 4.114}, {-2.437, 4.524}},
            adjacent = {'b17#', 'i1$', 'i2', 'i7', 'i10$', 'j8', 'n18', 'c4^', 'c5^'},
            sv = 5,
            industry = 5,
            resources = {osr = 2}
        },
        b19 = {
            scenarios = {europe = false, nafrica = false, eastern = false},
            name = 'Ceylon',
            circle = {c = {-2.73, 4.803}, r = 0.32},
            adjacent = {'i7'}
        },
        b20 = {
            scenarios = {nafrica = false, eastern = false},
            name = 'Maldives',
            circle = {c = {-1.82, 5.82}, r = 0.32},
            adjacent = {'i2', 'i6'}
        },
        b21 = {
            scenarios = {europe = false, nafrica = false, eastern = false},
            name = 'Western Australia',
            points = {{-7.655, 2.384}, {-7.286, 1.533}, {-7.189, 0.655}, {-7.696, 0.759}, {-8.241, 0.887}, {-7.974, 2.273}},
            adjacent = {'b22', 'b23#', 'p16', 'p17'},
            sv = 1,
            resources = {osr = 1}
        },
        b22 = {
            scenarios = {europe = false, nafrica = false, eastern = false},
            name = 'Northern Territory',
            points = {{-7.696, 0.759}, {-7.189, 0.655}, {-6.991, 0.47}, {-6.996, -0.058}, {-7.273, 0.058}, {-7.387, -0.43},
                    {-7.876, -0.376}},
            adjacent = {'b21', 'b23#', 'b24', 'p17'},
            sv = 1,
            resources = {osr = 1}
        },
        b23 = {
            scenarios = {europe = false, nafrica = false, eastern = false},
            name = 'South Australia',
            points = {{-8.241, 0.887}, {-7.696, 0.759}, {-7.876, -0.376}, {-7.914, -0.756}, {-8.116, -1.03}, {-7.954, -1.474},
                    {-8.163, -1.482}, {-8.265, -0.618}},
            adjacent = {'b21#', 'b22#', 'b24#', 'p18'},
            sv = 2,
            resources = {iron = 1}
        },
        b24 = {
            scenarios = {europe = false, nafrica = false, eastern = false},
            name = 'Eastern Australia',
            points = {{-7.876, -0.376}, {-7.387, -0.43}, {-6.739, -0.683}, {-7.84, -1.486}, {-7.954, -1.474}, {-8.116, -1.03},
                    {-7.914, -0.756}},
            adjacent = {'b22', 'b23#', 'p17', 'p18$'},
            sv = 3,
            industry = 3,
            resources = {iron = 1, osr = 1}
        },
        b25 = {
            scenarios = {europe = false, nafrica = false, eastern = false},
            name = 'Papua',
            points = {{-6.429, -0.476}, {-6.357, -0.637}, {-6.529, -1.369}, {-6.895, -1.517}, {-6.6, -0.986}, {-6.739, -0.683}},
            adjacent = {'j24', 'p17', 'p18'},
            sv = 1
        },
        b26 = {
            scenarios = {europe = false, nafrica = false, eastern = false},
            name = 'New Hebrides',
            circle = {c = {-6.75, -2.81}, r = 0.25},
            adjacent = {'p19'}
        },
        b27 = {
            scenarios = {europe = false, nafrica = false, eastern = false},
            name = 'New Zealand',
            points = {{-6.785, -3.91}, {-6.786, -4.126}, {-6.734, -4.318}, {-7.022, -4.387}, {-7.098, -4.271}},
            adjacent = {'p19$', 'p20'},
            sv = 2
        },
        b28 = {
            scenarios = {eastern = false},
            name = 'Western Canada',
            points = {{1.432, -3.086}, {1.759, -3.06}, {2.026, -3.401}, {1.629, -3.571}, {1.157, -4.083}, {1.202, -4.355},
                    {1.519, -4.367}, {1.438, -4.76}, {1.598, -5.037}, {1.071, -5.251}, {-0.084, -5.513}, {-0.408, -5.122},
                    {-0.253, -4.881}, {-0.607, -4.385}, {-0.431, -3.89}, {0.224, -3.898}, {0.907, -3.625}},
            adjacent = {'a1', 'b29#', 'p4$', 'u2#', 'u3#', 'u4'},
            sv = 3,
            resources = {oil = 1, iron = 2, osr = 1}
        },
        b29 = {
            scenarios = {pacific = false, eastern = false},
            name = 'Eastern Canada',
            points = {{3.019, -3.249}, {2.84, -3.928}, {3.223, -3.828}, {3.35, -3.695}, {3.315, -4.025}, {3.136, -4.064}, {2.891, -4.102}, {2.97, -4.284},
                    {2.562, -4.989}, {2.356, -4.794}, {1.598, -5.037}, {1.438, -4.76}, {1.519, -4.367}, {2.239, -4.363},
                    {1.685, -3.725}, {2.667, -3.354}},
            adjacent = {'a1', 'a2', 'a9$', 'b28#', 'u1#', 'u2#'},
            sv = 4,
            industry = 4,
            resources = {iron = 1, osr = 1}
        },
        b30 = {
            scenarios = {pacific = false, eastern = false},
            name = 'The Guyanas',
            points = {{5.955, -4.21}, {6.088, -4.374}, {6.239, -4.661}, {5.888, -4.98}, {5.417, -4.778}, {5.501, -4.542}},
            adjacent = {'a12', 'n5', 'n6'}
        },
        c1 = {
            scenarios = {europe = false, nafrica = false, eastern = false},
            name = 'Honan',
            points = {{-3.623, 1.227}, {-3.402, 0.986}, {-3.309, 0.66}, {-3.76, 0.327}, {-4.105, 0.632}},
            adjacent = {'c2#', 'c3', 'c4', 'j4#', 'j5#'},
            sv = 1,
            mobilization = 1,
            resources = {osr = 1}
        },
        c2 = {
            scenarios = {europe = false, nafrica = false, eastern = false},
            name = 'Kwangsi',
            points = {{-4.228, 1.707}, {-4.017, 1.703}, {-3.754, 1.503}, {-3.623, 1.227}, {-4.105, 0.632}, {-4.31, 1.197}},
            adjacent = {'c1#', 'c3', 'j5', 'j6'},
            sv = 1,
            mobilization = 1,
            resources = {osr = 1}
        },
        c3 = {
            scenarios = {europe = false, nafrica = false, eastern = false},
            name = 'Szechwan Yunnan',
            points = {{-3.729, 2.299}, {-3.335, 2.168}, {-3.153, 1.9}, {-2.966, 1.694}, {-2.912, 1.381}, {-3.18, 0.983},
                    {-3.402, 0.986}, {-3.623, 1.227}, {-3.754, 1.503}, {-4.017, 1.703}},
            adjacent = {'c1', 'c2', 'c4', 'j6', 'j8', 'n18^', 'r9^'},
            sv = 1,
            mobilization = 1,
            resources = {osr = 2}
        },
        c4 = {
            scenarios = {europe = false, nafrica = false, eastern = false},
            name = 'Tsinghai Ningsia',
            points = {{-2.409, 1.704}, {-2.377, 0.745}, {-2.772, 0.684}, {-2.908, 0.326}, {-3.309, 0.66}, {-3.402, 0.986},
                    {-3.18, 0.983}, {-2.912, 1.381}, {-2.966, 1.694}, {-2.684, 1.546}},
            adjacent = {'b18^', 'c1', 'c3', 'c5', 'j4', 'n18^', 'n19'},
            sv = 2,
            mobilization = 2,
            resources = {iron = 1, osr = 2}
        },
        c5 = {
            scenarios = {europe = false, nafrica = false, eastern = false},
            name = 'Sinkiang',
            points = {{-1.579, 1.96}, {-1.706, 1.682}, {-1.586, 1.402}, {-1.742, 0.804}, {-2.377, 0.745}, {-2.409, 1.704},
                    {-2.229, 1.576}},
            adjacent = {'b18^', 'c4', 'j8^', 'n19', 'r9', 'r10'},
            sv = 1,
            mobilization = 1,
            resources = {iron = 1}
        },
        g1 = {
            scenarios = {pacific = false, nafrica = false},
            name = 'Greater Germany',
            points = {{3.856, 1.621}, {4.338, 1.172}, {4.593, 0.763}, {4.527, 0.588}, {4.595, 0.459}, {4.325, 0.029}, {4.064, 0.106}, {3.964, 0.154},
                    {3.737, 0.535}, {3.142, 0.582}, {3.065, 0.771}, {3.429, 0.85}, {3.602, 1.218}, {3.959, 1.015}},
            adjacent = {'a5$', 'a6', 'g2#', 'g3#', 'g4#', 'g8#', 'n13', 't1#', 't2#'},
            sv = 8,
            industry = 8,
            resources = {oil = 1, iron = 2, osr = 3}
        },
        g2 = {
            scenarios = {pacific = false, nafrica = false, eastern = false},
            name = 'Denmark',
            points = {{3.668, 0.276}, {3.964, 0.154}, {4.064, 0.106}, {3.938, -0.5}, {3.621, -0.288}},
            adjacent = {'a5', 'a6', 'g1#'},
            sv = 1,
            resources = {osr = 1}
        },
        g3 = {
            scenarios = {pacific = false, eastern = false},
            name = 'France',
            points = {{4.902, 1.345}, {5.129, 1.089}, {5.338, 1.174}, {5.57, 0.538}, {5.37, 0.31}, {5.577, -0.246},
                    {4.9, 0.041}, {4.325, 0.029}, {4.595, 0.459}, {4.527, 0.588}, {4.593, 0.763}, {4.848, 0.949}},
            adjacent = {'a6', 'a15$', 'g1#', 'm1$', 'n11#', 'n13', 't1#'},
            sv = 6,
            industry = 6,
            resources = {iron = 2, osr = 3}
        },
        g4 = {
            scenarios = {pacific = false, nafrica = false},
            name = 'Poland Slovakia Hungary',
            points = {{3.092, 1.933}, {3.369, 1.818}, {3.489, 1.898}, {3.856, 1.621}, {3.959, 1.015}, {3.602, 1.218},
                    {3.429, 0.85}, {3.065, 0.771}, {2.819, 0.941}, {2.875, 1.114}, {2.718, 1.201}, {2.877, 1.651}},
            adjacent = {'g1#', 'g5#', 'g6#', 'g7', 'g8#', 't2'},
            sv = 4,
            industry = 4,
            resources = {iron = 2, osr = 3}
        },
        g5 = {
            scenarios = {pacific = false},
            name = 'Bulgaria Rumania',
            points = {{2.956, 2.751}, {3.457, 2.637}, {3.301, 2.181}, {3.489, 1.898}, {3.369, 1.818}, {3.092, 1.933},
                    {2.877, 1.651}, {2.484, 1.788}, {2.346, 2.096}, {2.68, 2.322}, {2.812, 2.677}},
            adjacent = {'g4#', 'g6#', 'm4$', 'n14#', 't2#'},
            sv = 4,
            industry = 4,
            resources = {oil = 2, osr = 2}
        },
        g6 = {
            scenarios = {pacific = false, nafrica = false},
            name = 'Ukraine',
            points = {{2.136, 2.469}, {2.346, 2.096}, {2.484, 1.788}, {2.877, 1.651}, {2.718, 1.201}, {2.101, 1.288},
                    {1.788, 1.166}, {1.628, 1.239}, {1.557, 1.654}, {1.325, 1.757}, {1.652, 2.129}, {2.046, 2.236},
                    {1.874, 2.364}},
            adjacent = {'g4#', 'g5#', 'g7#', 'm4$', 'r5#', 'r6#'},
            sv = 4,
            industry = 4,
            resources = {oil = 1, osr = 3},
            occupied = 'ussr'
        },
        g7 = {
            scenarios = {pacific = false, nafrica = false},
            name = 'Belarus',
            points = {{2.101, 1.288}, {2.718, 1.201}, {2.875, 1.114}, {2.819, 0.941}, {2.499, 0.75}, {2.368, 0.502},
                    {1.86, 0.533}, {1.625, 0.726}, {1.788, 1.166}},
            adjacent = {'g4', 'g6#', 'g8#', 'r4#', 'r5#'},
            sv = 2,
            industry = 2,
            resources = {iron = 2, osr = 1},
            occupied = 'ussr'
        },
        g8 = {
            scenarios = {pacific = false, nafrica = false},
            name = 'Baltic States',
            points = {{2.819, 0.941}, {3.065, 0.771}, {3.142, 0.582}, {2.783, 0.075}, {2.464, 0.034}, {2.368, 0.502},
                    {2.499, 0.75}},
            adjacent = {'a5', 'g1#', 'g4#', 'g7#', 'r4#'},
            sv = 1,
            resources = {osr = 1}
        },
        g9 = {
            scenarios = {pacific = false, nafrica = false},
            name = 'Finland',
            points = {{2.464, 0.034}, {2.854, -0.134}, {2.479, -0.846}, {2.395, -1.183}, {2.15, -1.345}, {2.18, -0.292}},
            adjacent = {'a3', 'a5$', 'g10', 'n10#', 'r3', 'r4#'},
            sv = 2,
            resources = {iron = 2}
        },
        g10 = {
            scenarios = {pacific = false, nafrica = false, eastern = false},
            name = 'Norway',
            points = {{3.621, -0.288}, {3.938, -0.5}, {3.78, -1.091}, {3.359, -1.118}, {2.524, -1.487}, {2.15, -1.345},
                    {2.395, -1.183}, {2.69, -1.263}, {3.207, -0.92}},
            adjacent = {'a3', 'a5$', 'a6', 'g9', 'n10#'},
            sv = 2,
            resources = {iron = 1}
        },
        g11 = {
            scenarios = {pacific = false, eastern = false},
            name = 'French Morocco',
            points = {{6.208, 2.655}, {6.743, 2.2}, {6.626, 1.96}, {6.401, 1.564}, {6.008, 2.131}, {5.931, 2.525}},
            adjacent = {'a15$', 'a16', 'g12#', 'g15^', 'm1'},
            sv = 2,
            resources = {oil = 1, osr = 1}
        },
        g12 = {
            scenarios = {pacific = false, eastern = false},
            name = 'Algeria',
            points = {{5.103, 3.614}, {5.706, 3.407}, {6.208, 2.655}, {5.931, 2.525}, {6.008, 2.131}, {5.799, 2.113},
                    {5.383, 2.422}, {5.319, 2.736}, {5.449, 2.955}},
            adjacent = {'a17^', 'b13^', 'b14^', 'g11#', 'g13#', 'g15^', 'm2$'},
            sv = 2,
            resources = {oil = 1}
        },
        g13 = {
            scenarios = {pacific = false, eastern = false},
            name = 'Tunisia',
            points = {{4.87, 3.671}, {5.103, 3.614}, {5.449, 2.955}, {5.319, 2.736}, {5.383, 2.422}, {4.866, 2.7},
                    {4.875, 3.097}, {4.726, 3.296}, {4.9, 3.531}},
            adjacent = {'b13^', 'b14^', 'g12#', 'g15^', 'm2$', 't5'},
            sv = 1,
            resources = {iron = 1}
        },
        g14 = {
            scenarios = {pacific = false, eastern = false},
            name = 'Crete',
            circle = {c = {3.135, 3.558}, r = 0.23},
            adjacent = {'m3'},
            sv = 1
        },
        g15 = {
            scenarios = {pacific = false, eastern = false},
            name = 'French West Africa',
            points = {{5.817, 4.618}, {6.304, 3.973}, {6.149, 3.815}, {6.27, 3.557}, {6.504, 3.571}, {6.602, 3.254},
                    {6.405, 3.196}, {6.064, 3.414}, {5.665, 4.237}},
            adjacent = {'a17$', 'b14', 'b15', 'g11^', 'g12^', 'g13^', 't5^'},
            sv = 1,
            resources = {osr = 1}
        },
        g16 = {
            scenarios = {pacific = false, eastern = false},
            name = 'Madagascar',
            points = {{1.782, 7.56}, {2.019, 7.423}, {1.758, 7.204}, {1.273, 7.097}, {1.216, 7.219}},
            adjacent = {'i4'}
        },
        i1 = {
            scenarios = {eastern = false},
            points = {{0.36, 4.996}, {-0.144, 4.581}, {-0.371, 4.112}, {-0.066, 3.992}, {0.245, 4.226}, {0.733, 3.826}, {0.542, 3.612},
                    {-0.227, 3.863}, {-0.646, 3.76}, {-0.962, 3.648}, {-1.478, 3.891}, {-2.052, 4.7}, {-0.915, 4.942}},
            adjacent = {'b16$', 'b17$', 'b18$', 'i2', 'n15$'},
            convoys = {{b16 = {oil = 1, x = 0.72, z = 3.64}, b17 = {oil = 1, x = 0.33, z = 3.76}}, {b18 = {osr = 1, x = -1.69, z = 4.24}}}
        },
        i2 = {
            scenarios = {eastern = false},
            points = {{-0.417, 5.981}, {0.786, 5.925}, {0.42, 5.57}, {0.762, 5.6}, {0.694, 5.187}, {0.36, 4.996},
                    {-0.915, 4.942}, {-2.052, 4.7}, {-2.245, 4.873}, {-2.477, 5.621}, {-1.414, 5.862}},
            adjacent = {'b7', 'b18', 'b20', 'i1', 'i3', 'i6', 'i7', 'm5', 'n15'},
            islands = true
        },
        i3 = {
            scenarios = {pacific = false, eastern = false},
            points = {{-0.485, 7.008}, {0.789, 7}, {1.984, 6.813}, {2.043, 6.7}, {2.022, 6.42}, {1.694, 6.261},
                    {0.786, 5.925}, {-0.417, 5.981}},
            adjacent = {'b7', 'b8', 'i2', 'i4', 'i6', 'n17'}
        },
        i4 = {
            scenarios = {pacific = false, eastern = false},
            points = {{0.688, 8.267}, {2.325, 7.962}, {2.1, 7}, {1.984, 6.813}, {0.789, 7}, {-0.485, 7.008},
                    {-0.82, 6.978}, {-0.968, 8.251}},
            adjacent = {'a19', 'g16', 'i3', 'i5', 'i6', 'n17'},
            islands = true
        },
        i5 = {
            scenarios = {europe = false, nafrica = false, eastern = false},
            points = {{-0.968, 8.251}, {-0.82, 6.978}, {-1.849, 6.787}, {-2.763, 6.495}, {-3.615, 6.139}, {-4.135, 7.219},
                    {-2.836, 7.808}},
            adjacent = {'i4', 'i6', 'i7', 'i8'}
        },
        i6 = {
            scenarios = {eastern = false},
            points = {{-0.485, 7.008}, {-0.417, 5.981}, {-1.414, 5.862}, {-2.477, 5.621}, {-2.763, 6.495}, {-1.849, 6.787},
                    {-0.82, 6.978}},
            adjacent = {'b20', 'i2', 'i3', 'i4', 'i5', 'i7'},
            islands = true
        },
        i7 = {
            scenarios = {eastern = false, nafrica = false},
            points = {{-2.763, 6.495}, {-2.477, 5.621}, {-2.245, 4.873}, {-2.437, 4.524}, {-3.543, 4.005}, {-4.484, 5.6},
                    {-3.615, 6.139}},
            adjacent = {'b18', 'b19', 'i2', 'i5', 'i6', 'i8', 'i9', 'i10'},
            islands = true
        },
        i8 = {
            scenarios = {eastern = false, nafrica = false},
            points = { {-4.135, 7.219}, {-3.615, 6.139}, {-4.484, 5.6}, {-5.285, 4.983}, {-5.949, 4.311}, {-6.618, 5.033},
                    {-5.898, 5.86}, {-5.038, 6.618}},
            adjacent = {'i5', 'i7', 'i9', 'p16'}
        },
        i9 = {
            scenarios = {eastern = false, nafrica = false},
            points = {{-4.484, 5.6}, {-3.543, 4.005}, {-4.182, 3.571}, {-4.323, 3.615}, {-5.115, 3.587}, {-4.47, 3.966},
                    {-4.39, 4.194}, {-5.184, 3.9}, {-5.56, 3.881}, {-5.949, 4.311}, {-5.285, 4.983}},
            adjacent = {'i7', 'i8', 'i10', 'j7', 'j9', 'j10', 'p15@', 'p16'},
            canals = {p15 = {'j9'}}
        },
        i10 = {
            scenarios = {eastern = false, nafrica = false},
            points = {{-2.437, 4.524}, {-2.301, 4.114}, {-2.63, 3.09}, {-2.957, 2.814}, {-3.323, 2.957}, {-3.501, 3.184},
                    {-3.695, 2.891}, {-3.975, 3.095}, {-4.182, 3.571}, {-3.543, 4.005}},
            adjacent = {'b18$', 'i7', 'i9', 'j7', 'j8'}
        },
        j1 = {
            scenarios = {europe = false, nafrica = false, eastern = false},
            name = 'Japan',
            points = {{-4.075, -0.517}, {-3.985, -0.808}, {-3.987, -1.369}, {-3.57, -1.52}, {-3.362, -1.733}, {-3.626, -1.95},
                    {-3.769, -1.64}, {-4.184, -1.802}, {-4.277, -1.357}, {-4.215, -0.76}, {-4.285, -0.574}},
            adjacent = {'p0', 'p1$'},
            sv = 8,
            industry = 8,
            resources = {iron = 2, osr = 2}
        },
        j2 = {
            scenarios = {europe = false, nafrica = false, eastern = false},
            name = 'Korea',
            points = {{-3.812, -0.315}, {-3.277, -0.317}, {-3.283, -0.954}, {-3.49, -0.644}, {-3.883, -0.573}},
            adjacent = {'j3#', 'p0', 'p1$', 'r16'},
            sv = 2,
            resources = {iron = 1, osr = 1}
        },
        j3 = {
            scenarios = {europe = false, nafrica = false, eastern = false},
            name = 'Manchuria',
            points = {{-2.732, -0.273}, {-2.458, -0.47}, {-2.109, -0.671}, {-2.21, -0.91}, {-2.861, -1.088}, {-2.878, -1.317},
                    {-3.283, -0.954}, {-3.277, -0.317}, {-2.968, -0.394}},
            adjacent = {'j2#', 'j4#', 'n19', 'p0$', 'r14', 'r16'},
            sv = 3,
            mobilization = 3,
            resources = {iron = 3, osr = 1},
            occupied = 'china'
        },
        j4 = {
            scenarios = {europe = false, nafrica = false, eastern = false},
            name = 'Peiping',
            points = {{-3.309, 0.66}, {-2.908, 0.326}, {-2.769, 0.125}, {-2.732, -0.273}, {-2.968, -0.394}, {-3.277, -0.317}, {-3.518, 0.142}, {-3.87, 0.118},
                    {-3.76, 0.327}},
            adjacent = {'c1#', 'c4', 'j3#', 'j5#', 'n19', 'p0$'},
            sv = 2,
            industry = 2,
            resources = {iron = 1, osr = 2},
            occupied = 'china'
        },
        j5 = {
            scenarios = {europe = false, nafrica = false, eastern = false},
            name = 'Chekiang Kwangtung',
            points = {{-4.228, 1.707}, {-4.31, 1.197}, {-4.105, 0.632}, {-3.76, 0.327}, {-3.87, 0.118}, {-4.197, 0.081},
                    {-4.458, 0.466}, {-4.545, 0.906}, {-4.445, 1.463}},
            adjacent = {'c1#', 'c2', 'j4#', 'j6', 'p0$', 'p14$'},
            sv = 2,
            mobilization = 2,
            resources = {iron = 2, osr = 1},
            occupied = 'china'
        },
        j6 = {
            scenarios = {europe = false, nafrica = false, eastern = false},
            name = 'Indochina',
            points = {{-4.931, 3.014}, {-4.507, 2.894}, {-4.399, 2.723}, {-4.594, 2.394}, {-4.205, 2.256}, {-3.988, 2.43},
                    {-3.729, 2.299}, {-4.017, 1.703}, {-4.228, 1.707}, {-4.316, 2.057}, {-4.816, 2.139}, {-4.994, 2.316},
                    {-5.073, 2.512}},
            adjacent = {'c2', 'c3', 'j5', 'j7#', 'j8', 'p14', 'p15$'},
            sv = 1,
            resources = {osr = 1}
        },
        j7 = {
            scenarios = {europe = false, nafrica = false, eastern = false},
            name = 'Thailand',
            points = {{-4.323, 3.615}, {-4.182, 3.571}, {-4.1, 3.115}, {-3.879, 2.792}, {-3.626, 2.72}, {-3.729, 2.299},
                    {-3.988, 2.43}, {-4.205, 2.256}, {-4.594, 2.394}, {-4.399, 2.723}, {-4.507, 2.894}, {-4.174, 2.991},
                    {-4.4, 3.362}},
            adjacent = {'i9', 'i10', 'j6#', 'j8#', 'j9#', 'p15'},
            sv = 1,
            resources = {osr = 2}
        },
        j8 = {
            scenarios = {europe = false, nafrica = false, eastern = false},
            name = 'Burma',
            points = {{-4.182, 3.571}, {-3.975, 3.095}, {-3.695, 2.891}, {-3.501, 3.184}, {-3.323, 2.957}, {-2.957, 2.814},
                    {-2.951, 2.22}, {-3.153, 1.9}, {-3.335, 2.168}, {-3.729, 2.299}, {-3.626, 2.72}, {-3.879, 2.792},
                    {-4.1, 3.115}},
            adjacent = {'b18', 'c3', 'i10', 'j6', 'j7#'},
            sv = 1,
            resources = {osr = 1}
        },
        j9 = {
            scenarios = {europe = false, nafrica = false, eastern = false},
            name = 'Malaya',
            points = {{-5.115, 3.587}, {-4.323, 3.615}, {-4.4, 3.362}, {-4.932, 3.258}, {-5.152, 3.418}},
            adjacent = {'i9', 'j7#', 'p15$'},
            sv = 2,
            resources = {osr = 2}
        },
        j10 = {
            scenarios = {europe = false, nafrica = false, eastern = false},
            name = 'Sumatra',
            points = {{-4.39, 4.194}, {-4.47, 3.966}, {-5.115, 3.587}, {-5.312, 3.583}, {-5.732, 3.386}, {-6.004, 3.571}, {-5.56, 3.881}, {-5.184, 3.9}},
            adjacent = {'i9', 'p15', 'p16$'},
            sv = 2,
            resources = {oil = 3}
        },
        j11 = {
            scenarios = {europe = false, nafrica = false, eastern = false},
            name = 'Java',
            points = {{-6.228, 3.511}, {-6.035, 3.443}, {-6.361, 3.056}, {-6.812, 2.138}, {-6.686, 2.924}},
            adjacent = {'p16$'},
            sv = 2,
            resources = {oil = 2}
        },
        j12 = {
            scenarios = {europe = false, nafrica = false, eastern = false},
            name = 'Borneo',
            points = {{-5.89, 2.98}, {-5.51, 2.945}, {-5.525, 1.825}, {-5.795, 1.72}, {-6.27, 2.48}},
            adjacent = {'p15$'},
            sv = 2,
            resources = {oil = 2, osr = 1}
        },
        j13 = {
            scenarios = {europe = false, nafrica = false, eastern = false},
            name = 'Celebes',
            points = {{-6.295, 2.003}, {-5.871, 1.57}, {-6.118, 1.03}, {-6.213, 1.485}, {-6.51, 1.6}},
            adjacent = {'p15'}
        },
        j14 = {
            scenarios = {europe = false, nafrica = false, eastern = false},
            name = 'Philippines',
            circle = {c = {-5.354, 1.017}, r = 0.44},
            adjacent = {'p14$'},
            sv = 2,
            resources = {iron = 1, osr = 2}
        },
        j15 = {
            scenarios = {europe = false, nafrica = false, eastern = false},
            name = 'Hainan',
            circle = {c = {-4.653, 1.72}, r = 0.25},
            adjacent = {'p14'}
        },
        j16 = {
            scenarios = {europe = false, nafrica = false, eastern = false},
            name = 'Formosa',
            circle = {c = {-4.721, 0.304}, r = 0.26},
            adjacent = {'p0', 'p14'},
            sv = 1
        },
        j17 = {
            scenarios = {europe = false, nafrica = false, eastern = false},
            name = 'Okinawa',
            circle = {c = {-4.748, -0.368}, r = 0.26},
            adjacent = {'p0', 'p1', 'p13', 'p14'},
            sv = 1
        },
        j18 = {
            scenarios = {europe = false, nafrica = false, eastern = false},
            name = 'Palau',
            circle = {c = {-5.638, -0.02}, r = 0.26},
            adjacent = {'p13', 'p14'}
        },
        j19 = {
            scenarios = {europe = false, nafrica = false, eastern = false},
            name = 'Japanese Sakhalin',
            circle = {c = {-3.075, -1.866}, r = 0.21},
            adjacent = {'p1'}
        },
        j20 = {
            scenarios = {europe = false, nafrica = false, eastern = false},
            name = 'Iwo Jima',
            circle = {c = {-4.725, -1.732}, r = 0.25},
            adjacent = {'p1'},
            sv = 1
        },
        j21 = {
            scenarios = {europe = false, nafrica = false, eastern = false},
            name = 'Mariana Islands',
            circle = {c = {-5.195, -2.115}, r = 0.25},
            adjacent = {'p1', 'p12', 'p13'}
        },
        j22 = {
            scenarios = {europe = false, nafrica = false, eastern = false},
            name = 'Caroline Islands',
            circle = {c = {-5.642, -0.948}, r = 0.26},
            adjacent = {'p13$'},
            sv = 2
        },
        j23 = {
            scenarios = {europe = false, nafrica = false, eastern = false},
            name = 'New Britain',
            circle = {c = {-6.28, -1.7}, r = 0.25},
            adjacent = {'p13'},
            sv = 1
        },
        j24 = {
            scenarios = {europe = false, nafrica = false, eastern = false},
            name = 'New Guinea',
            points = {{-6.164, -0.107}, {-6.059, -0.484}, {-6.244, -1.136}, {-6.529, -1.369}, {-6.357, -0.637}, {-6.429, -0.476}},
            adjacent = {'b25', 'p13'},
            sv = 1
        },
        j25 = {
            scenarios = {europe = false, nafrica = false, eastern = false},
            name = 'Solomon Islands',
            circle = {c = {-6.707, -2.092}, r = 0.26},
            adjacent = {'p13', 'p18', 'p19'},
            sv = 1
        },
        j26 = {
            scenarios = {europe = false, nafrica = false, eastern = false},
            name = 'Wake Island',
            circle = {c = {-4.225, -3.29}, r = 0.25},
            adjacent = {'p2', 'p11', 'p12'}
        },
        j27 = {
            scenarios = {europe = false, nafrica = false, eastern = false},
            name = 'Marshall Islands',
            circle = {c = {-5.2, -3.74}, r = 0.25},
            adjacent = {'p11', 'p12', 'p20'}
        },
        j28 = {
            scenarios = {europe = false, nafrica = false, eastern = false},
            name = 'Gilbert Islands',
            circle = {c = {-5.84, -3.963}, r = 0.25},
            adjacent = {'p12', 'p19', 'p20'}
        },
        m1 = {
            scenarios = {pacific = false, eastern = false},
            points = {{6.008, 2.131}, {6.401, 1.564}, {6.027, 1.446}, {5.573, 1.12}, {5.338, 1.174}, {5.129, 1.089},
                    {4.902, 1.345}},
            adjacent = {'a15@', 'b3$', 'g3$', 'g11', 'm2', 'n11$'},
            canals = {a15 = {'b3'}},
            islands = true
        },
        m2 = {
            scenarios = {pacific = false, eastern = false},
            points = {{4.206, 3.636}, {4.726, 3.296}, {4.875, 3.097}, {4.866, 2.7}, {5.383, 2.422}, {5.799, 2.113},
                    {6.008, 2.131}, {4.902, 1.345}, {4.65, 1.49}, {4.354, 2.709}, {4.052, 2.616}, {4.283, 1.589},
                    {4.068, 1.709}, {3.753, 2.478}, {3.743, 2.985}},
            adjacent = {'b4', 'g12$', 'g13$', 'm1', 'm3', 't1$', 't2', 't3', 't4', 't5$'},
            convoys = {{g12 = {oil = 1, x = 5.64, z = 2.21}}, {g13 = {iron = 1, x = 4.9, z = 2.69}},
                    {t1 = {iron = 1, osr = 1, x = 4.37, z = 2.35}}, {t5 = {oil = 1, iron = 1, x = 4.37, z = 3.55}}},
            islands = true
        },
        m3 = {
            scenarios = {pacific = false, eastern = false},
            points = {{2.422, 4.09}, {3.29, 3.88}, {3.72, 3.68}, {3.894, 3.879}, {4.206, 3.636}, {3.743, 2.985},
                    {3.678, 3.305}, {3.271, 3.171}, {3.351, 2.879}, {2.956, 2.751}, {2.843, 3.425}, {1.876, 3.447},
                    {1.969, 3.782}, {2.235, 3.948}},
            adjacent = {'b5$', 'b16', 'g14', 'm2', 'm4@', 'm5@', 'n14', 't2$', 't5'},
            canals = {m4 = {'n14'}, m5 = {'b5'}},
            convoys = {{b5 = {oil = 1, x = 2.65, z = 4.02}}, {t2 = {oil = 1, iron = 1, osr = 1, x = 3.37, z = 3.15}}},
            islands = true
        },
        m4 = {
            scenarios = {pacific = false, nafrica = false},
            points = {{1.357, 2.896}, {2.047, 2.794}, {2.664, 2.874}, {2.812, 2.677}, {2.68, 2.322}, {2.346, 2.096}, {2.136, 2.469},
                    {1.874, 2.364}, {2.046, 2.236}, {1.652, 2.129}, {1.716, 2.381}, {1.207, 2.734}},
            adjacent = {'g5$', 'g6$', 'm3@', 'n14', 'r6'},
            canals = {m3 = {'n14'}}
        },
        m5 = {
            scenarios = {pacific = false, eastern = false},
            points = {{0.762, 5.6}, {1.3374, 5.546}, {1.81, 5.057}, {2.097, 4.686}, {2.26, 4.26}, {2.112, 4.11},
                    {1.484, 4.684}, {1.18, 5.342}, {0.694, 5.187}},
            adjacent = {'b5', 'b6', 'b7', 'i2', 'm3@', 'n15'},
            canals = {m3 = {'b5'}}
        },
        m6 = {
            scenarios = {pacific = false, nafrica = false},
            points = {{0.625, 2.9}, {0.535, 2.686}, {0.957, 2.255}, {0.879, 2.126}, {0.721, 1.954}, {0.491, 1.949},
                    {0.582, 2.233}, {0.387, 2.405}, {0.145, 2.867}},
            adjacent = {'b17', 'r6', 'r7', 'r8', 'r9'}
        },
        n1 = {
            scenarios = {eastern = false},
            name = 'Mexico',
            points = {{3.277, -6.277}, {3.294, -6.478}, {3.178, -6.683}, {3.277, -6.942}, {2.911, -6.939}, {2.557, -7.157},
                    {1.776, -7.211}, {1.665, -7.038}, {0.909, -6.811}, {1.321, -7.141}, {1.041, -7.11}, {0.449, -6.631},
                    {1.357, -6.489}, {2.282, -6.548}, {2.363, -6.734}, {2.589, -6.854}, {2.975, -6.632}, {2.994, -6.477}},
            adjacent = {'a11$', 'n2', 'p5', 'p6$', 'p7', 'u2#', 'u3#'},
            army = {infantry = 3, artillery = 1},
            trade = 'iron',
            allied = true
        },
        n2 = {
            scenarios = {eastern = false},
            name = 'Central America',
            points = {{4.653, -6.237}, {4.732, -6.353}, {4.296, -6.696}, {3.721, -6.773}, {3.277, -6.942}, {3.178, -6.683},
                    {3.294, -6.478}, {3.411, -6.595}, {3.6, -6.416}, {3.779, -6.34}, {4.102, -6.588}},
            adjacent = {'a11', 'a12', 'n1', 'n4', 'p7'},
            allied = true
        },
        n3 = {
            scenarios = {pacific = false, eastern = false},
            name = 'West Indies',
            circle = {c = {4.209, -5.588}, r = 0.44},
            adjacent = {'a10', 'a12'},
            allied = true
        },
        n4 = {
            scenarios = {eastern = false, nafrica = false},
            name = 'Colombia',
            points = {{4.83, -5.542}, {5.09, -5.765}, {5.51, -5.597}, {5.81, -5.623}, {5.807, -5.89}, {5.022, -6.58},
                    {4.732, -6.353}, {4.653, -6.237}, {4.567, -6.074}},
            adjacent = {'a12$', 'n2', 'n5', 'n6', 'p7$'},
            army = {infantry = 4},
            trade = 'osr'
        },
        n5 = {
            scenarios = {pacific = false, nafrica = false, eastern = false},
            name = 'Venezuela',
            points = {{5.417, -4.778}, {5.888, -4.98}, {5.858, -5.229}, {6.088, -5.26}, {5.81, -5.623}, {5.51, -5.597}, {5.09, -5.765}, {4.83, -5.542}},
            adjacent = {'a12$', 'b30', 'n4', 'n6'},
            army = {infantry = 4},
            trade = 'oil'
        },
        n6 = {
            scenarios = {pacific = false, eastern = false},
            name = 'Brazil',
            points = {{6.92, -2.995}, {7.57, -3.354}, {7.049, -4.338}, {6.48, -5.158}, {5.807, -5.89}, {5.81, -5.623}, {6.088, -5.26},
                    {5.858, -5.229}, {5.888, -4.98}, {6.239, -4.661}, {6.088, -4.374}, {6.143, -4.051}},
            adjacent = {'a12', 'a13$', 'b30', 'n4', 'n5'},
            army = {infantry = 4, artillery = 2, fighter = 1},
            trade = 'iron',
            allied = true
        },
        n7 = {
            scenarios = {pacific = false, eastern = false},
            name = 'Greenland',
            points = {{1.66, -1.895}, {2.123, -2.038}, {2.37, -2.509}, {2.81, -2.731}, {2.518, -2.988}, {1.56, -2.83}},
            adjacent = {'a2', 'a3'},
            allied = true
        },
        n8 = {
            scenarios = {pacific = false, eastern = false},
            name = 'Iceland',
            circle = {c = {3.49, -2.24}, r = 0.25},
            adjacent = {'a2', 'a7', 'a8'},
            allied = true
        },
        n9 = {
            scenarios = {pacific = false, nafrica = false, eastern = false},
            name = 'Ireland',
            points = {{5.242, -0.803}, {5.664, -1.048}, {5.371, -1.395}, {5.032, -1.338}},
            adjacent = {'a7', 'b1'},
            army = {infantry = 3}
        },
        n10 = {
            scenarios = {pacific = false, nafrica = false},
            name = 'Sweden',
            points = {{3.668, 0.276}, {3.621, -0.288}, {3.207, -0.92}, {2.69, -1.263}, {2.395, -1.183}, {2.479, -0.846},
                    {2.983, -0.589}, {3.036, -0.109}},
            adjacent = {'a5$', 'g9#', 'g10#'},
            army = {infantry = 4, artillery = 1, fighter = 1},
            trade = 'iron'
        },
        n11 = {
            scenarios = {pacific = false, nafrica = false, eastern = false},
            name = 'Spain',
            points = {{6.027, 1.446}, {6.476, 1.19}, {6.096, 0.563}, {6.351, 0.343}, {6.18, 0.17}, {5.57, 0.538}, {5.338, 1.174}, {5.573, 1.12}},
            adjacent = {'a15', 'b3', 'g3#', 'm1$', 'n12'},
            islands = true,
            army = {infantry = 6, artillery = 2, fighter = 1},
            trade = 'osr'
        },
        n12 = {
            scenarios = {pacific = false, nafrica = false, eastern = false},
            name = 'Portugal',
            points = {{6.476, 1.19}, {6.719, 1.051}, {6.351, 0.343}, {6.096, 0.563}},
            adjacent = {'a15', 'n11'},
            army = {infantry = 4}
        },
        n13 = {
            scenarios = {pacific = false, nafrica = false},
            name = 'Switzerland',
            points = {{4.541, 1.184}, {4.848, 0.949}, {4.593, 0.763}, {4.338, 1.172}},
            adjacent = {'g1', 'g3', 't1'},
            army = {infantry = 3}
        },
        n14 = {
            scenarios = {pacific = false, nafrica = false},
            name = 'Turkey',
            points = {{1.876, 3.447}, {2.843, 3.425}, {2.956, 2.751}, {2.812, 2.677}, {2.664, 2.874}, {2.047, 2.794}, {1.357, 2.896}, {1.207, 2.734}, {0.917, 2.925},
                    {0.881, 3.154}},
            adjacent = {'b16#', 'b17', 'g5#', 'm3', 'm4', 'r6', 't2'},
            army = {infantry = 6, artillery = 2, fighter = 1}
        },
        n15 = {
            scenarios = {pacific = false, nafrica = false, eastern = false},
            name = 'Arabia',
            points = {{1.18, 5.342}, {1.484, 4.684}, {2.112, 4.11}, {1.575, 3.971}, {1.618, 3.828}, {0.733, 3.826},
                    {0.245, 4.226}, {-0.066, 3.992}, {-0.371, 4.112}, {-0.144, 4.581}, {0.36, 4.996}, {0.694, 5.187}},
            adjacent = {'b5', 'b6', 'i1$', 'i2', 'm5'},
            army = {infantry = 3},
            trade = 'oil'
        },
        n16 = {
            scenarios = {pacific = false, nafrica = false, eastern = false},
            name = 'Angola',
            points = {{3.605, 6.692}, {4.351, 6.414}, {4.257, 6.164}, {4.323, 5.96}, {3.515, 6.416}},
            adjacent = {'a19', 'b9', 'b10', 'b11'},
            army = {infantry = 3}
        },
        n17 = {
            scenarios = {pacific = false, nafrica = false, eastern = false},
            name = 'Mozambique',
            points = {{2.893, 7.232}, {2.887, 7.122}, {2.578, 6.589}, {2.043, 6.7}, {1.984, 6.813}, {2.1, 7}},
            adjacent = {'a19', 'b8', 'b9', 'b10', 'i3', 'i4'},
            army = {infantry = 3}
        },
        n18 = {
            scenarios = {europe = false, nafrica = false, eastern = false},
            name = 'Afghanistan',
            points = {{-0.519, 3.411}, {-0.419, 2.861}, {-0.888, 2.288}, {-1.579, 1.96}, {-1.504, 2.137}, {-1.28, 2.275},
                    {-1.002, 3.148}},
            adjacent = {'b17', 'c3^', 'c4^', 'b18', 'r9'},
            army = {infantry = 4}
        },
        n19 = {
            scenarios = {europe = false, nafrica = false, eastern = false},
            name = 'Mongolia',
            points = {{-1.742, 0.804}, {-1.728, 0.617}, {-2.417, -0.248}, {-2.458, -0.47}, {-2.732, -0.273}, {-2.769, 0.125},
                    {-2.908, 0.326}, {-2.772, 0.684}, {-2.377, 0.745}},
            adjacent = {'c4', 'c5', 'j3', 'j4', 'r10', 'r14'},
            army = {infantry = 3}
        },
        p0 = {
            scenarios = {europe = false, nafrica = false, eastern = false},
            points = {{-4.458, 0.466}, {-4.197, 0.081}, {-3.87, 0.118}, {-3.518, 0.142}, {-3.277, -0.317}, {-3.812, -0.315},
                    {-3.883, -0.573}, {-3.985, -0.808}, {-4.075, -0.517}, {-4.285, -0.574}, {-4.215, -0.76}, {-4.85, -0.587},
                    {-4.793, -0.34}},
            adjacent = {'j1', 'j2', 'j3$', 'j4$', 'j5$', 'j16', 'j17', 'p1', 'p14'},
            islands = true,
            convoys = {{j3 = {iron = 1, osr = 1, x = -3.27, z = -0.32}, j4 = {iron = 1, osr = 1, x = -3.47, z = 0.08}, j5 = {iron = 1, osr = 1, x = -4.02, z = 0.11}}}
        },
        p1 = {
            scenarios = {europe = false, nafrica = false, eastern = false},
            points = {{-3.883, -0.573}, {-3.49, -0.644}, {-3.283, -0.954}, {-3.347, -1.18}, {-3.068, -1.592}, {-2.544, -1.793},
                    {-2.337, -1.483}, {-2.061, -1.937}, {-2.09, -2.255}, {-4.31, -2.255}, {-5.074, -2.255}, {-5.035, -1.436}, {-4.85, -0.587},
                    {-4.215, -0.76}, {-4.277, -1.357}, {-4.184, -1.802}, {-3.769, -1.64}, {-3.626, -1.95}, {-3.362, -1.733},
                    {-3.57, -1.52}, {-3.987, -1.369}, {-3.985, -0.808}},
            adjacent = {'j1$', 'j2$', 'j17', 'j19', 'j20', 'j21', 'p0', 'p2', 'p12', 'p13', 'r16$', 'r18'},
            islands = true,
            convoys = {{j1 = {iron = 1, osr = 1, x = -4.29, z = -1.36}}, {j2 = {iron = 1, osr = 1, x = -3.78, z = -0.6}}, {r16 = {iron = 1, x = -2.48, z = -1.65}}}
        },
        p2 = {
            scenarios = {europe = false, nafrica = false, eastern = false},
            points = {{-4.31, -2.255}, {-2.09, -2.255}, {-2.17, -2.482}, {-1.947, -2.603}, {-2, -2.835}, {-2.351, -2.615},
                    {-2.982, -2.686}, {-2.485, -2.935}, {-2.146, -2.943}, {-1.888, -3.239}, {-1.559, -3.277}, {-3.249, -4.493},
                    {-3.578, -3.886}, {-3.802, -3.264}, {-4.219, -3.379}},
            adjacent = {'j26', 'p1', 'p3', 'p11', 'p12', 'r17'},
            islands = true
        },
        p3 = {
            scenarios = {europe = false, nafrica = false, eastern = false},
            points = {{-1.559, -3.277}, {-1.512, -3.433}, {-1.25, -3.435}, {-1.236, -3.752}, {-1.522, -3.806}, {-1.575, -4.258}, {-1.374, -4.429}, {-2.263, -5.783}, {-2.537, -5.625},
                    {-3.016, -5.182}, {-3.46, -4.651}, {-3.249, -4.493}},
            adjacent = {'p2', 'p4', 'p9', 'p10', 'p11', 'r17', 'u4', 'u5', 'u7'},
            islands = true
        },
        p4 = {
            scenarios = {europe = false, nafrica = false, eastern = false},
            points = {{-0.782, -4.376}, {-0.408, -5.122}, {-0.084, -5.513}, {-1.058, -6.329}, {-1.72, -6.089}, {-2.263, -5.783}, {-1.374, -4.429}},
            adjacent = {'b28$', 'p3', 'p5', 'p9', 'u4$'},
            convoys = {{u4 = {oil = 1, iron = 1, osr = 1, x = -0.9, z = -4.19}}, {b28 = {oil = 1, iron = 1, osr = 1, x = -0.26, z = -5.17}}}
        },
        p5 = {
            scenarios = {europe = false, nafrica = false, eastern = false},
            points = {{-0.084, -5.513}, {-0.168, -5.877}, {0.032, -6.468}, {0.449, -6.631}, {1.041, -7.11}, {1.112, -7.502}, {-0.132, -7.612},
                    {-1.311, -7.452}, {-1.058, -6.329}},
            adjacent = {'n1', 'p4', 'p6', 'p8', 'p9', 'u3$'},
            convoys = {{u4 = {oil = 1, iron = 1, osr = 1, x = -0.08, z = -6.16}}}
        },
        p6 = {
            scenarios = {europe = false, nafrica = false, eastern = false},
            points = {{0.909, -6.811}, {1.665, -7.038}, {1.776, -7.211}, {2.557, -7.157}, {2.911, -6.939}, {3.258, -7.608},
                    {2.238, -7.975}, {1.225, -8.197}, {1.112, -7.502}, {1.041, -7.11}, {1.321, -7.141}},
            adjacent = {'n1$', 'p5', 'p7', 'p8'}
        },
        p7 = {
            scenarios = {europe = false, nafrica = false, eastern = false},
            points = {{4.732, -6.353}, {5.022, -6.58}, {4.127, -7.18}, {3.258, -7.608}, {2.911, -6.939}, {3.277, -6.942},
                    {3.721, -6.773}, {4.296, -6.696}},
            adjacent = {'a12@', 'n1', 'n2', 'n4$', 'p6'},
            canals = {a12 = {'n2'}}
        },
        p8 = {
            scenarios = {europe = false, nafrica = false, eastern = false},
            points = {{-1.311, -7.452}, {-0.132, -7.612}, {1.112, -7.502}, {1.225, -8.197}, {-0.122, -8.288}, {-1.494, -8.153}},
            adjacent = {'p5', 'p6', 'p9'}
        },
        p9 = {
            scenarios = {europe = false, nafrica = false, eastern = false},
            points = {{-2.537, -5.625}, {-2.263, -5.783}, {-1.72, -6.089}, {-1.058, -6.329}, {-1.311, -7.452}, {-1.494, -8.153}, {-2.632, -7.866}, {-3.746, -7.398}},
            adjacent = {'p3', 'p4', 'p5', 'p8', 'p10', 'u6$', 'u7', 'u8'},
            islands = true
        },
        p10 = {
            scenarios = {europe = false, nafrica = false, eastern = false},
            points = {{-3.46, -4.651}, {-3.016, -5.182}, {-2.537, -5.625}, {-3.746, -7.398}, {-4.735, -6.809}, {-5.556, -6.15}, {-4.355, -5.28}},
            adjacent = {'p3', 'p9', 'p11', 'p20', 'u7', 'u8', 'u9'},
            islands = true
        },
        p11 = {
            scenarios = {europe = false, nafrica = false, eastern = false},
            points = {{-3.802, -3.264}, {-3.578, -3.886}, {-3.249, -4.493}, {-3.46, -4.651}, {-4.355, -5.28}, {-4.712, -4.727}, {-5.178, -3.654}, {-4.219, -3.379}},
            adjacent = {'j26', 'j27', 'p2', 'p3', 'p10', 'p12', 'p20'},
            islands = true
        },
        p12 = {
            scenarios = {europe = false, nafrica = false, eastern = false},
            points = {{-6.192, -2.255}, {-5.074, -2.255}, {-4.31, -2.255}, {-4.219, -3.379}, {-5.178, -3.654}, {-5.956, -3.863}, {-6.132, -3.12}},
            adjacent = {'j21', 'j26', 'j27', 'j28', 'p1', 'p2', 'p11', 'p13', 'p19', 'p20'},
            islands = true
        },
        p13 = {
            scenarios = {europe = false, nafrica = false, eastern = false},
            points = {{-6.26, 0.166}, {-4.793, -0.34}, {-4.85, -0.587}, {-5.035, -1.436}, {-5.074, -2.255}, {-6.192, -2.255},
                    {-6.668, -2.255}, {-6.529, -1.369}, {-6.244, -1.136}, {-6.059, -0.484}, {-6.164, -0.107}, {-6.429, -0.476}},
            adjacent = {'j17', 'j18', 'j21', 'j22$', 'j23', 'j24', 'j25', 'p1', 'p12', 'p14', 'p17', 'p18', 'p19'},
            islands = true
        },
        p14 = {
            scenarios = {europe = false, nafrica = false, eastern = false},
            points = {{-4.994, 2.316}, {-4.816, 2.139}, {-4.316, 2.057}, {-4.228, 1.707}, {-4.445, 1.463}, {-4.545, 0.906}, {-4.458, 0.466},
                    {-4.793, -0.34}, {-6.26, 0.166}, {-5.975, 0.856}, {-5.546, 1.63}},
            adjacent = {'j5$', 'j6', 'j14$', 'j15', 'j16', 'j17', 'j18', 'p0', 'p13', 'p15', 'p17'},
            islands = true,
            convoys = {{j14 = {iron = 1, osr = 1, x = -5.18, z = 1.21}}}
        },
        p15 = {
            scenarios = {europe = false, nafrica = false, eastern = false},
            points = {{-5.115, 3.587}, {-5.152, 3.418}, {-4.932, 3.258}, {-4.4, 3.362}, {-4.174, 2.991}, {-4.507, 2.894},
                    {-4.931, 3.014}, {-5.073, 2.512}, {-4.994, 2.316}, {-5.546, 1.63}, {-5.975, 0.856}, {-6.972, 1.389},
                    {-6.424, 2.44}, {-5.732, 3.386}, {-5.312, 3.583}},
            adjacent = {'i9@', 'j6$', 'j7', 'j9$', 'j10', 'j12$', 'j13', 'p14', 'p16', 'p17'},
            canals = {i9 = {'j9'}},
            islands = true,
            convoys = {{j6 = {osr = 1, x = -5.05, z = 2.71}, j9 = {osr = 1, x = -5.18, z = 3.42}, j12 = {oil = 1, osr = 1, x = -5.56, z = 2.89}}}
        },
        p16 = {
            scenarios = {europe = false, nafrica = false, eastern = false},
            points = {{-6.618, 5.033}, {-5.949, 4.311}, {-5.56, 3.881}, {-6.004, 3.571}, {-5.732, 3.386}, {-6.424, 2.44},
                    {-6.972, 1.389}, {-7.286, 1.533}, {-7.655, 2.384}, {-7.974, 2.273}, {-7.53, 3.511}},
            adjacent = {'b21', 'i8', 'i9', 'j10$', 'j11$', 'p15', 'p17'},
            islands = true,
            convoys = {{j10 = {oil = 1, x = -5.89, z = 3.5}, j11 = {oil = 1, x = -6.08, z = 3.38}}}
        },
        p17 = {
            scenarios = {europe = false, nafrica = false, eastern = false},
            points = {{-7.286, 1.533}, {-6.972, 1.389}, {-5.975, 0.856}, {-6.26, 0.166}, {-6.429, -0.476}, {-6.739, -0.683},
                    {-7.387, -0.43}, {-7.273, 0.058}, {-6.996, -0.058}, {-6.991, 0.47}, {-7.189, 0.655}},
            adjacent = {'b21', 'b22', 'b24', 'b25', 'p13', 'p14', 'p15', 'p16', 'p18'}
        },
        p18 = {
            scenarios = {europe = false, nafrica = false, eastern = false},
            points = {{-6.739, -0.683}, {-6.6, -0.986}, {-6.895, -1.517}, {-6.529, -1.369}, {-6.668, -2.255}, {-7.98, -2.255},
                    {-8.163, -1.482}, {-7.954, -1.474}, {-7.84, -1.486}},
            adjacent = {'b24$', 'b25', 'j25', 'p13', 'p17', 'p19'},
            islands = true,
            convoys = {{b24 = {iron = 1, osr = 1, x = -7.8, z = -1.46}}}
        },
        p19 = {
            scenarios = {europe = false, nafrica = false, eastern = false},
            points = {{-7.98, -2.255}, {-6.668, -2.255}, {-6.192, -2.255}, {-6.132, -3.12}, {-5.956, -3.863}, {-6.786, -4.126},
                    {-6.785, -3.91}, {-7.098, -4.271}, {-7.597, -3.317}},
            adjacent = {'b26', 'b27$', 'j25', 'j28', 'p12', 'p13', 'p18', 'p20', 'u10'},
            islands = true
        },
        p20 = {
            scenarios = {europe = false, nafrica = false, eastern = false},
            points = {{-5.178, -3.654}, {-4.712, -4.727}, {-4.355, -5.28}, {-5.556, -6.15}, {-6.402, -5.268}, {-7.022, -4.387},
                    {-6.734, -4.318}, {-6.786, -4.126}, {-5.956, -3.863}},
            adjacent = {'b27', 'j27', 'j28', 'p10', 'p11', 'p12', 'p19', 'u9'},
            islands = true
        },
        r1 = {
            scenarios = {pacific = false, nafrica = false},
            name = 'Moscow',
            points = {{0.301, 1.464}, {0.8, 1.226}, {0.766, 0.878}, {0.62, 0.805}, {0.813, 0.337}, {0.346, 0.311},
                    {0.183, 0.577}, {-0.015, 0.572}, {-0.157, 1.061}, {0.061, 1.407}, },
            adjacent = {'r2#', 'r5#', 'r7#', 'r8#', 'r11#', 'r12'},
            sv = 5,
            industry = 5,
            resources = {iron = 1, osr = 1}
        },
        r2 = {
            scenarios = {pacific = false, nafrica = false},
            name = 'Arkhangelsk',
            points = {{1.139, 0.433}, {1.347, 0.325}, {1.245, 0.153}, {1.4, -0.151}, {1.194, -0.454}, {1.01, -0.227},
                    {0.262, -0.382}, {0.346, 0.311}, {0.813, 0.337}},
            adjacent = {'a4$', 'r1#', 'r3#', 'r4', 'r5#', 'r12#'},
            sv = 3,
            industry = 3,
            resources = {osr = 1}
        },
        r3 = {
            scenarios = {pacific = false, nafrica = false},
            name = 'Karelia',
            points = {{1.347, 0.325}, {2.18, -0.292}, {2.15, -1.345}, {1.853, -1.091}, {1.811, -0.861}, {1.513, -0.639},
                    {1.402, -0.397}, {1.509, -0.303}, {1.8, -0.414}, {1.595, -0.125}, {1.4, -0.151}, {1.245, 0.153}},
            adjacent = {'a3', 'a4$', 'g9', 'r2#', 'r4#'},
            sv = 2,
            industry = 2,
            resources = {iron = 1}
        },
        r4 = {
            scenarios = {pacific = false, nafrica = false},
            name = 'Leningrad',
            points = {{1.625, 0.726}, {1.86, 0.533}, {2.368, 0.502}, {2.464, 0.034}, {2.18, -0.292}, {1.347, 0.325},
                    {1.139, 0.433}, {1.524, 0.542}},
            adjacent = {'a5$', 'g7#', 'g8#', 'g9#', 'r2', 'r3#', 'r5#'},
            sv = 3,
            industry = 3,
            resources = {osr = 1}
        },
        r5 = {
            scenarios = {pacific = false, nafrica = false},
            name = 'Bryansk',
            points = {{1.325, 1.757}, {1.557, 1.654}, {1.628, 1.239}, {1.788, 1.166}, {1.625, 0.726}, {1.524, 0.542},
                    {1.139, 0.433}, {0.813, 0.337}, {0.62, 0.805}, {0.766, 0.878}, {0.8, 1.226}, {1.255, 1.2},
                    {1.366, 1.379}},
            adjacent = {'g6#', 'g7#', 'r1#', 'r2#', 'r4#', 'r6', 'r7'},
            sv = 2,
            industry = 2,
            resources = {iron = 1, osr = 1}
        },
        r6 = {
            scenarios = {pacific = false, nafrica = false},
            name = 'Caucasus',
            points = {{0.917, 2.925}, {1.207, 2.734}, {1.716, 2.381}, {1.652, 2.129}, {1.325, 1.757}, {1.169, 2.008},
                    {0.879, 2.126}, {0.957, 2.255}, {0.535, 2.686}, {0.625, 2.9}},
            adjacent = {'b17', 'g6#', 'm4', 'm6', 'n14', 'r5', 'r7#'},
            sv = 3,
            resources = {oil = 2}
        },
        r7 = {
            scenarios = {pacific = false, nafrica = false},
            name = 'Volga',
            points = {{0.879, 2.126}, {1.169, 2.008}, {1.325, 1.757}, {1.366, 1.379}, {1.255, 1.2}, {0.8, 1.226},
                    {0.301, 1.464}, {0.564, 1.756}, {0.491, 1.949}, {0.721, 1.954}},
            adjacent = {'m6', 'r1#', 'r5', 'r6#', 'r8'},
            sv = 2,
            industry = 2,
            resources = {iron = 1, osr = 1}
        },
        r8 = {
            scenarios = {pacific = false, nafrica = false},
            name = 'Kazakh',
            points = {{0.387, 2.405}, {0.582, 2.233}, {0.491, 1.949}, {0.564, 1.756}, {0.301, 1.464}, {0.061, 1.407},
                    {-0.157, 1.061}, {-0.35, 0.919}, {-0.602, 1.029}, {-0.865, 1.748}, {-0.871, 1.756}, {-0.425, 1.948},
                    {0.195, 2.043}, {0.068, 2.302}},
            adjacent = {'m6', 'r1#', 'r7', 'r9', 'r10', 'r11'},
            sv = 1,
            resources = {osr = 2}
        },
        r9 = {
            scenarios = {pacific = false, nafrica = false},
            name = 'Turkmen Uzbek',
            points = {{-0.419, 2.861}, {0.145, 2.867}, {0.387, 2.405}, {0.068, 2.302}, {0.195, 2.043}, {-0.425, 1.948},
                    {-0.871, 1.756}, {-0.865, 1.748}, {-1.274, 1.331}, {-1.586, 1.402}, {-1.706, 1.682}, {-1.579, 1.96},
                    {-0.888, 2.288}},
            adjacent = {'b17', 'c3^', 'c5', 'j8^', 'm6', 'n18', 'r8', 'r10'},
            sv = 1
        },
        r10 = {
            scenarios = {pacific = false, nafrica = false},
            name = 'East Kazakh',
            points = {{-0.865, 1.748}, {-0.602, 1.029}, {-1.094, 0.799}, {-1.243, 0.87}, {-1.569, 0.665}, {-1.728, 0.617},
                    {-1.742, 0.804}, {-1.586, 1.402}, {-1.274, 1.331}},
            adjacent = {'c5', 'n19', 'r8', 'r9', 'r11', 'r13', 'r14'},
            sv = 1
        },
        r11 = {
            scenarios = {pacific = false, nafrica = false},
            name = 'Sverdlovsk',
            points = {{-0.157, 1.061}, {-0.015, 0.572}, {-0.157, 0.536}, {-0.786, 0.049}, {-1.13, 0.561}, {-1.094, 0.799},
                    {-0.602, 1.029}, {-0.35, 0.919}},
            adjacent = {'r1#', 'r8', 'r10', 'r12', 'r13#'},
            sv = 3,
            resources = {osr = 2}
        },
        r12 = {
            scenarios = {pacific = false, nafrica = false},
            name = 'Urals',
            points = {{0.183, 0.577}, {0.346, 0.311}, {0.262, -0.382}, {0.154, -0.475}, {-0.615, -0.566}, {-0.786, 0.049},
                    {-0.157, 0.536}, {-0.015, 0.572}},
            adjacent = {'a4', 'r1', 'r2#', 'r11', 'r13'},
            sv = 2,
            resources = {oil = 2}
        },
        r13 = {
            scenarios = {pacific = false, nafrica = false},
            name = 'Krasnoyarsk',
            points = {{-1.243, 0.87}, {-1.094, 0.799}, {-1.13, 0.561}, {-0.786, 0.049}, {-0.615, -0.566}, {-1.186, -0.877},
                    {-1.512, -0.477}, {-1.443, 0.363}, {-1.569, 0.665}},
            adjacent = {'r10', 'r11#', 'r12', 'r14#', 'r15'},
            sv = 1,
            resources = {oil = 1}
        },
        r14 = {
            scenarios = {pacific = false, nafrica = false},
            name = 'Amur Irkutsk',
            points = {{-1.569, 0.665}, {-1.443, 0.363}, {-1.512, -0.477}, {-2.085, -1.014}, {-2.21, -0.91}, {-2.109, -0.671},
                    {-2.458, -0.47}, {-2.417, -0.248}, {-1.728, 0.617}},
            adjacent = {'j3', 'n19', 'r10', 'r13#', 'r15', 'r16#'},
            sv = 2,
            resources = {iron = 1, osr = 1}
        },
        r15 = {
            scenarios = {pacific = false, nafrica = false},
            name = 'Yakut',
            points = {{-1.512, -0.477}, {-1.186, -0.877}, {-1.57, -1.36}, {-1.765, -2.01}, {-2.085, -1.014}},
            adjacent = {'r13', 'r14', 'r16'},
            sv = 2,
            resources = {oil = 1}
        },
        r16 = {
            scenarios = {pacific = false, nafrica = false},
            name = 'Khabarovsky',
            points = {{-2.21, -0.91}, {-2.085, -1.014}, {-1.765, -2.01}, {-1.77, -2.255}, {-2.09, -2.255}, {-2.061, -1.937},
                    {-2.337, -1.483}, {-2.544, -1.793}, {-3.068, -1.592}, {-3.347, -1.18}, {-3.283, -0.954}, {-2.878, -1.317},
                    {-2.861, -1.088}},
            adjacent = {'j2', 'j3', 'p1$', 'r14#', 'r15', 'r17'},
            sv = 2,
            industry = 2,
            resources = {iron = 1}
        },
        r17 = {
            scenarios = {pacific = false, nafrica = false},
            name = 'Kamchatsky',
            points = {{-2.09, -2.255}, {-1.77, -2.255}, {-1.622, -2.86}, {-1.25, -3.435}, {-1.512, -3.433}, {-1.559, -3.277},
                    {-1.888, -3.239}, {-2.146, -2.943}, {-2.485, -2.935}, {-2.982, -2.686}, {-2.351, -2.615}, {-2, -2.835},
                    {-1.947, -2.603}, {-2.17, -2.482}},
            adjacent = {'p2', 'p3', 'r16'},
            sv = 1,
            resources = {osr = 1}
        },
        r18 = {
            scenarios = {europe = false, pacific = false, nafrica = false, eastern = false},
            name = 'Soviet Sakhalin',
            circle = {c = {-2.692, -1.944}, r = 0.21},
            adjacent = {'j19', 'p1'}
        },
        t1 = {
            scenarios = {pacific = false, eastern = false},
            name = 'Italy',
            points = {{4.354, 2.709}, {4.65, 1.49}, {4.902, 1.345}, {4.848, 0.949}, {4.541, 1.184}, {4.338, 1.172}, {3.856, 1.621},
                    {4.068, 1.709}, {4.283, 1.589}, {4.052, 2.616}},
            adjacent = {'g1#', 'g3#', 'm2$', 'n13', 't2#'},
            sv = 6,
            industry = 6,
            resources = {iron = 1, osr = 3}
        },
        t2 = {
            scenarios = {pacific = false, eastern = false},
            name = 'Balkans',
            points = {{3.678, 3.305}, {3.743, 2.985}, {3.753, 2.478}, {4.068, 1.709}, {3.856, 1.621}, {3.489, 1.898},
                    {3.301, 2.181}, {3.457, 2.637}, {2.956, 2.751}, {3.351, 2.879}, {3.271, 3.171}},
            adjacent = {'g1#', 'g4', 'g5#', 'm2', 'm3$', 'n14'},
            sv = 4,
            resources = {oil = 1, iron = 2, osr = 3}
        },
        t3 = {
            scenarios = {pacific = false, eastern = false},
            name = 'Sardinia',
            circle = {c = {4.92, 1.98}, r = 0.23},
            adjacent = {'m2'},
            sv = 1
        },
        t4 = {
            scenarios = {pacific = false, eastern = false},
            name = 'Sicily',
            circle = {c = {4.531, 2.651}, r = 0.23},
            adjacent = {'m2', 't1'},
            sv = 1
        },
        t5 = {
            scenarios = {pacific = false, eastern = false},
            name = 'Libya',
            points = {{3.5, 4.63}, {4.192, 4.277}, {4.337, 4.331}, {4.847, 3.885}, {4.87, 3.671}, {4.9, 3.531},
                    {4.726, 3.296}, {4.206, 3.636}, {3.894, 3.879}, {3.72, 3.68}, {3.29, 3.88}, {3.355, 4.57}},
            adjacent = {'b5', 'b12^', 'b13^', 'b14^', 'g13', 'g15^', 'm2$', 'm3'},
            sv = 3,
            resources = {oil = 2, iron = 1}
        },
        u1 = {
            scenarios = {pacific = false, eastern = false},
            name = 'Eastern United States',
            points = {{3.136, -4.064}, {3.174, -4.834}, {3.326, -4.965}, {3.201, -5.479}, {3.583, -5.675}, {3.558, -5.813}, {3.176, -5.71},
                    {3.075, -5.777}, {2.719, -6.03}, {2.429, -5.87}, {2.562, -4.989}, {2.97, -4.284}, {2.891, -4.102}},
            adjacent = {'a10$', 'a11', 'b29#', 'u2#'},
            sv = 10,
            industry = 10,
            resources = {oil = 2, iron = 4, osr = 5}
        },
        u2 = {
            scenarios = {eastern = false},
            name = 'Central United States',
            points = {{2.356, -4.794}, {2.562, -4.989}, {2.429, -5.87}, {2.719, -6.03}, {2.195, -6.364}, {2.282, -6.548}, {1.357, -6.489}, {1.563, -6.342},
                    {1.403, -5.743}, {1.27, -5.777}, {1.071, -5.251}, {1.598, -5.037}},
            adjacent = {'a11$', 'b28#', 'b29#', 'n1#', 'u1#', 'u3#'},
            sv = 9,
            industry = 9,
            resources = {oil = 3, iron = 4, osr = 6}
        },
        u3 = {
            scenarios = {europe = false, nafrica = false, eastern = false},
            name = 'Western United States',
            points = {{1.071, -5.251}, {1.27, -5.777}, {1.403, -5.743}, {1.563, -6.342}, {1.357, -6.489}, {0.449, -6.631}, {0.032, -6.468}, {-0.168, -5.877}, {-0.084, -5.513}},
            adjacent = {'b28#', 'n1#', 'p5$', 'u2#'},
            sv = 8,
            industry = 8,
            resources = {oil = 2, iron = 3, osr = 6}
        },
        u4 = {
            scenarios = {europe = false, nafrica = false, eastern = false},
            name = 'Alaska',
            points = {{-1.25, -3.435}, {-0.431, -3.89}, {-0.607, -4.385}, {-0.253, -4.881}, {-0.408, -5.122}, {-0.782, -4.376},
                    {-1.374, -4.429}, {-1.575, -4.258}, {-1.522, -3.806}, {-1.236, -3.752}},
            adjacent = {'b28', 'p3', 'p4$'},
            sv = 3,
            resources = {oil = 1, iron = 2, osr = 1}
        },
        u5 = {
            scenarios = {europe = false, nafrica = false, eastern = false},
            name = 'Aleutian Islands',
            circle = {c = {-1.993, -4.029}, r = 0.25},
            adjacent = {'p3'},
            sv = 1
        },
        u6 = {
            scenarios = {europe = false, nafrica = false, eastern = false},
            name = 'Hawaiian Islands',
            circle = {c = {-2.135, -6.434}, r = 0.36},
            adjacent = {'p9$'},
            sv = 2
        },
        u7 = {
            scenarios = {europe = false, nafrica = false, eastern = false},
            name = 'Midway Island',
            circle = {c = {-2.562, -5.626}, r = 0.25},
            adjacent = {'p3', 'p9', 'p10'}
        },
        u8 = {
            scenarios = {europe = false, nafrica = false, eastern = false},
            name = 'Johnson Atoll',
            circle = {c = {-3.14, -6.393}, r = 0.25},
            adjacent = {'p9', 'p10'}
        },
        u9 = {
            scenarios = {europe = false, nafrica = false, eastern = false},
            name = 'Samoan Islands',
            circle = {c = {-4.763, -5.773}, r = 0.25},
            adjacent = {'p10', 'p20'}
        },
        u10 = {
            scenarios = {europe = false, nafrica = false, eastern = false},
            name = 'New Caledonia',
            circle = {c = {-7.278, -2.982}, r = 0.25},
            adjacent = {'p19'}
        }
    }
}

----#include ../config/map

function Map:initialize(obj, scenario)
    bind(obj, self)
    self.position, self.rotation, self.snaps = obj.getPosition(), obj.getRotation(), obj.getSnapPoints()
    local Y, lines = 0.585, {}
    self.quadrants = {{{}, {}}, {{}, {}}}
    for id, data in pairs(self.regions) do if data.scenarios[scenario] ~= false then
        data.is_sea = id:match('^[aimp]') ~= nil
        if data.points then
            data.centroid, data.box = vector(0, 0, 0), {
                max = vector(data.points[1][1], 0, data.points[1][2]),
                min = vector(data.points[1][1], 0, data.points[1][2])
            }
            local prev_point, points, sum, cross = data.points[#data.points], {}, 0
            for _, point in ipairs(data.points) do
                table.insert(points, {point[1], Y, point[2]})
                for i, dim in ipairs{'x', 'z'} do if data.box.max[dim] < point[i] then data.box.max[dim] = point[i]
                elseif data.box.min[dim] > point[i] then data.box.min[dim] = point[i] end end
                cross = prev_point[1] * point[2] - point[1] * prev_point[2]
                for i, dim in ipairs{'x', 'z'} do data.centroid[dim] = data.centroid[dim] + (prev_point[i] + point[i]) * cross / 3 end
                sum, prev_point = sum + cross, point
            end
            data.centroid = data.centroid * (1 / sum)
            table.insert(points, {data.points[1][1], Y, data.points[1][2]})
            table.insert(lines, {points = points, thickness = 0.02})
        elseif data.circle then
            data.circle.c, data.box = vector(data.circle.c[1], 0, data.circle.c[2]), {
                max = vector(data.circle.c[1] + data.circle.r, 0, data.circle.c[2] + data.circle.r),
                min = vector(data.circle.c[1] - data.circle.r, 0, data.circle.c[2] - data.circle.r)
            }
            local points = {{data.circle.c.x + data.circle.r, Y, data.circle.c.z}}
            for i = 1, 12 do table.insert(points, {
                data.circle.c.x + data.circle.r * math.cos(math.pi * i / 6), Y,
                data.circle.c.z + data.circle.r * math.sin(math.pi * i / 6)
            }) end
            table.insert(lines, {points = points, thickness = 0.02, color = {0, 1, 1}})
        end
        if data.box.min.x < 0 then
            if data.box.min.z < 0 then table.insert(self.quadrants[1][1], id) end
            if data.box.max.z > 0 then table.insert(self.quadrants[1][2], id) end
        end
        if data.box.max.x > 0 then
            if data.box.min.z < 0 then table.insert(self.quadrants[2][1], id) end
            if data.box.max.z > 0 then table.insert(self.quadrants[2][2], id) end
        end
        self.regions[id] = Map.Region(id, data)
    else self.regions[id] = nil end end
    for _, region in pairs(self.regions) do for i = #region.adjacent, 1, -1 do
        if not Map.regions[region.adjacent[i]:match('^%a%d+')] then table.remove(region.adjacent, i) end
    end end
    -- for _, region in pairs(self.regions) do
    --     while #region.adjacent > 0 do
    --         local id, flag = table.remove(region.adjacent):match('(%a%d+)(.?)')
    --         if self.regions[id] then if flag ~= nil then
    --             local t = {port = flag == '$' and {} or nil, canal = flag == '@' and {} or nil}
    --             setmetatable(t, {__index = self.regions[id]})
    --         else region.adjacent[id] = self.regions[id] end end
    -- end end
    for _, id in ipairs(Scenarios[state.scenario].capitals) do self.regions[id].capital = true end
    self.setTable('Lines', lines)
    self.setVar('enabled', true)
    log('Map initialized')
end

function Map:getRegion(obj)
    return self:inRegion(self.positionToLocal(obj.getPosition()))
end

function Map:inRegion(point)
    local regions = {}
    for _, id in ipairs(self.quadrants[point.x < 0 and 1 or 2][point.z < 0 and 1 or 2]) do
        local region = self.regions[id]
        if region.box.max.x > point.x and region.box.min.x < point.x and region.box.max.z > point.z and region.box.min.z < point.z then
            if region.islands then table.insert(regions, region) else table.insert(regions, 1, region) end
    end end
    if #regions == 1 then return regions[1].id
    else for _, region in ipairs(regions) do
        if region.circle then if point:setAt('y', 0):distance(region.circle.c) < region.circle.r then return region.id end
        elseif self.inside2d(point, region.points) then return region.id end
    end end
end

function Map:rotationToCenter(point)
    return (math.atan2((point.x or point[1]) - self.center.x, (point.z or point[2]) - self.center.z) / math.pi + 1) * 180
end

function Map:radialVector(point)
    return (point - self.positionToWorld(self.center)):setAt('y', 0):normalized()
end

function Map:search(q, path, visit, v)
    local from, to, d, node
    if type(q) == 'table' then
        repeat
            if #q == 0 then return v.result end
            node = table.remove(q, 1)
            d, from, to = node[1], node[2], node[3]
        until visit(d, from, to, v)
        from = to:match('%a%d+')
    else d, from, q, v = 0, q, {}, {[q] = 'start', result = v} end
    for _, link in ipairs(self.regions[from].adjacent) do if path(d, link) then table.insert(q, {d + 1, from, link}) end end
    return self:search(q, path, visit, v)
end

-- Computes the Delaunay triangulation of the given region and commands
function Map:delaunay(region, commands, show_lines)
    local co = coroutine.create(|cor| Map.delaunayBuild(region, commands, show_lines, cor))
    coroutine.resume(co, co)
end

function Map.delaunayBuild(region, commands, show_lines, co)
    local triangles = {}
    local addPoint = function (point)
        Map.delaunayAddPoint(point)
        Wait.frames(|| coroutine.resume(co), 10)
        coroutine.yield()
    end
    for _, point in ipairs(Map.regions[region].points) do addPoint(vector(point[1], 0, point[2])) end
    for _, command in ipairs(commands) do if command.force == 'army' then
        local origin = command.getPosition()
        local offset = (command.getTransformForward() + command.getTransformRight()) * 0.45
        for i = 1, 4 do addPoint(Map.positionToLocal(origin + offset:rotateOver('y', 90)):setAt('y', 0)) end
        for i = #triangles, 1, -1 do if triangles[i].center == Map.positionToLocal(origin):setAt('y', 0) then table.remove(triangles, i) end end
    elseif command.force == 'fleet' then
        local origin = command.getPosition()
        local forward, right = command.getTransformForward(), command.getTransformRight()
        for x = 1, -1, -2 do for z = 1, -1, -1 do
            addPoint(Map.positionToLocal(origin + right * (x - math.abs(z) * 0.1) + forward * z):setAt('y', 0))
    end end end end
    for i = #triangles, 1, -1 do
        if not self.inside2d((triangles[i][1] + triangles[i][2] + triangles[i][3]) * (1/3), Map.regions[region].points) then
            table.remove(triangles, i)
    end end
    if show_lines then
        local lines = {}
        for i, tri in ipairs(triangles) do
            local points = {vector(tri[3].x, 0.585, tri[3].z)}
            for _, point in ipairs(tri) do table.insert(points, vector(point.x, 0.585, point.z)) end
            table.insert(lines, {points = points, thickness = 0.02})
        end
        Map.setVectorLines(lines)
    end
end

function Map.delaunayTriangle(v1, v2, v3)
    local tri = {v1, v2, v3}
    local a, b, c = v2 - v1, v3 - v1, v3 - v2
    local d, e = a:dot(v1 + v2), b:dot(v1 + v3)
    tri.center = vector(b.z * d - a.z * e, 0, a.x * e - b.x * d) * (1 / (2 * (a.x * c.z - a.z * c.x)))
    tri.r2 = tri.center:sqrDistance(v1)
    return tri
end

function Map.delaunayAddPoint(point)
    local edges = {}
    for i = #triangles, 1, -1 do
        local tri = triangles[i]
        if point:sqrDistance(tri.center) < tri.r2 then
            for v = 1, 3 do table.insert(edges, {tri[v], tri[v % 3 + 1]}) end
            table.remove(triangles, i)
    end end
    while #edges > 0 do
        local edge = table.remove(edges)
        for i = 1, #edges do
            if edge[1] == edges[i][1] and edge[2] == edges[i][2] or edge[1] == edges[i][2] and edge[2] == edges[i][1] then
                table.remove(edges, i)
                edge = nil
                break
        end end
        if edge then table.insert(triangles, Map.delaunayTriangle(edge[1], edge[2], point)) end
    end
    if show_lines then
        local lines = {}
        for i, tri in ipairs(triangles) do
            local points = {vector(tri[3].x, 0.585, tri[3].z)}
            for _, point in ipairs(tri) do table.insert(points, vector(point.x, 0.585, point.z)) end
            table.insert(lines, {points = points, thickness = 0.02})
        end
        Map.setVectorLines(lines)
    end
end

-- Static helpers --
function Map.inside2d(point, polygon)
    local v1, inside = polygon[#polygon], false
    for _, v2 in ipairs(polygon) do
        if (point.x > v1[1]) != (point.x > v2[1])
            and (point.x - v1[1]) * Map.signed_area(point, v1, v2) > 0 then inside = not inside end
        v1 = v2
    end
    return inside
end

function Map.signed_area(a, b, c)
    return a.x * (b[2] - c[2]) - a.z * (b[1] - c[1]) + b[1] * c[2] - b[2] * c[1]
end

-- subclass Region --
Map.Region = {}
setmetatable(Map.Region, {__call = function (t, id, data)
    local r = {id = id}
    for k, v in pairs(data) do r[k] = v end
    for _, link in ipairs(data.adjacent) do if link:match('$$') then r.port = true end end
    setmetatable(r, {__index = t})
    return r
end})

function Map.Region:center()
    if self.centroid then return Map.positionToWorld(self.centroid:copy():setAt('y', 0.585))
    else return Map.positionToWorld({self.circle.c[1], 0.585, self.circle.c[2]}) end
end

function Map.Region:angle() return Map:rotationToCenter(self:center()) end

function Map.Region:displayID() return self.id:gsub('[aimp]', '%0-'):upper() end
function Map.Region:displayName() return self:displayID() .. (self.is_sea and '' or ' - ' .. self.name) end
function Map.Region:colorizedName()
    local id = self:displayID():colorize(self.is_sea and 'sea' or Nations[self.id:sub(1, 1)])
    return id .. (self.is_sea and '' or ' - ' .. self.name)
end

function Map.Region:owner()
    local nation
    if self.flag ~= nil then
        local name = self.flag.getName()
        if name:match('standing army') then nation = name:match('%b[](%a+)%b[]'):lower()
        else nation = name:match('^%a+'):lower() end
    else nation = Nations[self.id:sub(1, 1)] end
    return nation
end

function Map.Region:side() return Nations[self:owner()].side end

function Map.Region:commands() return Commands:region(self.id) end

function Map.Region:income()
    local income = {}
    if self.resources then
        for resource, value in pairs(self.resources) do income[resource] = value end
        if self.card.is_face_down then
            if income.oil then income.oil = income.oil - 1
            elseif income.iron then income.iron = income.iron - 1
            elseif income.osr then income.osr = income.osr - 1 end
    end end
    return income
end

function Map.Region:production()
    return self.industry and self.industry - #(self.bombs or {}) or 0
end

function Map.Region:activeConvoys()
    debug('Checking for active convoys in ', self.id)
    local clusters = {}
    if self.convoys then for _, cluster in ipairs(self.convoys) do
        local t = {}
        for origin, convoy in pairs(cluster) do if origin:find('%-') then
            local from, to = origin:match('(%w+)%-(%w+)')
            if Map.regions[from] and Map.regions[to] and Map.regions[from]:side() == Map.regions[to]:side() then
                local side = Map.regions[from]:side()
                t[side] = t[side] or {}
                t[side][origin] = convoy
            end
        elseif Map.regions[origin] then
            if not Map.regions[origin].collapsed or Map.regions[origin]:owner() ~= Nations[origin:sub(1, 1)] then
                local side = Map.regions[origin]:side()
                t[side] = t[side] or {}
                t[side][origin] = convoy
        end end end
        for side, convoys in pairs(t) do
            clusters[side] = clusters[side] or {}
            table.insert(clusters[side], t[side])
    end end end
    return clusters
end

function Map.Region:bombTargets()
    debug('Getting bomb targets for ', self.id)
    local resources, targets = self:income(), {}
    if resources.osr then targets.yellow = {osr = resources.osr} end
    if resources.iron then targets.blue = {iron = resources.iron} end
    if resources.oil then targets.red = {oil = resources.oil} end
    if self.construction then for unit_type, num in pairs(self.construction.units) do
        targets[Units[unit_type].color] = targets[Units[unit_type].color] or {}
        targets[Units[unit_type].color][unit_type] = num
    end end
    if self.industry then
        targets.white = {bomb = self.industry - #(self.bombs or {})}
        if targets.white.bomb == 0 then targets.white = nil end
    elseif not self.bombs then targets.white = {bomb = 1} end
    return targets
end

function Map.Region:placeHotspot()
    local p = Promise()
    Bags.hotspot.takeObject({
        position = self:center() + vector(0, 4, 0),
        callback_function = function (obj)
            self.hotspot = Hotspot(obj, self.id)
            p:resolve(obj)
    end})
    return p
end

function Map.Region:removeHotspot()
    local p = self.hotspot:stash()
    self.hotspot = nil
    return p
end

----#include components/map
----#include components/dice
Die = Wrapper()

function Die:getColor() return self.getRotationValue():sub(9):lower() end

function Die:setColor(clr)
    for _, face in ipairs(self.getRotationValues()) do
        if face.value:sub(9):lower() == clr then
            self.setRotationSmooth(face.rotation)
            break
    end end
end

function Die:faceUp() self.setRotationSmooth(self.getRotationValues()[self.getValue()].rotation) end

Dice = Wrapper()
Dice.Order = {yellow = 1, blue = 2, green = 3, red = 4, black = 5, white = 6}

function Dice:destruct() for _, die in ipairs(self) do die.destruct() end end

-- Helper for calculating dice roll positions
function Dice.positions(n, center, norm)
    debug('Calculating dice positions')
    if n > 1 then
        local radius = norm * (1 / (math.sqrt(2) * math.sin(math.pi / n)))
        if n % 2 == 0 then radius:rotateOver('y', 90) end
        local positions = {center + radius}
        for i = 2, n do positions[i] = center + radius:rotateOver('y', 360 / n) end
        return positions
    else return {center} end
end

-- Spawn and roll a set of dice at the specified positions
function Dice:roll(positions)
    debug('Rolling dice at fixed positions')
    local delay, ps = 0.25, {}
    for i, pos in ipairs(positions) do
        local p = Promise()
        table.insert(ps, p)
        Wait.time(function () self.takeObject({
            position = pos,
            rotation = {math.random(360), math.random(360), math.random(360)},
            smooth = false,
            callback_function = function (die)
                die.setVelocity({0, 0, 0})
                die.use_gravity, die.angular_drag = false, 1.6
                p:resolve(Die(die))
    end}) end, (i - 1) * delay) end
    return Promise.all(ps):delay(delay):next(function (...)
        local dice = Dice.Roll({...})
        for _, die in ipairs(dice) do
            local x, z = math.random() - 0.5, math.random() - 0.5
            local scale = (math.abs(x) + math.abs(z)) / 8
            die.addTorque({x / scale, 0, z / scale})
        end
        return dice
    end):delay(2):next(function (roll)
        for _, die in ipairs(roll) do die:faceUp() end
        return roll:notMoving()
    end)
end

-- Roll dice from the bag by tossing in a specified direction
function Dice:toss(n, f, v, d)
    local ps = {}
    local b, nx, ny = v:orthoNormalize()
    for i = 1, n do
        local p, angle = Promise(), math.random() * 2 * math.pi
        local force = b + (math.sin(angle) * nx + math.cos(angle) * ny) * d
        table.insert(ps, p)
        Wait.frames(function () self.takeObject({
            position = self.getPosition() + vector(0, 3, 0),
            rotation = vector(math.random(360), 0, math.random(360)),
            smooth = false, callback_function = function (obj)
                obj.use_gravity = false
                Wait.frames(function ()
                    obj.use_gravity = true
                    obj.addForce(force * f * (1 + math.random()))
                    obj.addTorque(vector(math.random(), math.random(), math.random()):normalized() * 2)
                end, 3)
                p:resolve(Die(obj))
        end}) end, (i - 1) * 8)
    end
    return Promise.all(ps):delay(2):next(|...| Dice.Roll({...}))
end

Dice.Roll = {}
Dice.Roll.__meta = {__index = Dice.Roll, __tostring = function (t)
    local s, count, prev = 'Dice roll: '
    for _, die in ipairs(t) do
        local clr = die:getColor()
        if clr ~= prev then
            if prev then s = string.format('%s%s %s, ', s, count, prev) end
            count, prev = 1, clr
        else count = count + 1 end
    end
    return s .. count .. ' ' .. prev
end}
setmetatable(Dice.Roll, {__call = function (t, roll)
    setmetatable(roll, t.__meta)
    return roll
end})

function Dice.Roll:values()
    local values = {}
    for _, die in ipairs(self) do table.insert(values, die:getColor()) end
    return values
end

function Dice.Roll:sort()
    table.sort(self, |a, b| Dice.Order[a:getColor()] < Dice.Order[b:getColor()])
end

function Dice.Roll:arrange(head, tail)
    self:sort()
    for i, die in ipairs(self) do
        die.setLock(true)
        die.setPositionSmooth(head:lerp(tail, (i - 1) / (#self - 1)))
        die:faceUp()
    end
    return self:notMoving()
end

function Dice.Roll:notMoving()
    return Promise.condition(function ()
        for _, die in ipairs(self) do if die.isSmoothMoving() then return false end end
        return true
    end, self)
end

----#include components/dice
----#include components/cards
CardZones = {
    china = '7f5b64',
    germany = '3a283f',
    italy = '2c9afd',
    japan = 'a79084',
    uk = 'd6e8f6',
    usa = '1f06b0',
    ussr = 'f08468'
}

Card = Wrapper(function (card, id)
    card.id = id
    return card
end)

function Card:compare(b, prefix)
    local ap, an = self.id:match('(%a)(%d+)')
    local bp, bn = b.id:match('(%a)(%d+)')
    if ap == bp then return tonumber(an) < tonumber(bn)
    elseif ap == prefix then return true
    elseif bp == prefix then return false
    else return ap < bp end
end

function Card:displayName() return Map.regions[self.id]:displayName() end
function Card:colorizedName() return Map.regions[self.id]:colorizedName() end

function Card:embattled(flip)
    flip = flip or Map.regions[self.id].collapsed ~= nil
    local cards = {this = self, next = rawget(self, 'next'), prev = rawget(self, 'prev')}
    if self.is_face_down ~= flip then return Promise.condition(function ()
        for _, card in pairs(cards) do if card.locked then return false end end
        return true
    end):next(function ()
        for _, card in pairs(cards) do card.setLock(true) end
        self.setRotationSmooth(self.getRotation() + vector(0, 0, 180))
    end):when(|| not self.isSmoothMoving()):skip(1):next(function ()
        for _, card in pairs(cards) do card.setLock(false) end
    end) else return Promise():resolve() end
end

function Card:giveTo(nation)
    local card = self
    return Promise.condition(|| not (card.isSmoothMoving() or card.getLock())):next(function ()
        card.setPositionSmooth(card.getPosition() + vector(0, 3, 0))
        if not Map.regions[card.id].collapsed then
            card.setRotationSmooth(card.getRotation():setAt('z', 0))
    end end):when(|| not card.isSmoothMoving()):next(function ()
        card.setPositionSmooth(Cards[nation].getPosition() + vector(0, 3, 0))
        card.setRotationSmooth(card.getRotation():setAt('y', Cards[nation].getRotation().y))
        return card
    end):when(|| not card.isSmoothMoving())
end

function Card.getId(card)
    return card.getName():lower():match('^%b[](%a%d+)%b[]')
end

Cards = {}
Cards.__meta = wrapper(Cards)
setmetatable(Cards, {
    __pairs = function (t, k) return function (t, k)
        local v
        repeat k, v = next(t, k)
        until nil == v or type(v) == 'table' and v.type == 'Card'
        if nil ~= v then return k, v end
    end, t, nil end,
    __call = constructor(function (zone, nation)
        zone.nation = nation
        return zone
    end),
    __index = function (t, k) if k:match('^%w%w%w%w%w%w$') then
        if getObjectFromGUID(k).type == 'Card' then
            for _, card in pairs(t) do if card.guid == k then return card end end
        else for nation, _ in pairs(Nations) do
            if rawget(t, nation) and t[nation].guid == k then return t[nation] end
    end end end end
})

function Cards:cards()
    local skips = 0
    return function (t, i)
        local j = i + 1
        repeat
            i = i + skips + 1
        until t[i] == nil or t[i].type == 'Card'
        skips = i - j
        if t[i] then return j, Cards[Card.getId(t[i])] end
    end, self.getObjects(), 0
end

function Cards:inside(card)
    local scale = self.getScale() * 0.5
    if math.round(self.getRotation().y) % 180 == 90 then scale.x, scale.z = scale.z, scale.x end
    local max = self.getBounds().center + scale
    local min = self.getBounds().center - scale
    for dim, value in pairs(card.getPosition()) do if value > max[dim] or value < min[dim] then return false end end
    return true
end

function Cards:sort(prefix)
    local cards = self.type == 'Scripting' and {} or self
    if self.type == 'Scripting' then for i, card in self:cards() do cards[i] = card end end
    prefix = prefix or Nations[self.nation].prefix
    table.sort(cards, |a, b| a:compare(b, prefix))
    return cards
end

function Cards:unlocked()
    for _, card in self:cards() do if card.getLock() then return false end end
    return true
end

function Cards:unlockAll() for _, card in self:cards() do card.setLock(false) end end

function Cards:add(card)
    if not (card == rawget(self, 'first') or rawget(card, 'next') or rawget(card, 'prev') or card.getLock()) then
        if rawget(self, 'first') then
            local next, prev = self.first
            while next ~= nil do
                if card:compare(next, Nations[self.nation].prefix) then
                    card.next, card.prev, next.prev = next, prev, card
                    if not prev then self.first = card
                    else prev.next = card end
                    break
                end
                next, prev = rawget(next, 'next'), next
            end
            if next == nil then card.prev, prev.next = prev, card end
        else self.first = card end
        debug('Added ', card.id, ' to ', self.nation, ' card zone')
        self:arrange()
    end
end

function Cards:remove(card)
    if not (card.getLock() or self:inside(card)) then
        if rawget(card, 'next') then card.next.prev, arrange = rawget(card, 'prev'), true end
        if not rawget(card, 'prev') then
            self.first = rawget(card, 'next')
            if rawget(self, 'first') then self.first.prev = nil end
        else card.prev.next, arrange = rawget(card, 'next'), true end
        card.next, card.prev = nil
        debug('Removed ', card.id, ' from ', self.nation, ' card zone')
        self:arrange()
    end
end

function Cards:arrange()
    debug('Rearranging ', self.nation, ' cards')
    local cols, total, card, snaps = #getObjectsWithAllTags({self.nation, 'cardholder'}), 0, rawget(self, 'first'), {}
    local rot, col_height = self.origin.rotation + vector(3, 0, 0), self.getTransformForward() * -20.52
    local col_shift = self.getTransformRight() * (getObjectsWithAllTags({self.nation, 'orders'})[1].positionToLocal(self.getPosition()).x > 0 and 5.6 or -5.6)
    while card ~= nil do card, total = rawget(card, 'next'), total + 1 end
    for i = 1, cols do
        local rows = math.max(math.floor(total / (cols - i + 1)), 12)
        total = math.max(total - rows, 0)
        for j = 1, rows do
            table.insert(snaps, self.origin.position + col_shift * (i - 1) + col_height * ((j - 1) / rows))
    end end
    card = rawget(self, 'first')
    for _, pos in ipairs(snaps) do
        if not card.getLock() then card.setLock(true) end
        card.setPositionSmooth(pos)
        card.setRotation(rot:copy():setAt('z', card.getRotation().z))
        card = rawget(card, 'next')
        if not card then break end
    end
    Promise.condition(function ()
        for _, card in self:cards() do if card.isSmoothMoving() then return false end end
        return true
    end):skip(3):next(|| self:unlockAll())
end

function Cards:getSnaps()
    getObjectsWithAllTags({self.nation})
end

----#include components/cards
----#include components/units
Units = {
    infantry = {order = 6, force = 'army', color = 'yellow', cost = {osr = 2}, casualties = 2, stances = {
        offensive = {hp = 1, dice = {air = 0, bomb = 0, ground = 2}, z = -0.005},
        defensive = {hp = 2, dice = {air = 0, bomb = 0, ground = 1}, z = -0.005}
    }, stance = || 'defensive', casualties = 2},
    artillery = {order = 5, force = 'army', color = 'blue', cost = {iron = 2, osr = 1}, casualties = 2, stances = {
        ground = {hp = 2, dice = {air = 0, bomb = 0, ground = 2}, z = -0.005},
        antiair = {hp = 2, dice = {air = 2, bomb = 0, ground = 1}, z = 0}
    }, stance = |_, antiair| antiair and 'antiair' or 'ground'},
    armor = {order = 4, force = 'army', color = 'green', cost = {oil = 1, iron = 2, osr = 1}, casualties = 4, stances = {
        offensive = {hp = 2, dice = {air = 0, bomb = 0, ground = 4}, z = 0},
        defensive = {hp = 3, dice = {air = 1, bomb = 0, ground = 2}, z = 0}
    }, stance = || 'defensive'},
    fighter = {order = 3, force = 'air', color = 'green', cost = {oil = 2, iron = 1, osr = 1}, casualties = 4, stances = {
        ground = {hp = 2, dice = {air = 0, bomb = 0, ground = 3}, z = 0.18},
        air = {hp = 2, dice = {air = 3, bomb = 0, ground = 0}, z = -0.005},
        surface = {hp = 2, dice = {air = 0, surface = 3}, z = 0.005},
        guard = {hp = 2, dice = {air = 3, surface = 0}, z = 0.005}
    }, stance = |mode, antiair| mode == 'land' and (antiair and 'air' or 'ground') or antiair and 'guard' or 'surface'},
    cfighter = {order = 2, force = 'air', color = 'green', casualties = 4},
    bomber = {order = 1, force = 'air', color = 'red', cost = {oil = 2, iron = 2, osr = 1}, casualties = 6, stances = {
        ground = {hp = 2, dice = {air = 1, bomb = 0, ground = 4}, z = -0.005},
        strategic = {hp = 2, dice = {air = 1, bomb = 4, ground = 0}, z = -0.01},
        surface = {hp = 2, dice = {air = 1, surface = 3}, z = 0.01}
    }, stance = |mode, antiair, bomb| mode == 'sea' and 'surface' or bomb and 'strategic' or 'ground'},
    submarine = {order = 10, force = 'fleet', color = 'yellow', cost = {oil = 1, iron = 2, osr = 1}, casualties = 6, stances = {
        dive = {hp = 2, dice = {air = 0, surface = 2}, z = 0.005, default = true}
    }, stance = || 'dive'},
    cruiser = {order = 9, force = 'fleet', color = 'blue', cost = {oil = 2, iron = 3, osr = 2}, casualties = 10, stances = {
        offensive = {hp = 2, dice = {air = 1, surface = 3}, z = 0.005},
        escort = {hp = 2, dice = {air = 2, surface = 2}, z = 0.005}
    }, stance = |_, antiair, escort| (antiair or escort) and 'escort' or 'offensive'},
    carrier = {order = 8, force = 'fleet', color = 'green', cost = {oil = 4, iron = 3, osr = 3}, casualties = 20, stances = {
        offensive = {hp = 3, dice = {air = 1, surface = 2}, z = 0},
        antiair = {hp = 3, dice = {air = 2, surface = 1}, z = 0}
    }, stance = |_, antiair| antiair and 'antiair' or 'offensive'},
    battleship = {order = 7, force = 'fleet', color = 'red', cost = {oil = 3, iron = 4, osr = 3}, casualties = 20, stances = {
        offensive = {hp = 3, dice = {air = 1, surface = 4}, z = 0},
        antiair = {hp = 3, dice = {air = 2, surface = 3}, z = -0.18}
    }, stance = |_, antiair| antiair and 'antiair' or 'offensive'}
}
setmetatable(Units, {
    __call = |t, unit| t[unit.getName()],
    __pairs = function (T, k) return function (t, k)
        local v
        repeat k, v = next(t, k)
        until v == nil or type(v) == 'table'
        if v ~= nil then return k, v end
    end, T, nil end
})

function Units:buildStack(units, pos, rot, delay)
    rot, delay = rot or Map.getRotation(), delay or 5
    local queue, stack, ps = {}, {}, {}
    for unit, count in pairs(units) do for i = 1, count do table.insert(queue, unit) end end
    table.sort(queue, |a, b| self[a].order > self[b].order)
    for i, unit in ipairs(queue) do
        local p = Promise()
        table.insert(ps, p)
        Wait.frames(function () Bags[unit].takeObject({
            position = pos + (i - 1) * vector(0, 0.21, 0), rotation = rot,
            callback_function = |obj| p:resolve(obj)
    }) end, delay * (i - 1)) end
    return Promise.all(ps)
end

function Units:sort(units)
    table.sort(units, |a, b| self[a.getName()].order > self[b.getName()].order)
    return units
end

function Units.stack(units, position, rotation, step)
    step = vector(0, step or 0.21, 0)
    for _, unit in ipairs(units) do
        unit.setLock(true)
        unit.setPositionSmooth(position + vector(0, unit.is_face_down and 0.21 or 0, 0))
        unit.setRotationSmooth(rotation + vector(0, 0, unit.is_face_down and 180 or 0))
        position = position + step
    end
    return Promise.condition(function ()
        for _, unit in ipairs(units) do if unit.isSmoothMoving() then return false end end
        return true
    end):next(function ()
        for _, unit in ipairs(units) do unit.setLock(false) end
        return units
    end)
end

function Units.pairs(force)
    return function (t, k)
        local v
        repeat k, v = next(t, k)
        until v == nil or (type(v) == 'table' and v.force == force)
        if nil ~= v then return k, v end
    end, Units, nil
end

Unit = {}
Unit.__meta = {__index = |t, k| Unit[k] or t.data[k] or t.obj[k]}
setmetatable(Unit, {__call = function (T, obj, stack)
    local u = {obj = obj, name = obj.getName(), stack = stack}
    u.nation, u.data = stack and stack.nation, Units[u.name] or {}
    setmetatable(u, T.__meta)
    return u
end})

function Unit:notMoving() return Promise.condition(|| not self.isSmoothMoving(), self) end

function Unit:clearUI()
    self.UI.setCustomAssets()
    self.UI.setXml('')
end

----#include components/units
----#include components/stack
Stack = {units = {}}
setmetatable(Stack, {__call = function (T, obj)
    local s = {obj = obj, units = {}}
    setmetatable(s, {__index = |t, k| T[k] or t.obj[k]})
    setmetatable(s.units, getmetatable(T.units))
    return s
end})
setmetatable(Stack.units, {__index = || 0, __call = function (t)
    local total = 0
    for unit, count in pairs(t) do total = total + count end
    return total
end})

function Stack:attach(units)
    local count, desc = {}, ''
    if self:check(units) then return self:align(units):next(self.attach) end
    for _, unit in ipairs(units) do
        if not self.hasTag('standing') then unit.removeTag('standing') end
        self.units[unit.getName()] = self.units[unit.getName()] + 1
        self.addAttachment(type(unit) == 'table' and unit.obj or unit)
    end
    self:setDisplayName():updateContextMenu()
    return Promise():resolve(self)
end

function Stack:check(units)
    local pos, rot_y, order, align = units[1].getPosition(), units[1].getRotation().y, Units(units[1]).order
    for i = 1, #units do
        local unit = units[i + 1] or self
        local rot = unit.getRotation()
        if rot.x > 180 then rot.x = 360 - rot.x end
        if rot.z > 180 then rot.z = 360 - rot.z end
        if (unit.getPosition() - pos):setAt('y', 0):magnitude() > 0.02 then return 'position'
        elseif (rot - vector(0, rot_y, 0)):magnitude() > 1 then return 'rotation'
        elseif i < #units and Units(unit).order > order then return 'order' end
        pos.y, order = unit.getPosition().y + 0.21, (Units(unit) or {}).order
    end
end

function Stack:align(units)
    local pos, rot_y
    table.sort(units, function (a, b)
        if Units(a).order == Units(b).order then return a.getPosition().y < b.getPosition().y
        else return Units(a).order > Units(b).order end
    end)
    for i, unit in ipairs(units) do
        unit.setLock(true)
        if i == 1 then pos, rot = unit.getPosition(), vector(0, unit.getRotation().y, 0)
        else Stack.alignPosition(unit, pos) end
        Stack.alignRotation(unit, rot)
        pos = pos + vector(0, 0.21, 0)
    end
    self.setLock(true)
    self:alignPosition(pos)
    self:alignRotation(rot)
    return Promise.condition(function ()
        for _, unit in ipairs(units) do if unit.isSmoothMoving() then return false end end
        return not self.isSmoothMoving()
    end):next(function ()
        local pp = Promise()
        Wait.frames(function ()
            for _, unit in ipairs(units) do unit.setLock(false) end
            self.setLock(false)
            Wait.frames(|| pp:resolve(self, units), 1)
        end, 1)
        return pp
    end)
end

function Stack.alignPosition(unit, pos)
    if (unit.getPosition() - pos):magnitude() < 0.1 then unit.setPosition(pos)
    else unit.setPositionSmooth(pos, false, true) end
end

function Stack.alignRotation(unit, rot)
    if (unit.getRotation() - rot):magnitude() < 3 then unit.setRotation(rot)
    else unit.setRotationSmooth(rot, false, true) end
end

function Stack:remove(name)
    local unit_p, stack_p = Promise(), Promise()
    Promise.condition(|| self.units() > 0):next(|| Promise.frames(1, self:detach()))
        :next(function (units) if #units == 1 and units[1].getName() == name then
            self:stash():next(|| stack_p:resolve(self))
            unit_p:resolve(units[1])
        else
            local index
            self.setPositionSmooth(self.getPosition() - units[#units].getPosition() + units[#units - 1].getPosition())
            for i = #units, 1, -1 do if units[i].getName() == name or i == 1 then
                unit_p:resolve(units[i])
                index = i break
            else units[i].setPositionSmooth(units[i - 1].getPosition()) end end
            table.remove(units, index)
            self:notMoving():next(function ()
                self:attach(units)
                stack_p:resolve(self)
        end) end end)
    return unit_p, stack_p
end

function Stack:restoreUnits()
    for _, unit in ipairs(self.getAttachments()) do self.units[unit.name] = self.units[unit.name] + 1 end
    return self
end

function Stack:notMoving() return Promise.condition(|| not self.isSmoothMoving(), self) end

function Stack:setDisplayName()
    local name, details = self:displayName(), ''
    if self.units() > 0 then for unit, count in pairs(self.units) do
        details = string.format('\n %s %s%s', count, unit:proper():colorize(unit), details)
    end end
    self.setName(name .. details)
    return self
end

function Stack:updateContextMenu()
    self.clearContextMenu()
    return self
end

function Stack:region() return Map:getRegion(self) end

----#include components/stack
----#include components/commands
Commands = {cfighters = {}, standing = {}, trays = {}}
setmetatable(Commands, {
    __pairs = function (t, k) return function (t, k)
        local v
        repeat k, v = next(t, k)
        until v == nil or type(v) == 'table' and Nations[k] ~= nil
        if nil ~= v then return k, v end
    end, t, nil end,
    __call = function (t, obj)
        local nation, id = obj.getName():lower():match('^%b[](%a+)%b[] (%d+)')
        if nation and id then return t[nation][tonumber(id)] end
    end
})

function Commands:loadJSON(data)
    self.Setup = {}
    for nation, commands in pairs(JSON.decode(data)) do
        self.Setup[nation] = {}
        for _, command in ipairs(commands) do
            self.Setup[nation][command.id] = command
    end end
end

Commands.Forces = {}
setmetatable(Commands.Forces, {__call = function (t, commands)
    local c = {axis = {}, allies = {}}
    setmetatable(c, {__index = t})
    if commands then for _, command in ipairs(commands) do c:add(command) end end
    return c
end})

function Commands.Forces:add(command, side, force)
    side, force = side or Nations[command.nation].side, force or command.force
    self[side][force] = self[side][force] or {}
    table.insert(self[side][force], command)
end

function Commands:all() return function (t, command)
    local nation
    if command ~= nil then
        nation = command.nation
        _, command = next(t[nation], command.id)
    end
    if command == nil then
        repeat nation, command = next(t, nation)
        until command == nil or type(command) == 'table' and Nations[nation] ~= nil
        if command ~= nil then _, command = next(command) end
    end
    return command
end, self, nil end

function Commands:region(region)
    debug('Getting commands for region ', region)
    local forces, force = self.Forces()
    for command in self:all() do if command:region() == region and not command.hasTag('escaped') then
        forces:add(command)
    end end
    for _, cfighter in ipairs(self.cfighters) do
        if cfighter ~= nil and Map:getRegion(cfighter) == region then
            forces:add(cfighter, Nations[cfighter.nation].side, 'air')
    end end
    if self.standing[region] then forces:add(self.standing[region]) end
    return forces
end

function Commands:byRegion()
    debug('Getting all commands by region')
    local forces = {}
    for command in self:all() do
        local id = Map:getRegion(command)
        if id and not command.hasTag('escaped') then
            forces[id] = forces[id] or Commands.Forces()
            forces[id]:add(command)
    end end
    for _, cfighter in ipairs(self.cfighters) do
        local id = Map:getRegion(cfighter)
        if id then
            forces[id] = forces[id] or Commands.Forces()
            forces[id]:add(cfighter, Nations[cfighter.nation].side, 'air')
    end end
    for id, command in pairs(self.standing) do
        forces[id] = forces[id] or Commands.Forces()
        forces[id]:add(command)
    end
    return forces
end

function Commands:free(nation)
    local free = {}
    for _, command in pairs(self[nation]) do
        if (math.abs(command.getPosition().x) > 45 or command.getPosition().z < -45) and not command.isSmoothMoving() then
            table.insert(free, command)
    end end
    return free
end

function Commands:getNew(nation, force, pos, rot)
    for _, command in ipairs(self:free(nation)) do if command.force == force then
        if pos then
            command.setPositionSmooth(pos)
            if rot then command.setRotationSmooth(rot) end
            return command:notMoving()
        else return Promise():resolve(command) end
    end end
    return Promise():reject('No free commands')
end

function Commands:verifyStacks()
    local ps = {}
    for command in self:all() do if command:region() and command.units() == 0 then
        table.insert(ps, command:form())
    end end
    return #ps > 0 and Promise.all(ps) or Promise():resolve()
end

----#include command
Command = {}
setmetatable(Command, {__call = function (t, obj, nation)
    local name, s, c = obj.getName(), Stack(obj), {}
    if name ~= 'cfighter' then
        c.nation, c.id, c.force = name:lower():match('^%b[](%a+)%b[] (%d+)%a+ (%a+)')
        c.id = c.id and tonumber(c.id)
    else c = {nation = nation, id = obj.guid, force = 'air'} end
    setmetatable(c, {
        __index = |_, k| t[k] or s[k],
        __tostring = |t| '(' .. t.guid .. ') ' .. t.getName():match('^[^\n]+')
    })
    return c
end})

function Command:form(player, units)
    debug('Forming ', Nations[self.nation]:shortName(), ' command stack')
    units = units or player and Player[player].getSelectedObjects() or {}
    if #units < 2 then
        debug('No objects selected, casting for units')
        units = {}
        for _, hit in ipairs(Physics.cast({
            origin = self.getPosition() + vector(0, 0.1, 0),
            direction = {0, -1, 0}, max_distance = 2
        })) do table.insert(units, hit.hit_object) end
        debug('Found ', #units, ' objects')
        table.sort(units, |a, b| a.getPosition().y < b.getPosition().y)
        while #units > 0 and not Units(units[1]) do debug('Removing ', units[1].getName(), ' from list') table.remove(units, 1) end
    else
        debug('Using ', #units, ' selected object(s)')
        table.sort(units, |a, b| a.getPosition().y < b.getPosition().y)
        for i = 1, #units do if units[i].guid == self.guid then table.remove(units, i) break end end
    end
    local invalid
    if #units > 0 and #units < 9 then for _, unit in ipairs(units) do
        local data = Units(unit)
        if not data or not data.cost or data.force ~= self.force then invalid = 'Wrong units for this command type' end
    end else invalid = (#units > 0 and 'Too many' or 'No') .. ' units' end
    if invalid then return Promise():reject('Could not form stack: ' .. invalid)
    else return self:attach(units) end
end

function Command:combine(arg)
    local selected = type(arg) == 'table' and arg or Player[arg].getSelectedObjects()
    local total, invalid = self.units()
    for i = #selected, 1, -1 do if not Units(selected[i]) then
        selected[i] = Commands(selected[i]) or false
        if not selected[i] then invalid = true
        elseif selected[i].guid == self.guid then table.remove(selected, i)
        elseif selected[i].nation ~= self.nation or selected[i].force ~= self.force then invalid = true
        else total = total + selected[i].units() end
    elseif Units(selected[i]).cost then total = total + 1 else invalid = true end end
    if not invalid and #selected > 0 and total < 9 then
        local units, ps = self:detach(), {}
        for i = #selected, 1, -1 do if not Units(selected[i]) then
            for _, unit in ipairs(selected[i]:detach()) do table.insert(units, unit) end
            table.insert(ps, selected[i]:stash())
        else table.insert(units, table.remove(selected, i)) end end
        table.insert(ps, self:attach(units))
        return Promise.all(ps):next(|| self)
    else return Promise():reject('Can\'t merge the selected units') end
end

function Command:destroy()
    return Promise.all(Morale:casualties(self:detach()), self:stash())
end

function Command:destroyUnit(name)
    local unit_p, command_p = self:remove(name)
    return Promise.all(command_p, unit_p:next(|unit| Morale:casualties(unit)))
end

function Command:detach()
    local units = {}
    for _, obj in ipairs(self.removeAttachments()) do table.insert(units, Unit(obj, self)) end
    for unit, _ in pairs(self.units) do self.units[unit] = nil end
    self:setDisplayName()
    self:updateContextMenu()
    return units
end

function Command:stash()
    if self.getName() == 'cfighter' then for i, cfighter in ipairs(Commands.cfighters) do
        if cfighter.guid == self.guid then return stash(table.remove(Commands.cfighters, i)) end
    end end
    self.setTags({'command', self.nation})
    stopGlow(self)
    local offset = vector(math.random() * 3 - 1.5, math.random() * 2 + 4, math.random() * 3 - 1.5)
    self.setPositionSmooth(self.getPosition() + vector(0, 3, 0))
    return self:notMoving():next(|| self.setPositionSmooth(Commands.trays[self.nation][self.force].getPosition() + offset))
end

function Command:placeArrow()
    local is_axis, p = Nations[self.nation]:isAxis(), Promise()
    local offset = is_axis and 0.215 or 0
    self.removeTag('landing')
    Bags.arrow.takeObject({
        position = self.getPosition() + vector(0, 0.25 + offset, 0),
        rotation = vector(0, math.random(360) - 180, is_axis and 180 or 0),
        callback_function = function (arrow)
            Promise.condition(|| arrow.getPosition().y - self.getPosition().y - offset < 0.24)
            :skip(3):next(function ()
                self.jointTo(arrow, {type = 'Fixed'})
                arrow.interactable = false
                p:resolve()
    end) end})
    return p
end

function Command:ordinal()
    local n, tail = self.id, 'th'
    if n < 4 or n > 20 then if n % 10 == 1 then tail = 'st'
    elseif n % 10 == 2 then tail = 'nd'
    elseif n % 10 == 3 then tail = 'rd' end end
    return n .. tail
end

function Command:displayName() return self.getName():match('^[^\n]+') end

function Command:updateContextMenu()
    self.clearContextMenu()
    if self.units() > 0 then
        self.addContextMenuItem('Break stack', || self:detach())
        if self.units() > 1 then self.addContextMenuItem('Split stack', function ()
            Commands:getNew(self.nation, self.force, self.getPosition() + vector(0, 0.25, 0), self.getRotation())
            self:detach()
        end) end
        self.addContextMenuItem('Combine stacks', |player| self:combine(player))
    else self.addContextMenuItem('Form stack', |player| self:form(player)) end
    return self
end

function Command:setAura(clr)
    local lines, y = {}, self.units() * -0.21
    if clr == nil and self.nation ~= 'japan' and self.nation ~= 'italy' and self.nation ~= 'china' then
        clr = Color[self.nation]:lerp(Color.white, 0.3)
    else clr = clr or Color[self.nation] end
    if self.force == 'air' then for r = 12, 1, -1 do table.insert(lines, {
        points = {{0, y, 0}, {0.001, y, 0}}, thickness = 1.05 + 0.1 * r,
        color = clr:copy():setAt('a', 0.1 + 0.9 / r)
    }) end elseif self.force == 'army' then for r = 12, 1, -1 do table.insert(lines, {
        points = {{0, y, 0}, {0.001, y, 0}}, thickness = 1.2 + 0.1 * r,
        color = clr:copy():setAt('a', 0.1 + 0.9 / r)
    }) end else for r = 12, 1, -1 do table.insert(lines, {
        points = {{-0.525, y, 0}, {0.525, y, 0}}, thickness = 0.95 + 0.1 * r,
        color = clr:copy():setAt('a', 0.1 + 0.9 / r)
    }) end end
    self.setVectorLines(lines)
end

function Command:clearAura() self.setVectorLines() end

function Command:clearUI()
    self.UI.setCustomAssets()
    self.UI.setXml('')
end

Construction = {}
setmetatable(Construction, {__call = function (T, obj)
    local s, c = Stack(obj), {}
    setmetatable(c, {__index = |_, k| T[k] or s[k]})
    obj.tooltip = true
    return c
end})

function Construction:displayName() return 'Units under construction' end

function Construction:stash()
    Map.regions[self:region()].construction = nil
    return stash(self)
end

function Construction:detach()
    local units, nation = {}, Map.regions[self:region()]:owner()
    for _, obj in ipairs(self.removeAttachments()) do
        unit = Unit(obj)
        unit.nation = nation
        table.insert(units, unit)
    end
    for unit, _ in pairs(self.units) do self.units[unit] = nil end
    return units
end

function Construction:destroyUnit(name)
    local unit_p, command_p = self:remove(name)
    unit_p.nation = Map.regions[self:region()]:owner()
    return Promise.all(command_p, unit_p:next(|unit| Morale:casualties(unit)))
end

Standing = {}
setmetatable(Standing, {__call = function (T, obj, free)
    local s, c = Stack(obj), {}
    if obj.getName():match('standing army') then
        s:restoreUnits()
        c.nation = obj.getName():lower():match('%b[](%a+)%b[]')
    else
        c = {nation = obj.getName():lower():match('^%a+')}
        obj.tooltip = true
        obj.addTag('standing')
        if free then obj.addTag('free') end
    end
    setmetatable(c, {__index = function (self, k) if k == 'force' then
        return self.units.fighter == self.units() and 'air' or 'army'
    else return T[k] or s[k] end end})
    return c
end})

function Standing:displayName()
    local region = Map.regions[Map:getRegion(self)]
    return string.format('%s standing army (%s)', region.name, Nations[self.nation]:colorized())
end

function Standing:updateContextMenu()
    self.clearContextMenu()
    if not self.hasTag('free') then self.addContextMenuItem('Break stack', || self:detach(true)) end
    return self
end

function Standing:detach(reform)
    local units, tags = {}, self.getTags()
    Commands.standing[Map:getRegion(self)] = nil
    for _, obj in ipairs(self.removeAttachments()) do
        for _, tag in ipairs(tags) do obj.addTag(tag) end
        table.insert(units, Unit(obj, self))
    end
    for unit, _ in pairs(self.units) do self.units[unit] = nil end
    self.obj.tooltip = false
    self.setTags({})
    self.setName(Nations[self.nation]:shortName() .. ' flag')
    self.setDescription()
    if reform then
        local pid = Wait.condition(|| self.clearContextMenu(), function ()
            for i = #units, 1, -1 do if units[i].obj == nil then table.remove(units, i) end end
            return #units == 0
        end)
        self.clearContextMenu()
        self.addContextMenuItem('Form standing army', function ()
            Wait.stop(pid)
            self:attach(units)
            self.obj.tooltip = true
            Commands.standing[Map:getRegion(self)] = self
        end)
    end
    return units
end

function Standing:convert()
    local region, nation, force = Map:getRegion(self), self.nation, self.force
    local units = self.removeAttachments()
    Commands.standing[region] = nil
    self.obj.tooltip = false
    self.setTags({})
    self.setName(Nations[nation]:shortName() .. ' flag')
    self.setDescription()
    self.translate((Map.regions[region]:center() - self.getPosition()):setAt('y', 0):normalize())
    return Commands:getNew(nation, force, self.getPosition(), self.getRotation()):next(|c| c:attach(units))
end

----#include command

----#include components/commands
----#include components/hotspot
Hotspot = {}
Hotspot.__meta = wrapper(Hotspot)
setmetatable(Hotspot, {__call = function (T, ...) if select('#', ...) > 2 then
    local region, data = select(2, ...)
    Map.regions[region].hotspot.resume(data)
else
    local obj, region = ...
    local t = wrap(T, obj)
    if obj.memo == nil then obj.memo = region end
    t.region = obj.memo
    t:regionLabel()
    return t
end end})

----#include ../ui/hotspot
Hotspot.XML = {}

function Hotspot.XML.xmlAngle(obj, offset)
    offset = offset or vector(0, 0, 0)
    return '0 0 ' .. obj.getRotation().y - Map.rotation.y - Map:rotationToCenter(Map.positionToLocal(obj.getPosition() + offset))
end

function Hotspot.XML.nationButtons(nations, label, region, id)
    local buttons = {}
    for _, nation in ipairs(nations) do table.insert(buttons, {tag = 'Button', attributes = {id = nation,
        text = label, icon = nation, fontSize = 30, onClick = 'Global/Hotspot(' .. region .. ')',
        colors = table.concat({Color[nation]:setAt('a', 0.75):toXml(true), Color[nation]:toXml(), 'white', 'clear'}, '|')
    }}) end
    return {tag = 'VerticalLayout', attributes = {id = id or 'nations', height = #nations * 120, width = 216}, children = buttons}
end

function Hotspot.XML.targetButtons(targets, region, active)
    local buttons = {}
    for _, t in ipairs(Combat.BombOrder) do if targets[t.color] and targets[t.color][t.target] then
        table.insert(buttons, {tag = 'Button', attributes = {id = t.color .. '-' .. t.target,
            image = t.target, text = targets[t.color][t.target], fontSize = 60,
            textColor = (t.target == 'bomb' and Color.red or Color.white):toXml(),
            onClick = 'Global/Hotspot(' .. region .. ')', interactable = active or false
        }}) end
    end
    return {tag = 'HorizontalLayout', attributes = {id = 'targets', active = active or false}, children = buttons}
end

function Hotspot:initAssets()
    self.XML.Assets = {Nation = {}, Hit = {}, Bomb = {}, Raid = {}}
    for _, asset in ipairs(UI.getCustomAssets()) do if Units[asset.name] then
        table.insert(self.XML.Assets.Bomb, asset)
        if Units[asset.name].force == 'army' then table.insert(self.XML.Assets.Hit, asset) end
    elseif Nations[asset.name] then
        table.insert(self.XML.Assets.Nation, asset)
        table.insert(self.XML.Assets.Hit, asset)
    elseif asset.name:match('[io][irs][lor]n?') then
        table.insert(self.XML.Assets.Raid, asset)
        table.insert(self.XML.Assets.Bomb, asset)
    elseif asset.name == 'bomb' then
        table.insert(self.XML.Assets.Bomb, asset)
    end end
end

function Hotspot:regionLabel()
    self.UI.setXmlTable({{tag = 'Text', value = Map.regions[self.region]:displayID(), attributes = {id = 'region',
        position = '0 0 -37.1', scale = '0.75 1', fontSize = 56, fontStyle = 'Bold'
    }}})
end

function Hotspot:nationButtons(nations, label, id)
    local xml = self.UI.getXmlTable()
    local buttons = self.XML.nationButtons(nations, label, self.region, id)
    buttons.attributes.position = '0 0 -85'
    buttons.attributes.rotation = self.XML.xmlAngle(self)
    table.insert(xml, buttons)
    self.UI.setCustomAssets(self.XML.Assets.Nation)
    self.UI.setXmlTable(xml)
end

function Hotspot:raidButtons(resources, offset)
    local xml, targets = self.UI.getXmlTable(), {}
    for res in Resources() do if resources[res] then targets[Resources.Colors[res]] = {[res] = ''} end end
    local buttons = self.XML.targetButtons(targets, self.region, true)
    buttons.attributes.height, buttons.attributes.width = 120, #resources * 120
    buttons.attributes.rotation = self.XML.xmlAngle(self, offset)
    offset = self.positionToLocal(self.getPosition() + offset) * 100
    buttons.attributes.position = table.concat({offset.x, offset.z, -offset.y - 60}, ' ')
    table.insert(xml, buttons)
    self.UI.setCustomAssets(self.XML.Assets.Raid)
    self.UI.setXmlTable(xml)
end

function Hotspot:bombButtons(bombers, targets)
    local xml, callback = self.UI.getXmlTable(), 'Global/Hotspot(' .. self.region .. ')'
    bomber_buttons = {tag = 'HorizontalLayout', attributes = {id = 'bombers'}, children = {}}
    for i = 0, bombers do table.insert(bomber_buttons.children, {tag = 'Button', attributes = {id = i,
        image = 'bomber', text = i, textColor = 'white', fontSize = 60, onClick = callback
    }}) end
    target_buttons = self.XML.targetButtons(targets, self.region)
    local width = math.max(#bomber_buttons.children, #target_buttons.children)
    for _, buttons in ipairs{bomber_buttons, target_buttons} do if width > #buttons.children then
        local pad = (width - #buttons.children) * 60
        buttons.attributes.padding = pad .. ' ' .. pad .. ' 0 0'
    end end
    table.insert(xml, {tag = 'Panel', attributes = {
        height = 120, width = width * 120, position = '0 0 -150', rotation = self.XML.xmlAngle(self)
    }, children = {bomber_buttons, target_buttons}})
    self.UI.setCustomAssets(self.XML.Assets.Bomb)
    self.UI.setXmlTable(xml)
end

function Hotspot:hitButtons(targets)
    local xml, rows, cols = self.UI.getXmlTable(), {}, 0
    for nation, _ in pairs(targets) do table.insert(rows, {
        tag = 'HorizontalLayout', attributes = {id = nation}, children = {}
    }) end
    for _, row in ipairs(rows) do
        local nation = row.attributes.id
        for unit, _ in pairs(targets[nation]) do table.insert(row.children, {tag = 'Button', attributes = {id = nation .. '-' .. unit,
            image = unit, icon = #rows > 1 and nation or nil, onClick = 'Global/Hotspot(' .. self.region .. ')'
        }}) end
        cols = math.max(cols, #row.children)
    end
    if #rows > 1 then
        for _, row in ipairs(rows) do
            local pad = (cols - #row.children) * 60
            row.attributes = {padding = pad .. ' ' .. pad .. ' 0 0'}
        end
        rows = {tag = 'VerticalLayout', children = rows}
    else rows = rows[1] end
    rows.attributes = {id = 'hits', height = rows * 120, width = cols * 120, position = '0 0 -85', rotation = self.XML.xmlAngle(self)}
    table.insert(xml, rows)
    self.UI.setCustomAssets(self.XML.Assets.Hit)
    self.UI.setXmlTable(xml)
end

----#include ../ui/hotspot

function Hotspot:stash()
    self.setPositionSmooth(self.getPosition() + vector(0, 3, 0))
    return Promise.condition(|| not self.isSmoothMoving()):next(|| self.destruct())
end

function Hotspot:activate()
    debug('Activating hotspot in ', self.region, ' with tags: ', table.concat(self.getTags(), ', '))
    if not self.hasTag('busy') then
        local commands = Commands:region(self.region)
        local action = self:action(commands)
        debug('Resolving ', action, ' hotspot in region ', self.region)
        Combat[action:proper()](self, commands)
        self.addTag('busy')
        self.removeTag('active')
        HUD.Combat:active(self.hud)
        return true
    end
    return false
end

--TODO: clean up the use of helper functions?
function Hotspot:action(commands)
    local region = Map.regions[self.region]
    commands = commands or Commands:region(region.id)
    local force = region.is_sea and 'fleet' or 'army'
    local side, other, japan_only, ussr_only
    if commands.axis.air or commands.axis[force] then
        side, other = 'axis', 'allies'
        japan_only = Combat.nationOnly('japan', commands.axis.air, commands.axis[force])
    end
    if commands.allies.air or commands.allies[force] then
        ussr_only = Combat.nationOnly('ussr', commands.allies.air, commands.allies[force])
        if side then if state.pact_broken or not (japan_only and ussr_only) then return 'battle' end
        else side, other = 'allies', 'axis' end
    end
    if side then if region.is_sea then
        local convoys = region:activeConvoys()
        if japan_only and ussr_only then
            if convoys.allies and not Combat.convoyOnly('ussr', convoys.allies)
                or convoys.axis and not Combat.convoyOnly('japan', convoys.axis) then return 'raid'
            elseif commands.allies.army and not Combat.nationOnly('ussr', commands.allies.army)
                or commands.axis.army and not Combat.nationOnly('japan', commands.axis.army) then return 'uncontested' end
        elseif convoys[other] and (state.pact_broken or
            not (japan_only and Combat.convoyOnly('ussr', convoys.allies)) and
            not (ussr_only and Combat.convoyOnly('japan', convoys.axis))) then return 'raid'
        elseif commands[other].army and (state.pact_broken or
            not (japan_only and Combat.nationOnly('ussr', commands.allies.army)) and
            not (ussr_only and Combat.nationOnly('japan', commands.axis.army))) then return 'uncontested' end
    else
        local owner = region:side()
        if japan_only and ussr_only then if owner == 'axis' then side, other = 'allies', 'axis' end end
        if region.collapsed and region:owner() == Nations[region.id:sub(1, 1)] then return commands[side].army and 'uncontested'
        elseif owner == other then if commands[side].army then return 'uncontested'
        else for _, command in ipairs(commands[side].air) do if command.units.bomber > 0 then return 'uncontested' end
    end end end end end
    return nil
end

function Hotspot:getCombatants(commands)
    commands = commands or Commands:region(self.region)
    local region, combatants = Map.regions[self.region], {}
    local owner = region:owner()
    if owner then combatants[owner] = true end
    for _, side in pairs(commands) do for _, force in pairs(side) do for _, command in ipairs(force) do
        combatants[command.nation] = true
    end end end
    if self:action(commands) == 'raid' then
        local clusters = region:activeConvoys()
        local side = (commands.axis.air or commands.axis.fleet) and 'allies' or 'axis'
        for _, cluster in ipairs(clusters[side]) do for origin, _ in pairs(cluster) do
            owner = Map.regions[origin:match('^%a%d+')]:owner()
            if owner ~= 'neutral' then combatants[owner] = true end
    end end end
    return combatants
end

-- Battle debrief methods

function Hotspot:finalize(embattled)
    debug('Finalizing hotspot')
    local region = Map.regions[self.region]
    debug('Checking for embattled status in ', region.id)
    if embattled then
        self.flip()
        self:regionLabel()
        if not region.is_sea then region.card:embattled(true) end
    else
        self:stash()
        self.UI.setXml('')
        region.hotspot = nil
        if not region.is_sea then region.card:embattled(false) end
    end
    self.setTags({'inactive'})
    HUD.Combat:done(self.hud)
    Combat.resume()
end

----#include components/hotspot
----#include components/orders
Orders = {}
setmetatable(Orders, {__pairs = function (T, k) return function (t, k)
    local v
    repeat k, v = next(t, k)
    until v == nil or type(v) == 'table'
    if v ~= nil then return k, v end
end, T, nil end})

function Orders:loaded() return Promise.condition(function ()
    for _, orders in pairs(self) do if orders.UI.getXml() == '' then return false end end
    return true
end) end

OrdersChart = Wrapper(function (t, nation)
    t.nation, t.not_china = nation, nation ~= 'china'
    return t
end)

function OrdersChart:initialize(scenario)
    log('Initializing ' .. self.nation .. ' orders')
    self.resources = {current = {oil = self.not_china and 0 or nil, iron = 0, osr = 0}}
    local order_count = Scenarios[scenario].nations[self.nation]
    if not state.orders[self.nation] then
        state.orders[self.nation] = {}
        if self.not_china then
            self:setState(0, 'bid')
            self.trade = {}
            state.orders[self.nation].trade = self.trade
        end
        self:setState({}, 'moves')
        for i = 1, order_count do self:setState({}, 'moves', i) end
        self.purchases = {}
        state.orders[self.nation].purchases = self.purchases
    else
        self:restore(state.orders[self.nation])
        for i, move in ipairs(self.moves) do
            if move.command then move.command = Commands[self.nation][move.command] end
            if move.target then move.target = Map.regions[move.target] end
    end end
    self:loadUI(scenario)
    return self
end

function OrdersChart:restore(state)
    for k, v in pairs(state) do if k ~= 'purchases' and k ~= 'trade' and type(v) == 'table' then
        self[k] = {}
        if next(v) then OrdersChart.restore(self[k], v) end
    else self[k] = v end end
end

----#include ../ui/orders
function OrdersChart:loadUI(scenario)
    local gassets, assets = UI.getCustomAssets(), {}
    for _, asset in ipairs(UI.getCustomAssets()) do
        for _, name in ipairs{
            'cancel', 'confirm', 'invalid', 'maximize', 'maximize-hover', 'neutral', 'pin'
        } do if asset.name == name then table.insert(assets, gassets[id]) end end
        if asset.name == 'pact' and scenario == 'global'
            and (self.nation == 'japan' or self.nation == 'ussr') then table.insert(assets, asset) end
    end
    local pos = |x, y| table.concat({x, y, -59}, ' ')
    local Z, rows, cols = ' -59', {}, {}
    local moves, pre_trade, production = {}, {}, {}
    for i = 1, #self.moves / 3 do
        local col, r = {}, (i - 1) * 3
        for j = 1, 3 do table.insert(col, {tag = 'Cell', children = {
            {tag = 'VerticalLayout', attributes = {}, children = {
                {tag = 'Panel', attributes = {padding = '60 60 40 40'}, children = {
                    {tag = 'InputField', attributes = {class = 'command', id = 'command' .. r + j}}
                }}, {tag = 'Panel', attributes = {padding = '40 40 30 50'}, children = {
                    {tag = 'InputField', attributes = {class = 'target', id = 'target' .. r + j}}
            }}}},
            {tag = 'Text', attributes = {id = 'slash' .. r + j,
                scale = '3 1.5', fontSize = 240, text = '\\', ignoreLayout = true, active = false
            }}
        }}) end
        table.insert(moves, {tag = 'Row', children = col})
    end
    local total_xml, trade_xml = {}, {}
    for resource, value in pairs{oil = 2, iron = 3, osr = 5} do
        table.insert(total_xml, {tag = 'Cell',
            attributes = self.not_china and {columnSpan = 2} or nil,
            children = {{tag = 'Panel', attributes = {class = 'resources'},
                children = (resource ~= 'oil' or self.not_china) and {{tag = 'Text', attributes = {id = 'resources-' .. resource}}} or nil
        }}})
        table.insert(trade_xml, {tag = 'Cell', children = {
            {tag = 'Panel', attributes = {class = 'plus_minus'}, children = {
                {tag = 'VerticalLayout', children = {
                    {tag = 'Panel', children = {{tag = 'ToggleButton', attributes = {class = 'trade', id = 'minus-' .. resource}}}},
                    {tag = 'Panel', children = {{tag = 'ToggleButton', attributes = {class = 'trade', id = 'plus-' .. resource}}}}
        }}}}}})
        table.insert(trade_xml, {tag = 'Cell', children = {
            {tag = 'Panel', attributes = {class = 'trade'}, children = {
                {tag = 'Text', value = value, attributes = {id = 'trade-' .. resource,
                    scale = '1 1', fontStyle = 'Bold', verticalOverflow = 'Overflow', active = false
        }}}}}})
    end
    pre_trade = {{tag = 'Row', children = total_xml}}
    if self.not_china then table.insert(pre_trade, {tag = 'Row', children = trade_xml}) end
    for i, unit in ipairs{'infantry', 'artillery', 'armor', 'fighter', 'bomber', 'submarine', 'cruiser', 'carrier', 'battleship'} do
        cols = {{tag = 'Cell', attributes = {class = 'input'}, children = {
            {tag = 'InputField', attributes = {class = 'purchase', id = unit .. '-quantity'}}
        }}}
        for j, resource in ipairs{'oil', 'iron', 'osr'} do table.insert(cols, {tag = 'Cell', attributes = {class = 'cost'},
            children = i + j > 3 and {{tag = 'Text', attributes = {id = unit .. '-' .. resource}}} or {}
        }) end
        if i < 3 or self.not_china then table.insert(production, {tag = 'Row', attributes = {class = 'purchase'}, children = cols}) end
    end
    if not self.not_china then table.insert(production, {tag = 'Row', attributes = {preferredHeight = 749}, children = {
        {tag = 'Cell', attributes = {columnSpan = 4}}
    }}) end
    cols = {
        {{tag = 'Cell'}}, {{tag = 'Cell'}}, {{tag = 'Cell'}},
        {{tag = 'Cell', attributes = {class = 'input'}, children = {{tag = 'Text', attributes = {id = 'cg-quantity'}}}}}
    }
    for i, id in ipairs{'post_trade', 'cost', 'remaining', 'cg'} do for resource in Resources() do
        if self.not_china or resource ~= 'oil' then table.insert(cols[i], {tag = 'Cell', attributes = {class = 'cost'},
            children = {{tag = id == 'cg' and 'InputField' or 'Text', attributes = {class = 'cg' and 'purchase' or nil, id = id .. '-' .. resource}}}
        }) else table.insert(cols[i], {tag = 'Cell'}) end
    end end
    table.insert(production, 1, {tag = 'Row', attributes = {class = 'resource'}, children = cols[1]})
    table.insert(production, 2, {tag = 'Row', attributes = {class = 'purchase'}, children = cols[4]})
    table.insert(production, {tag = 'Row', attributes = {class = 'resource'}, children = cols[2]})
    table.insert(production, {tag = 'Row', attributes = {preferredHeight = 150}, children = cols[3]})

    local xml = {
        {tag = 'Defaults', children = {
            {tag = 'TableLayout', attributes = {rotation = '0 0 180', cellBackgroundColor = 'clear'}},
            {tag = 'Row', attributes = {class = 'resource', preferredHeight = 127}},
            {tag = 'Row', attributes = {class = 'purchase', preferredHeight = 107}},
            {tag = 'Cell', attributes = {class = 'input', padding = '70 0 6 6'}},
            {tag = 'Cell', attributes = {class = 'cost', padding = '60 0 6 6'}},
            {tag = 'Panel', attributes = {class = 'resources', padding = '80 50 0 20'}},
            {tag = 'Panel', attributes = {class = 'plus_minus', padding = '95 0 42 12'}},
            {tag = 'Panel', attributes = {class = 'trade', padding = '0 80 42 12'}},
            {tag = 'InputField', attributes = {
                colors = '#ffffff3f|#ffffff7f|#ffffff00|#00000000', scale = '0.8 1',
                fontSize = 72, placeholder = ' ', interactable = false
            }},
            {tag = 'InputField', attributes = {class = 'command',
                characterValidation = 'Integer', characterLimit = 3, onEndEdit = 'moveInput'
            }},
            {tag = 'InputField', attributes = {class = 'target',
                characterLimit = 4, onEndEdit = 'moveInput'
            }},
            {tag = 'InputField', attributes = {class = 'purchase',
                characterValidation = 'Integer', characterLimit = 2, onValueChanged = 'purchaseInput'
            }},
            {tag = 'Button', attributes = {class = 'resolve',
                height = 75, width = 240, fontSize = 30, ignoreLayout = true
            }},
            {tag = 'ToggleButton', attributes = {class = 'trade',
                height = 30, width = 30, fontSize = 20, color = Color.white:setAt('a', 0.3):toXml(true),
                onValueChanged = 'tradeClick', transition = 'None', active = false
            }},
            {tag = 'Text', attributes = {scale = '0.8 1', fontSize = 72}}
        }},
        {tag = 'Button', attributes = {id = 'maximize',
            height = 85, width = 85, position = '775 -775' .. Z, rotation = '0 0 180', scale = '0.8 1',
            transition = 'SpriteSwap', image = 'maximize', highlightedSprite = 'maximize-hover',
            onClick = 'maximize', active = false
        }},
        {tag = 'Text', attributes = {id = 'round',
            height = 97, width = 105, position = '560 -586' .. Z, rotation = '0 0 180'
        }},
        {tag = 'ToggleButton', attributes = {id = 'ready',
            height = 32, width = 64, position = '415 -588' .. Z, rotation = '0 0 180', scale = '2.4 3',
            text = 'Ready', fontSize = 18, colors = '#ffffff|#00ff00|#ffff00|#404040ff',
            isOn = true, onValueChanged = 'readyClick', active = false
        }},
        {tag = 'TableLayout', attributes = {id = 'moves',
            height = 350 * #self.moves / 3, width = 780, position = pos(410, #self.moves / 3 == 3 and -34 or -209)
        }, children = moves},
        {tag = 'Panel', attributes = {id = 'resolve',
            height = 320, width = 260, position = pos(670, -390),
            rotation = '0 0 180', scale = '0.8 1', active = false
        }, children = {
            {tag = 'Button', attributes = {class = 'resolve', id = 'confirm',
                position = '-130 0 0', rotation = '0 0 90', text = 'Confirm', icon = 'confirm',
                colors = '#ffffffff|#00cc00ff|#00cc00ff|#000000b2', onClick = 'Global/confirmOrder'
            }}, {tag = 'Button', attributes = {class = 'resolve', id = 'cancel',
                position = '130 0 0', rotation = '0 0 -90', text = 'Cancel', icon = 'cancel',
                colors = '#ffffffff|#ff0000ff|#ff0000ff|#000000b2', onClick = 'Global/cancelOrder'
        }}}},
        {tag = 'TableLayout', attributes = {
            height = self.not_china and 250 or 125, width = 770, position = pos(405, self.not_china and 655 or 592)
        }, children = pre_trade},
        {tag = 'TableLayout', attributes = {id = 'production',
            height = 1474, width = 700, position = pos(-452, 60), useGlobalCellPadding = false, active = false
        }, children = production}
    }
    if self.not_china then table.insert(xml, 4, {tag = 'InputField', attributes = {id = 'bid',
        height = 97, width = 105, position = pos(71, -586), rotation = '0 0 180',
        characterValidation = 'Integer', characterLimit = 2, onValueChanged = 'bidInput'
    }}) end
    if self.nation == 'japan' or self.nation == 'ussr' then table.insert(xml, 3, {tag = 'Button', attributes = {id = 'pact',
        height = 90, width = 200, position = pos(0, -775), rotation = '0 0 180', scale = '0.8 1',
        text = 'Break pact', fontSize = 28, icon = 'pact', colors = '#c0c0c0ff|white|red|#a0a0a080',
        onClick = 'breakPact', interactable = false, active = false
    }}) end
    self.UI.setCustomAssets(assets)
    self.UI.setXmlTable(xml)
end

----#include ../ui/orders

-- GAME PHASE FUNCTIONS --

-- Phase 1: Direct National Economy

function OrdersChart:newRound(round)
    for i = 1, #self.moves do self.UI.setAttribute('slash' .. i, 'active', i > #self.moves - 3 and Morale.stressZone(self.nation) > 3) end
    if round > 1 then
        self:setProduction(true, true)
        self.UI.hide('production')
    end
end

-- Phase 2: Strategic Planning
----#include orders/planning
function OrdersChart:writeOrders(ready_callback, disrupted, resume)
    local attr = {active = true, visibility = Vis[Nations[self.nation].side]}
    if self.not_china then self.UI.setAttributes('bid', attr) end
    self.UI.setAttributes('moves', attr)
    for _, player in ipairs(Player.getPlayers()) do if player.color == Nations[self.nation].player then
        attr.visibility = player.color .. '|Black'
    end end
    self.UI.setAttributes('maximize', attr)
    self:setOrders(false, not resume)
    if disrupted then for i = #self.moves - 2, #self.moves do
        self.UI.hide('command' .. i)
        self.UI.hide('target' .. i)
    end end
    self:enableReady(function (nation, ready)
        self:setOrders(ready)
        HUD.updateStatus(nation, ready)
        ready_callback(nation, ready)
    end)
end

function OrdersChart:restoreOrders()
    if self.not_china and self.bid > 0 then self.UI.setAttribute('bid', 'text', self.bid) end
    for i, move in ipairs(self.moves) do
        if move.command then
            local id, value = 'command' .. i, move.command.id
            self.UI.setAttribute(id, 'text', value)
            UI.setAttribute(self.nation .. '-' .. id, 'text', value)
        end
        if move.target then
            local id, value = 'target' .. i, move.target:displayID()
            self.UI.setAttribute(id, 'text', value)
            UI.setAttribute(self.nation .. '-' .. id, 'text', value)
    end end
end

function OrdersChart:setOrders(lock, clear)
    for i = 1, #self.moves do
        if clear then self:setState({}, 'moves', i) end
        for _, label in ipairs{'command', 'target'} do
            self.UI.setAttribute(label .. i, 'interactable', not lock)
            if clear then
                self.UI.setAttribute(label .. i, 'text', '')
                UI.setAttribute(self.nation .. '-' .. label .. i, 'text', '')
    end end end
    if self.not_china then
        self.UI.setAttribute('bid', 'interactable', not lock)
        if clear then
            self:setState(0, 'bid')
            self.UI.setAttribute('bid', 'text', '')
            UI.setAttribute(self.nation .. '-' .. 'bid', 'text', '')
    end end
    self.UI.setAttribute('maximize', 'active', not lock)
end

function OrdersChart:popout(color)
    self:setOrders(true)
    self.UI.hide('ready')
    HUD.openPopout(self.nation, color)
end

function OrdersChart:minimize()
    self:setOrders(false)
    self.UI.show('ready')
end

function OrdersChart:updateCommand(i, value)
    local id = 'command' .. i
    self.UI.setAttribute(id, 'text', value)
    UI.setAttribute(self.nation .. '-' .. id, 'text', value)
    if value ~= nil and value ~= '' then
        local command = Commands[self.nation][tonumber(value) or 0]
        self:setState(command ~= nil and command:region() ~= nil and command or nil, 'moves', i, 'command')
        if self.moves[i].command then self:inputOK(id, value) else self:inputError(id, value) end
    else self:setState(nil, 'moves', i, 'command'):inputOK(id, '') end
end

function OrdersChart:updateTarget(i, value)
    local id = 'target' .. i
    self.UI.setAttribute(id, 'text', value)
    UI.setAttribute(self.nation .. '-' .. id, 'text', value)
    if value ~= nil and value ~= '' then
        local region = Map.regions[value:gsub('%-', ''):lower()]
        self:setState(region ~= nil and region or nil, 'moves', i, 'target')
        if self.moves[i].target then self:inputOK(id, region:displayID()) else self:inputError(id, value) end
    else self:setState(nil, 'moves', i, 'target'):inputOK(id, '') end
end

function OrdersChart:updateBid(value)
    if value == nil or value >= 0 and value <= self.resources.current.oil then
        self:setState(value or 0, 'bid'):inputOK('bid', value or '')
    else self:setState(0, 'bid'):inputError('bid', value) end
end

----#include orders/planning

-- Phase 3: Movement Operations
----#include orders/movement
function OrdersChart:resolveMovement(n)
    local i = turnOrder[self.nation]
    self.UI.setAttribute('moves', 'visibility', '')
    if n < 9 then
        self.UI.show('resolve')
        UI.setAttribute('movement-nation', 'image', self.nation)
        UI.setAttributes('orders-highlight', {offsetXY = i * 39 .. ' -39', color = Color[self.nation]:setAt('a', 0.2):toXml(true)})
        UI.setAttributes('confirm-panel', {visibility = Vis[Nations[self.nation].side], active = true})
        UI.setAttributes('cancel-panel', {visibility = Vis[Nations[self.nation].side], active = true})
    end
    for j, move in ipairs(self.moves) do if move.command and move.target then
        UI.setValue('command' .. i .. j, move.command.id)
        UI.setValue('target' .. i .. j, move.target:displayID())
        if move.canceled then
            UI.show('slash' .. i .. j)
            self.UI.show('slash' .. j)
        else UI.setAttribute('slash' .. i .. j, 'active', false) end
        UI.setAttribute('order' .. i .. j, 'active', true)
        if j > n and self.moves[j].command and self.moves[j].target then
            self.moves[j].command.obj.memo = self.moves[j].command:region()
    end end end
    for j = n + 1, #self.moves do
        local move = self.moves[j]
        if move.command and move.target then
            setGlow(move.command)
            self:resolveMove(j)
            coroutine.yield()
            stopGlow(move.command)
            move.command.obj.memo = nil
        else self.UI.show('slash' .. j) end
        state.step = state.step + 1
    end
    self.UI.hide('resolve')
end

function OrdersChart:resolveMove(n)
    local command, target = self.moves[n].command, self.moves[n].target
    debug('Resolving ', self.nation, ' move #', n, ': ', command.id, ' --> ', target.id)
    local msg = command:displayName() .. ' moves to ' .. target:colorizedName()
    UI.setValue('movement-order', msg:gsub('%b[]', ''))
    local flag = Movement:evaluateMove(self.nation, command, target)
    if flag == 'invalid' then msg = msg .. ' (' .. string.colorize('Invalid', '_red') .. ')'
    elseif flag == 'pinned' then msg = msg .. ' (' .. string.colorize('Pinned', '_yellow') .. ')'
    elseif flag == 'pact' then msg = msg .. ' (' .. string.colorize('Breaks pact', 'neutral') .. ')' end
    alert(msg)
    local confirm, cancel = {text = 'Confirm', icon = 'confirm', active = true}, {text = 'Cancel', icon = 'cancel'}
    if flag == 'pact' then confirm.text, confirm.icon, confirmOrder = 'Break pact', 'pact', function ()
        Movement.breakPact(self.nation)
        self:resolveMove(n)
    end elseif flag == 'neutral' then confirm.text, confirm.icon, confirmOrder = 'Invasion', 'neutral', function ()
        Movement.invadeNeutral(self.nation, target):next(Movement.resume)
    end else
        confirmOrder = function ()
            if command.id > 9 and command.id < 20 then command.addTag('landing') end
            Movement.resume()
        end
        if flag == 'invalid' then confirm.active, cancel.text, cancel.icon = false, 'Invalid', 'invalid'
        elseif flag == 'pinned' then confirm.active, cancel.text, cancel.icon = false, 'Pinned', 'pin'
        elseif flag == 'partial' then confirm.icon = 'pin'
    end end
    local turn = turnOrder[self.nation]
    cancelOrder = function ()
        self:setState(true, 'moves', n, 'canceled')
        self.UI.show('slash' .. n)
        UI.show('slash' .. turn .. n)
        Movement.resume()
    end
    self.UI.setAttribute('resolve', 'offsetXY', (n - 1) % 3 * -260 .. ' ' .. math.floor((n - 1) / 3) * 356)
    self.UI.setAttributes('confirm', confirm)
    self.UI.setAttributes('cancel', cancel)
    local i, y, x1, x2 = turn, -4 - n * 39
    if i == 1 then x1, x2 = (i + 1) * 39, (i + 3) * 39
    elseif i > 5 then x1, x2 = (i - 4) * 39 + 4, (i - 2) * 39 + 4
    else x1, x2 = (i - 2) * 39 + 4, (i + 1) * 39 end
    UI.setAttribute('confirm-panel', 'offsetXY', x1 .. ' ' .. y)
    UI.setAttributes('confirm', confirm)
    UI.setAttribute('cancel-panel', 'offsetXY', x2 .. ' ' .. y)
    UI.setAttributes('cancel', cancel)
end

----#include orders/movement

-- Phase 7: Production
----#include orders/production
function OrdersChart:writeProduction(ready_callback, trades, resume)
    local attr = {active = true, visibility = Vis[Nations[self.nation].side]}
    self.UI.setAttributes('production', attr)
    self:setProduction(false, not resume)
    if next(trades) ~= nil then for resource, _ in pairs(self.resources.current) do
        self.UI.show('minus-' .. resource)
        if trades[resource] then self.UI.show('plus-' .. resource) end
    end end
    self:enableReady(function (nation, ready)
        self:setProduction(ready)
        HUD.updateStatus(nation, ready)
        ready_callback(nation, ready)
    end)
end

function OrdersChart:restoreProduction()
    if self.not_china then for sign, resource in pairs(self.trade) do self.UI.setAttributes(sign .. '-' .. resource, {
        color = (sign == 'plus' and Color._green or Color._red):setAt('a', 0.5):toXml(true), isOn = true
    }) end end
    for unit, data in pairs(self.purchases) do if data.quantity > 0 then
        if unit == 'cg' then self.UI.setValue('cg-quantity', data.quantity)
        else self.UI.setAttribute(unit .. '-quantity', 'text', data.quantity) end
        for resource, value in pairs(data) do if resource ~= 'quantity' then if unit == 'cg' then
            self.UI.setAttribute('cg-' .. resource, 'text', value)
        else self.UI.setValue(unit .. '-' .. resource, value) end end end
    end end
end

function OrdersChart:setProduction(lock, clear)
    for resource, _ in pairs(self.resources.current) do
        self.UI.setAttribute('cg-' .. resource, 'interactable', not lock)
        if clear then
            self.UI.setAttribute('cg-' .. resource, 'text', '')
            self:updatePurchase(0, 'cg', resource)
    end end
    for unit, data in pairs(Units) do if type(data) == 'table' and data.cost and (self.not_china or not data.cost.oil) then
        self.UI.setAttribute(unit .. '-quantity', 'interactable', not lock)
        if clear then
            self.UI.setAttribute(unit .. '-quantity', 'text', '')
            self:updatePurchase(0, unit)
    end end end
    if self.not_china then for resource, _ in pairs(self.resources.current) do for _, sign in ipairs{'plus', 'minus'} do
        self.UI.setAttribute(sign .. '-' .. resource, 'interactable', not lock)
        if clear then
            self.UI.setAttribute(sign .. '-' .. resource, 'isOn', false)
            if self.trade[sign] == resource then self:toggleTrade(false, sign, resource) end
    end end end end
end

function OrdersChart:toggleTrade(on, sign, trade)
    local other = sign == 'plus' and 'minus' or 'plus'
    local reset = {color = Color.white:setAt('a', 0.3):toXml(true), isOn = false}
    self.trade[sign] = on and trade or nil
    if not on then self.UI.setAttributes(sign .. '-' .. trade, reset) else
        if self.trade[other] == trade then self.trade[other] = nil end
        self.UI.setAttribute(sign .. '-' .. trade, 'color', (sign == 'plus' and Color._green or Color._red):setAt('a', 0.5):toXml(true))
        for res, _ in pairs(self.resources.current) do
            self.UI.setAttributes((res == trade and other or sign) .. '-' .. res, reset)
    end end
    self:updateTrade()
end

function OrdersChart:resetTrade(sign, resource) self.UI.setAttributes(sign .. '-' .. resource, {
    color = Color.white:setAt('a', 0.3):toXml(true), isOn = false
}) end

function OrdersChart:updateTrade()
    local hidden = state.phase == 7 and state.step == 2
    self.resources.post_trade = {}
    for resource, value in pairs(self.resources.current) do
        local tid, rid = 'trade-' .. resource, 'post_trade-' .. resource
        self.resources.post_trade[resource] = value
        if self.not_china then if resource == self.trade.plus then
            self.UI.setAttributes(tid, {color = Color._green:setAt('a', 0.5):toXml(), active = true})
            if self.trade.minus then self.resources.post_trade[resource] = value + tonumber(self.UI.getValue(tid)) end
        elseif resource == self.trade.minus then
            self.UI.setAttributes(tid, {color = Color.red:setAt('a', 0.5):toXml(), active = true})
            if self.trade.plus then self.resources.post_trade[resource] = value - tonumber(self.UI.getValue(tid)) end
        else self.UI.hide(tid) end end
        self.UI.setValue(rid, hidden and '' or self.resources.post_trade[resource])
    end
    self:updateResources(hidden)
end

function OrdersChart:updatePurchase(value, unit, res)
    self.purchases[unit] = self.purchases[unit] or {}
    if unit == 'cg' then
        local total = 0
        self.purchases.cg[res] = value > 0 and value or nil
        for k, cost in pairs(self.purchases.cg) do if k ~= 'quantity' then total = total + cost end end
        self.purchases.cg.quantity = math.floor(total / 5)
        if total == 0 then
            self.purchases.cg = nil
            self.UI.setValue('cg-quantity', '')
        else self.UI.setValue('cg-quantity', self.purchases.cg.quantity) end
    else
        self.purchases[unit].quantity = value
        for resource, cost in pairs(Units[unit].cost) do
            self.purchases[unit][resource] = cost * value
            self:setIntValue(unit .. '-' .. resource, self.purchases[unit][resource])
        end
        if value == 0 then self.purchases[unit] = nil end
    end
    self:updateResources(state.phase == 7 and state.step == 2)
end

function OrdersChart:updateResources(hidden)
    self.resources.cost = {oil = self.not_china and 0 or nil, iron = 0, osr = 0}
    local cg_spent, enable_ready = 0, true
    for unit, data in pairs(self.purchases) do for resource, cost in pairs(data) do if resource ~= 'quantity' then
        self.resources.cost[resource] = self.resources.cost[resource] + cost
        if unit == 'cg' then cg_spent = cg_spent + cost end
    end end end
    if cg_spent % 5 > 0 then
        for res, _ in pairs(self.resources.current) do self:inputError('cg-' .. res) end
        enable_ready = false
    else for res, _ in pairs(self.resources.current) do self:inputOK('cg-' .. res) end end
    self.resources.remaining = {}
    for resource, cost in pairs(self.resources.cost) do
        self.resources.remaining[resource] = (self.resources.post_trade or self.resources.current)[resource] - cost
        self:setIntValue('cost-' .. resource, hidden and 0 or cost)
        self.UI.setValue('remaining-' .. resource, hidden and '' or self.resources.remaining[resource])
        if self.resources.remaining[resource] < 0 then
            self:inputError('remaining-' .. resource)
            enable_ready = false
        else self:inputOK('remaining-' .. resource) end
    end
    if not hidden then self.UI.setAttribute('ready', 'interactable', enable_ready) end
end

function OrdersChart:revealPurchases()
    self.UI.setAttributes('production', {active = true, visibility = ''})
    local purchases = {}
    for unit, t in pairs(self.purchases) do purchases[unit] = t.quantity end
    return purchases
end

----#include orders/production

-- INTERFACE FUNCTIONS --

function OrdersChart:setResources(data)
    self.resources.current = data
    for resource, value in pairs(data) do if resource ~= 'oil' or self.not_china then
        self.UI.setValue('resources-' .. resource, value)
    end end
    self:updateTrade()
end

function OrdersChart:breakPact(color)
    if rawget(self, 'pact') == nil or self.pact ~= color then
        local colors, r = self.UI.getAttribute('pact', 'colors'), 0
        self.pact = color
        self.UI.setAttribute('pact', 'colors', colors:gsub('white', Color[self.nation]:toXml(false)))
        Wait.time(function ()
            r = r + 0.05
            if r > 0.96 then
                self.pact = nil
                self.UI.setAttribute('pact', 'colors', colors)
            else self.UI.setAttribute('pact', 'colors', colors:gsub('([^|]+|)[^|]+(|[^|]+|.+)',
                '%1' .. Color[self.nation]:lerp(Color.white, r):toXml(false) .. '%2')) end
        end, 0.1, 20)
        broadcastToColor('Press again within 2 seconds to break the pact', color)
    else Movement.breakPact(self.nation) end
end

-- HELPER FUNCTIONS --

function OrdersChart:setState(value, ...)
    local ks, t, s = {...}, self, state.orders[self.nation]
    for i = 1, #ks - 1 do t, s = t[ks[i]], s[ks[i]] end
    t[ks[#ks]] = value
    if type(value) == 'table' then if value.id then s[ks[#ks]] = value.id
    elseif next(value) == nil then s[ks[#ks]] = {} end
    else s[ks[#ks]] = value end
    return self
end

function OrdersChart:toggleReady(ready)
    self.UI.setAttributes('ready', {isOn = not ready, color = ready and '#80ff80' or '#ffffff'})
    self.onReady(self.nation, ready)
end

function OrdersChart:enableReady(callback)
    self.UI.setAttributes('ready', {color = '#ffffff', isOn = true, active = true})
    if callback then self.onReady = callback end
end

function OrdersChart:inputOK(id, value)
    self.UI.setAttributes(id, {text = value, textColor = 'black'})
    UI.setAttributes(self.nation .. '-' .. id, {text = value, textColor = 'black'})
end

function OrdersChart:inputError(id, value)
    self.UI.setAttributes(id, {text = value, textColor = 'red'})
    UI.setAttributes(self.nation .. '-' .. id, {text = value, textColor = 'red'})
end

function OrdersChart:setIntValue(id, value) self.UI.setValue(id, value == 0 and '' or value) end

----#include components/orders
----#include components/resources
Resources = {Colors = {oil = 'red', iron = 'blue', osr = 'yellow'}}
setmetatable(Resources, {
    __pairs = function (T, k) return function (t, k)
        local v
        repeat k, v = next(t, k)
        until v == nil or type(v) == 'table'
        if v ~= nil then return k, v end
    end, T, nil end,
    __call = |t| pairs(t.Colors)
})

ResourceChart = Wrapper(function (t, nation)
    t.nation, t.not_china = nation, nation ~= 'china'
    return t
end)

function ResourceChart:initialize()
    log('Initializing ' .. self.nation .. ' resource chart')
    for resource in Resources() do if resource ~= 'oil' or self.not_china then
        self[resource] = {value = 0, more = {value = 0}}
    end end
    self.snaps = {oil = {}, iron = {}, osr = {}}
    for i, snap in ipairs(self.getSnapPoints()) do
        table.insert(self.snaps[i < 22 and 'oil' or i < 43 and 'iron' or 'osr'], self.positionToWorld(snap.position))
    end
    return self
end

function ResourceChart:loaded() self.setVar('loaded', true) end

function ResourceChart:add(data)
    totals = {oil = self.not_china and data.oil or nil}
    for resource, value in pairs(self:totals()) do if data[resource] then
        totals[resource] = math.max(data[resource] + value, 0)
    end end
    self:set(totals)
end

function ResourceChart:set(data)
    local current = self:totals()
    for resource, value in pairs(data) do
        self[resource].value, self[resource].more.value = math.min(value, 20), math.max(value - 20, 0)
        if current[resource] < 20 or value < 20 then self:adjustPeg(resource) end
        if value > 20 then
            if current[resource] < 21 then
                self[resource].more.peg = self[resource].peg.clone({position = self.snaps[resource][self[resource].more.value + 1]})
                self[resource].more.peg.setColorTint(Color.white)
                self[resource].more.peg.setName('more')
            else self:adjustPeg(resource, true) end
        elseif current[resource] > 20 then self[resource].more.peg.destruct() end
    end
    for resource, value in pairs(current) do data[resource] = data[resource] or value end
    self:updateUI(data)
end

function ResourceChart:zero()
    data = {iron = 0, osr = 0}
    if self.not_china then data['oil'] = 0 end
    self:set(data)
end

function ResourceChart:updateUI(data)
    data = data or self:totals()
    Orders[self.nation]:setResources(data)
    HUD.setResources(self.nation, data)
end

function ResourceChart:totals()
    local resources = {}
    for resource in Resources() do if resource ~= 'oil' or self.not_china then
        resources[resource] = self[resource].value + self[resource].more.value
    end end
    return resources
end

function ResourceChart:adjustPeg(resource, more)
    local t = more and self[resource].more or self[resource]
    t.peg.setPositionSmooth(self.snaps[resource][t.value + 1] + vector(0, 0.1, 0))
end

function ResourceChart:pegDown(peg, point)
    debug('Peg down on ', self.nation, ' resource chart')
    point = vector(table.unpack(point))
    local resource, value, t
    for res, points in pairs(self.snaps) do for i, snap in ipairs(points) do
        if point:distance(snap) < 0.005 then resource, value = res, i - 1 break end
    end if resource then break end end
    if peg.getName() == resource then t = self[resource]
    elseif resource and peg.getName() == 'more' then t = self[resource].more end
    if t then
        t.value, t.peg = value, peg
        self:updateUI()
    end
end

function ResourceChart:pegUp(peg)
    debug('Peg up on ', self.nation, ' resource chart')
    for resource in Resources() do if resource ~= 'oil' or self.not_china then
        if self[resource].more.peg ~= nil and peg.guid == self[resource].more.peg.guid then
            self[resource].more = {value = 0}
            self:updateUI() break
    end end end
end

----#include components/resources
----#include components/battle
Battle = {}
setmetatable(Battle, {__call = function (self, ...)
    if select('#', ...) == 3 then
        local player, value, id = ...
        if id == 'hit' then
            local hand, clr, stance, stack = value:match('(%w+)%-(%w+)%-(%w+)%-(%w+)')
            self[hand].combat.resume(player, {color = clr, stance = stance, stack = stack})
        elseif value ~= 'left' and value ~= 'right' then
            local hand, key = value:match('(%w+)%-([%w%-]+)')
            self[hand].combat.resume(player, id, key)
        elseif id:match('confirm') then
            local side = id:match('^%a+')
            if Vis[side]:match(player.color) then self[value].combat.resume(side) end
        elseif not id:match('%d$') then self[value].combat.resume(id)
        else self[value].combat.resume(id:match('^(%a+)%-%a+(%d)$')) end
    else
        local board, hand = ...
        local b = {board = board, hand = hand, zones_active = false}
        setmetatable(b, {__index = |t, k| self[k] or t.board[k]})
        return b
end end})

function Battle:mode() return self.is_face_down and 'sea' or 'land' end

----#include ../ui/battle
Battle.XML = {Defaults = {
    Text = {
        ground = {color = '#42352d', shadow = '#d2c6b6', shadowDistance = '1 -3'},
        air = {color = '#4d5959'},
        bomb = {color = '#cc6b58', shadow = '#6a4f46', shadowDistance = '3 -1'},
        surface = {color = '#202040', shadow = '#a0a0ff'}
    },
    Button = {
        axis = {colors = 'clear|#c0808040|#c0808080|#a04040'},
        allies = {colors = 'clear|#a0a0ff40|#a0a0ff80|#4040a0'}
    },
    Panel = {fadein = {showAnimation = 'FadeIn', animationDuration = 0.5}}
}}

function Battle.XML.rollers(naval, side)
    local rows, X = {}, 144 * (side == 'axis' and 1 or -1) * (naval and -1 or 1)
    for i = 1, 10 do table.insert(rows, {tag = 'Panel', attributes = {padding = '0 0 25 25'}, children = {
        {tag = 'Button', attributes = {id = side .. '-roll' .. i, class = side, onClick = 'rollDice'}}
    }}) end
    return {tag = 'VerticalLayout', attributes = {id = side .. '-roller',
        position = X + (side == 'axis' and not naval and 1 or 0) .. ' -9 ' .. (naval and 1 or -21),
        rotation = '0 ' .. (naval and 180 or 0) .. ' 0', scale = '0.1 0.1', height = 1725, width = 90
    }, children = rows}
end

function Battle.XML.status(hand, naval)
    local children = {
        {tag = 'Text', attributes = {id = 'region',
            position = '5 -22 0', width = 180, scale = '1.2 1', fontSize = 60, fontStyle = 'Bold'
        }},
        {tag = 'Text', attributes = {id = 'status',
            position = '5 24 0', width = 260, fontSize = 42, color = '#cccccc'
        }}
    }
    for side, sign in pairs{axis = -1, allies = 1} do
        for dice_type, params in pairs({
            ground = {pos = 190, width = 103},
            surface = {pos = 210, width = 113},
            air = {pos = naval and 325 or 295, width = 102},
            bomb = {pos = 405, width = 112}
        }) do table.insert(children, {tag = 'Panel', attributes = {id = side ..'-' .. dice_type,
            position = 5 + params.pos * sign .. ' 0 0', width = params.width, active = false
        }, children = {
            {tag = 'Image', attributes = {image = dice_type .. '-dice'}},
            {tag = 'Text', attributes = {id = side .. '-' .. dice_type .. '-dice',
                class = dice_type, scale = '0.8 1', fontSize = 84, fontStyle = 'Bold'
            }}
        }}) end
        table.insert(children, {tag = 'Panel', attributes = {id = side ..'-confirm-panel',
            position = 5 + (naval and 580 or 650) * sign .. ' 0 0',
            height = 80, width = 300, color = '#404040', active = false
        }, children = {{tag = 'Button', attributes = {id = side .. '-confirm',
            class = side, fontSize = 42, textColor = 'white', onClick = 'Global/Battle(' .. hand .. ')'
        }}}})
    end
    return children
end

function Battle.XML.targets(hand)
    local children = {}
    for side, params in pairs{
        axis = {align = {'Left', 'Right'}, width = 566, sign = -1},
        allies = {align = {'Right', 'Left'}, width = 568, sign = 1}
    } do table.insert(children, {tag = 'Panel', attributes = {id = side .. '-targets',
        rectAlignment = 'Middle' .. params.align[1], width = params.width, color = '#000000d8', active = false
    }, children = {{tag = 'Panel', attributes = {
        height = 25, width = 82, rectAlignment = 'Lower' .. params.align[2],
        rotation = '0 0 ' .. 90 * params.sign, color = '#000000f0'
    }, children = {{tag = 'Text', value = 'Targets', attributes = {
        fontSize = 20, fontStyle = 'Bold', color = 'White', horizontalOverflow = 'Overflow'
    }}}}}}) end
    for i, t in ipairs(Combat.BombOrder) do table.insert(children, {tag = 'Button', attributes = {id = t.color .. '-' .. t.target,
        height = 64, width = 64, rectAlignment = 'MiddleLeft', image = t.target, fontSize = 36, textOutline = 'black',
        colors = '#f0f0f0c0|#ffffffff|' .. Color['_' .. t.color]:toXml() .. '|#606060c0',
        onClick = 'Global/Battle(' .. hand .. ')', active = false
    }}) end
    return children
end

function Battle.XML:defaults()
    local children = {}
    for tag, classes in pairs(self.Defaults) do for class, attr in pairs(classes) do
        if class ~= 'default' then attr.class = class end
        table.insert(children, {tag = tag, attributes = attr})
    end end
    return children
end

function Battle.XML:setup(hand, naval)
    local rot = (naval and 180 or 0) .. ' 0 ' .. (naval and 0 or 180)
    local xml = {
        {tag = 'Defaults', children = self:defaults()},
        {tag = 'Panel', attributes = {id = 'status-panel',
            class = 'fadein', position = '0 104 ' .. (naval and 1 or -21),
            rotation = rot, scale = '0.15 0.15', height = 107, width = 2100,
            color = '#282020', active = false
        }, children = self.status(hand, naval)},
        {tag = 'Panel', attributes = {id = 'targets', class = 'fadein',
            position = '0.2 -86.2 -21', rotation = '0 0 180', scale = '0.2 0.2', height = 82, width = 1390
        }, children = self.targets(hand)}
    }
    for side in pairs(Nations.other) do table.insert(xml, self.rollers(naval, side)) end
    return xml
end

function Battle.XML:repairs(align, onClick)
    local buttons = {}
    for resource, attr in pairs{
        osr = {align = 'Upper'},
        iron = {align = 'Lower'},
        oil = {align = 'Middle', offset = (align == 'Left' and -56 or 56) .. ' 0'}
    } do table.insert(buttons, {tag = 'Button', attributes = {
        id = resource, height = 56, width = 56, offsetXY = attr.offset,
        rectAlignment = attr.align .. align, image = resource,
        transition = 'SpriteSwap', highlightedSprite = resource .. '-hover',
        colors = 'white|white|white|#606060a0', onClick = onClick
    }}) end
    return table.unpack(buttons)
end

function Battle:loadUI()
    log('Loading battle board UI')
    local assets = {}
    for _, asset in ipairs(UI.getCustomAssets()) do
        if asset.name:match('dice') or Units[asset.name] or asset.name == 'bomb' then
            table.insert(assets, asset)
        elseif asset.name:match('[io][irs][lor]n?') then
            table.insert(assets, asset)
    end end
    self.UI.setCustomAssets(assets)
    self.UI.setXmlTable(self.XML:setup(self.hand, self.is_face_down))
end

function Battle:flipUI()
    local naval = not self.is_face_down
    for side, sign in pairs{axis = -1, allies = 1} do
        local attr = self.XML.rollers(naval, side).attributes
        self.UI.setAttributes(side .. '-rollers', {position = attr.position, rotation = attr.rotation})
        self.UI.setAttribute(side .. '-air', 'position', 5 + (naval and 325 or 295) * sign .. ' 0 0')
        self.UI.setAttribute(side .. '-confirm-panel', 'position', 5 + (naval and 580 or 650) * sign .. ' 0 0')
    end
    self.UI.setAttributes('status-panel', {
        position = '0 104 ' .. (naval and 1 or -21),
        rotation = (naval and 180 or 0) .. ' 0 ' .. (naval and 0 or 180)
    })
end

function Battle:updateTarget(clr, target, attr)
    attr.textColor = clr == 'white' and 'red' or 'white'
    self.UI.setAttributes(clr .. '-' .. target, attr)
end

----#include ../ui/battle
----#include battle/config
function Battle.diceHandler(zone, value)
    if Battle.left.zones_active and zone.hasTag('left') then
        Battle.left:updateDice(zone, value)
    elseif Battle.right.zones_active and zone.hasTag('right') then
        Battle.right:updateDice(zone, value)
    end
end

function Battle:initialize()
    self.bags = {}
    for side in pairs(Nations.other) do self.bags[side] = Dice(Tags.getObject({self.hand, side, 'dice'})) end
    self:setupZones()
    self:loadUI()
    self.RepairAssets = {}
    for _, asset in ipairs(UI.getCustomAssets()) do
        if Nations[asset.name] or asset.name:match('[io][irs][lor]n?') then
            table.insert(self.RepairAssets, asset)
    end end
    return self
end

function Battle:setupZones()
    log('Initializing battle zones')
    self.commands = Battle.Zone(Tags.getObject({self.hand, 'command'}), {z = 0.178})
    self.casualties, self.stances = {}, {land = {}, sea = {}}
    local naval = self:mode() == 'sea'
    local v = self.positionToLocal(self.commands.getPosition()):setAt('y', naval and 0 or 0.2)
    for side, params in pairs{
        axis = {tilt = 33, x = -0.008},
        allies = {tilt = -33, x = 0.011}
    } do
        self.casualties[side] = Battle.Zone(Tags.getObject({self.hand, side, 'casualty'}), {z = 0.01})
        for nation, x in pairs(Battle.Snaps[self:mode()][side].nations) do self.commands.snaps[nation] = {
            position = v:copy():setAt('x', x),
            rotation = vector(0, naval and params.tilt or 0, naval and -180 or 0)
        } end
        for mode, t in pairs(self.stances) do
            t[side] = {}
            setmetatable(t[side], {__index = {x = params.x}})
        end
        for unit, specs in pairs(Units) do for stance, data in pairs(specs.stances or {}) do
            local mode, zone = self:mode(), Tags.getObject({self.hand, side, unit, stance})
            if not zone then for _, obj in Tags.forAllObjects({self.hand, side}) do
                if obj.memo == unit .. '-' .. stance then zone, mode = obj, naval and 'land' or 'sea' break end
            end end
            local rotation = specs.force == 'fleet' and vector(0, params.tilt, -180) or vector(0, 0, mode == 'land' and 0 or -180)
            local y = mode == 'land' and 0.2 or 0
            local snaps, xs = Battle.Snaps[mode][side], {casualty = Battle.Snaps[mode][side].casualty}
            zone = Battle.Stance(zone, data)
            zone.side, zone.unit = side, unit
            local z = self.positionToLocal(zone.getPosition()).z - (mode == self:mode() and 0 or zone.z)
            for nation, x in pairs(snaps.nations) do if nation ~= 'china' or specs.force == 'army' then xs[nation] = x end end
            if zone.hp == 3 then xs.sustained, xs.damaged2 = snaps.sustained, snaps.damaged2
            elseif zone.hp == 2 then xs.damaged = snaps.damaged end
            for label, x in pairs(xs) do zone.snaps[label] = {position = vector(x, y, z), rotation = rotation} end
            if unit == 'submarine' then zone.snaps.escaped = {position = vector(side == 'axis' and -1.275 or 1.27, y, -0.365), rotation = vector(0, 0, -180)} end
            self.stances[mode][side][unit] = self.stances[mode][side][unit] or {}
            self.stances[mode][side][unit][stance] = zone
        end end
    end
end

Battle.Zone = {}
setmetatable(Battle.Zone, {__call = function (T, obj, z)
    z = z or {}
    z.obj, z.snaps = obj, {}
    setmetatable(z, {__index = |t, k| T[k] or t.obj[k]})
    return z
end})

Battle.Stance = {}
setmetatable(Battle.Stance, {__call = function (T, obj, params)
    local t, z = {}, Battle.Zone(obj)
    setmetatable(t, {__index = |_, k| params[k] or T[k] or z[k]})
    return t
end})

function Battle.Stance:getUnits()
    self.units = self.getObjects()
    return self.units
end

Battle.Snaps = {land = {
    axis = {sustained = 0.88, damaged = 1.035, damaged2 = 1.085, casualty = 1.29, nations = {
        italy = 0.325, japan = 0.515, germany = 0.69,
    }},
    allies = {sustained = -0.87, damaged = -1.025, damaged2 = -1.075, casualty = -1.285, nations = {
        uk = -0.3, ussr = -0.465, usa = -0.63, china = -0.8
    }}
}, sea = {
    axis = {sustained = -0.89, damaged = -1.035, damaged2 = -1.085, casualty = -1.29, nations = {
        italy = -0.335, japan = -0.525, germany = -0.705,
    }},
    allies = {sustained = 0.885, damaged = 1.025, damaged2 = 1.08, casualty = 1.285, nations = {
        uk = 0.34, ussr = 0.52, usa = 0.7
    }}
}}

----#include battle/config
----#include battle/setup
function Battle:initializeCombat(combat)
    local region = Map.regions[combat.hotspot.region]
    debug('Setting up battle for region ', region.id)
    local mode = region.is_sea and 'sea' or 'land'
    self.combat = combat
    self.UI.setValue('region', region:displayID())
    self.UI.setAttribute('region', 'color', Color[Nations[region.id:sub(1, 1)] or 'sea']:toXml())
    if mode ~= self:mode() then self:flipBoard() end
    self.UI.show('status-panel')
    self.UI.setValue('status', 'Set stances')
    self.dice, self.zones_active = {}, true
    for side, _ in pairs(Nations.other) do
        self.UI.hide(side .. '-roller')
        for _, stage in ipairs(mode == 'land' and {'air', 'bomb', 'ground'} or {'air', 'surface'}) do
            self.dice[stage] = self.dice[stage] or {}
            self.dice[stage][side] = 0
    end end
end

function Battle:flipBoard()
    local sign = self.is_face_down and -1 or 1
    self:adjustZones()
    self:flipUI()
    self.setPositionSmooth(self.getPosition() + vector(0, 0.2, 0) * sign)
    self.setRotationSmooth(self.getRotation() + vector(0, 0, 180) * sign)
    Wait.condition(function ()
        self:adjustSnaps()
        Wait.condition(|| self.combat.resume(), || self.UI.getAttribute('status-panel', 'position') == '0 104 ' .. (self.is_face_down and 1 or -21))
    end, || not self.isSmoothMoving())
    coroutine.yield()
end

function Battle:adjustZones()
    local sign = self.is_face_down and -1 or 1
    for _, zone in ipairs{self.commands, self.casualties.axis, self.casualties.allies} do
        zone.translate(vector(0, 0, zone.z) * self.getScale() * sign)
    end
    for side, units in pairs(self.stances[self.is_face_down and 'land' or 'sea']) do
        for unit, stances in pairs(units) do for stance, zone in pairs(stances) do
            zone.translate(vector(sign * units.x, 0, zone.z) * self.getScale())
            local old_unit, old_stance
            for _, tag in ipairs(zone.getTags()) do
                if Units[tag] then old_unit = tag
                elseif tag ~= 'left' and tag ~= 'right' and tag ~= 'axis' and tag ~= 'allies' then old_stance = tag
            end end
            zone.obj.memo = old_unit .. '-' .. old_stance
            zone.setTags({self.hand, side, unit, stance})
    end end end
end

function Battle:adjustSnaps()
    local mode, snaps = self:mode(), {}
    local y, z = mode == 'land' and 0.2 or 0, self.positionToLocal(self.commands.getPosition()).z
    local rotation = mode == 'land' and vector(0, 0, 0) or vector(0, 33, -180)
    for side, t in pairs(Battle.Snaps[mode]) do for nation, x in pairs(t.nations) do
        local snap = {position = vector(x, y, z), rotation = rotation * vector(1, side == 'axis' and 1 or -1, 1)}
        self.commands.snaps[nation] = snap
        table.insert(snaps, {tags = {'command', nation}, snap = snap})
    end end
    for _, units in pairs(self.stances[mode]) do for unit, stances in pairs(units) do for _, stance in pairs(stances) do
        for _, snap in pairs(stance.snaps) do table.insert(snaps, {tags = {unit}, snap = snap}) end
    end end end
    for i = 1, #snaps do snaps[i] = {
        position = snaps[i].snap.position, rotation = snaps[i].snap.rotation * vector(0, -1, 0),
        rotation_snap = true, tags = snaps[i].tags
    } end
    self.setSnapPoints(snaps)
end

function Battle:placeUnits(sides)
    local battle, ps, mode = {axis = {nations = {}}, allies = {nations = {}}}, {}, self:mode()
    local region = Map.regions[self.combat.hotspot.region]
    for side, forces in pairs(sides) do for force, commands in pairs(forces) do
        if region.industry and region:side() ~= side then battle[side].special = true end
        if force == 'air' then battle[Nations.other[side]].antiair = true end
        if force ~= 'army' or mode == 'land' then for _, command in ipairs(commands) do
            local t = battle[side].nations[command.nation] or {}
            battle[side].nations[command.nation] = t
            if command.getName() == 'cfighter' then
                t.fighter = t.fighter or {}
                table.insert(t.fighter, 1, command)
                command.origin = {pos = command.getPosition(), rot = command.getRotation()}
            else
                t.command = t.command or {}
                if not command.hasTag('standing') then table.insert(t.command, force ~= 'air' and 1 or #t.command + 1, command) end
                for i, unit in ipairs(command:detach()) do
                    t[unit.name] = t[unit.name] or {}
                    if unit.name == 'carrier' or unit.name == 'battleship' then battle[side].special = true end
                    table.insert(t[unit.name], unit)
                    if i == 1 then command.origin = {pos = unit.getPosition(), rot = unit.getRotation()} end
    end end end end end end
    debug('Moving units to battle board')
    for side, params in pairs(battle) do for nation, types in pairs(params.nations) do for name, units in pairs(types) do
        local step, point = 0.21
        if name ~= 'command' then
            point = self.stances[mode][side][name][Units[name].stance(mode, params.antiair, params.special)].snaps[nation]
        else step, point = 0.23, self.commands.snaps[nation] end
        table.insert(ps, Units.stack(units, self.positionToWorld(point.position), self.getRotation() + point.rotation, step))
    end end end
    Promise.all(ps):next(function (...)
        debug('All units have been moved')
        self.guids = {}
        for _, units in ipairs{...} do for _, unit in ipairs(units) do self.guids[unit.guid] = unit end end
        self.combat.resume()
    end)
    coroutine.yield()
    for side, _ in pairs(Nations.other) do self.UI.setAttributes(side .. '-confirm', {
        text = 'Ready', textColor = 'white', interactable = true
    }) end
    if mode == 'land' then
        local invaders = {}
        for nation, _ in pairs(battle[Nations[region:owner()].other].nations) do
            table.insert(invaders, nation)
        end
        return invaders
    elseif sides.axis.army or sides.allies.army then
        return {axis = sides.axis.army, allies = sides.allies.army}
    end
end

function Battle:updateDice(zone, sign)
    local side, unit, stance
    for _, tag in ipairs(zone.getTags()) do
        if Nations.other[tag] then side = tag
        elseif Units[tag] then unit = tag
        elseif tag ~= 'left' and tag ~= 'right' then stance = tag
    end end
    if side and unit and stance then
        zone = self.stances[self:mode()][side][unit][stance]
        for stage, value in pairs(zone.dice) do if self.dice[stage] then
            self.dice[stage][side] = self.dice[stage][side] + value * sign
        end end
        self:updateDiceTotal(side)
    end
end

function Battle:updateDiceTotal(side)
    for stage, sides in pairs(self.dice) do
        local value, id = sides[side], side .. '-' .. stage
        if stage == 'surface' and rawget(self, 'advantage') and self.advantage[side].port then value = value + 2 end
        if value > 0 then
            self.UI.show(id)
            self.UI.setValue(id .. '-dice', math.min(value, 30))
        else self.UI.hide(id) end
    end
end

function Battle:setAdvantages()
    debug('Checking force and port advantage')
    local adv, sides = {axis = {}, allies = {}}, {axis = -1, allies = 1}
    local naval, balance = self:mode() == 'sea', 0
    for side, units in pairs(self.stances[self:mode()]) do
        sides[side] = {types = {}, value = sides[side]}
        for unit, stances in pairs(units) do if Units[unit].force ~= 'air' then
            for _, stance in pairs(stances) do if #stance:getUnits() > 0 then
                sides[side].types[unit] = true
                if Units[unit].force == 'fleet' then sides[side].fleet = true end
    end end end end end
    if naval then for _, link in ipairs(Map.regions[self.combat.hotspot.region].adjacent) do if link:match('$$') then
        local owner, side = Map.regions[link:sub(1, -2)]:owner()
        if owner ~= 'neutral' then
            side = Nations[owner].side
            if side and Morale.stressZone(owner) < 3 then sides[side].port = true end
        elseif Map.regions[link:sub(1, -2)].allied then sides.allies.port = true end
    end end end
    for side, data in pairs(sides) do
        for _, _ in pairs(data.types) do balance = balance + data.value end
        if data.port and data.fleet then
            adv[side].port = true
            self:updateDiceTotal(side)
    end end
    if balance < 0 then adv.axis.force = true
    elseif balance > 0 then adv.allies.force = true end
    self.advantage = {axis = {}, allies = {}}
    for side, advantages in pairs(adv) do for advantage, _ in pairs(advantages) do
        debug('Setting ', advantage, ' advantage for ', side)
        local sign = (side == 'axis' and -1 or 1)-- * (naval and -1 or 1)
        self.advantage[side][advantage] = Bags.arrow.takeObject({
            position = self.commands.positionToWorld(vector(0.05 * sign, 0, naval and (advantage == 'force' and 0.5 or -0.5) or 0)),
            rotation = self.getRotation() + vector(0, 90 * sign, side == 'axis' ~= naval and 180 or 0), smooth = false
        })
    end end
end

function Battle:lockStances(side)
    debug('Locking ', side, ' stances')
    for unit_type, stances in pairs(self.stances[self:mode()][side]) do
        for label, stance in pairs(stances) do if #stance:getUnits() > 0 then
            debug('Found ', #stance.units, ' ', unit_type, ' in ', label, ' stance')
            local stacks = {}
            stance.stacks = {}
            for _, obj in ipairs(stance.units) do
                local unit = self.guids[obj.guid]
                stacks[unit.nation] = stacks[unit.nation] or {}
                table.insert(stacks[unit.nation], unit)
            end
            for nation, units in pairs(stacks) do
                debug('Locking ', nation, ' stack with ', #units, ' units')
                table.sort(units, function (a, b)
                    local cfighter = a.name == 'cfighter'
                    if cfighter ~= (b.name == 'cfighter') then return cfighter
                    else return a.getPosition().y < b.getPosition().y end
                end)
                for i = 1, #units do units[i].next = units[i - 1] end
                stance.stacks[nation] = units[#units]
                local pos, rot = self.positionToWorld(stance.snaps[nation].position), stance.snaps[nation].rotation + self.getRotation()
                Units.stack(units, pos, rot):skip(3):next(function (units) for _, unit in ipairs(units) do unit.setLock(true) end end)
    end end end end
end

function Battle:countUnits(params)
    local total = 0
    for side, units in pairs(self.stances[self:mode()]) do if not params.side or side == params.side then
        for unit, stances in pairs(units) do
            local countable = true
            if params.force and Units[unit].force ~= params.force then countable = false end
            if params.color and Units[unit].color ~= params.color then countable = false end
            if params.unit and unit ~= params.unit then countable = false end
            if countable then for _, stance in pairs(stances) do total = total + #stance:getUnits() end end
    end end end
    return total
end

----#include battle/setup
----#include battle/stage
function Battle:stage(stage, turn)
    self.UI.setValue('status', stage:proper() .. ' stage')
    self.UI.hide('allies-confirm-panel')
    self.UI.hide('allies-' .. stage)
    self.UI.hide('axis-confirm-panel')
    self.UI.hide('axis-' .. stage)
    local targets = {}
    local counters, force = self:setupStage(stage)
    while #counters.axis + #counters.allies > 0 do
        if #counters[turn] > 0 then
            if not targets[turn] then targets[turn] = self:getTargets(Nations.other[turn], force) end
            local counter, remaining = table.remove(counters[turn]), 0
            debug(turn:proper(), ' rolling ', counter.value, ' dice')
            if stage == 'bomb' then
                if self.UI.getAttribute('targets', 'active') == 'false' then self.UI.show('targets') end
                for color, targets in pairs(targets[turn]) do for _, count in pairs(targets) do
                    remaining = remaining + count
                end end
            else remaining = self:countUnits({side = Nations.other[turn], force = force}) end
            fadeOut(counter.obj, 2)
            if remaining > 0 then
                debug(remaining, ' targets remaining, rolling round')
                local id = table.concat({turn, 'confirm', 'panel'}, '-')
                self.UI.show(id)
                self.UI.setAttributes(id:sub(1, -7), {text = 'Rolling', textColor = 'white', interactable = false})
                self.bags[turn]:toss(counter.value, 10, vector(turn == 'axis' and 5 or -5, 7, 0), 0.1):next(function (roll)
                    local left = self.bags.axis.getPosition() + vector(0, 0.6, 0)
                    local right = self.bags.allies.getPosition() + vector(0, 0.6, 0)
                    return roll:arrange(left:lerp(right, 0.53 - #roll * 0.03), right:lerp(left, 0.53 - #roll * 0.03))
                end):next(|roll| self.combat.resume(roll))
                if stage ~= 'bomb' then
                    self:assignHits(stage, turn, coroutine.yield(), targets[turn], self.advantage[Nations.other[turn]].force)
                else self.combat:assignBombs(coroutine.yield(), targets[turn], self.UI) end
                self.UI.hide(id)
        end end
        turn = Nations.other[turn]
    end
    for side in pairs(Nations.other) do
        self.UI.hide(side .. '-confirm-panel')
        if stage == 'bomb' then self.UI.hide(side .. '-targets') end
    end
    if stage == 'bomb' then self.UI.hide('targets') end
end

function Battle:setupStage(stage)
    debug('Setting up ', stage, ' stage')
    local force = stage
    if force == 'ground' then force = 'army' elseif force == 'surface' then force = 'fleet' end
    local mode, counters = self:mode(), {}
    self.UI.setValue(mode .. '-status', stage:gsub('^%l', string.upper) .. ' stage')
    for side, dice in pairs(self.dice[stage]) do
        self.UI.hide(table.concat({mode, side, stage}, '-'))
        if stage == 'surface' and self.advantage[side].port then dice = dice + 2 end
        if dice > 0 and (stage == 'bomb' or self:countUnits({side = Nations.other[side], force = force}) > 0) then
            counters[side] = self:setHotspotCounters(side, math.min(dice, 30), stage == 'bomb')
        else counters[side] = Promise():resolve() end
    end
    self.dice[stage] = nil
    debug('Waiting for counters to spawn')
    counters.axis:next(function (...)
        counters.axis = {...}
        return counters.allies
    end):next(function (...)
        counters.allies = {...}
        self.combat.resume(counters)
    end)
    return coroutine.yield(), force
end

function Battle:setHotspotCounters(side, dice, bomb)
    debug('Setting up ', side, ' hotspot counters for ', dice, ' dice')
    local naval, counters = self:mode() == 'sea', {}
    local y_sign = naval and -1 or 1
    local y_inc, x_sign = 0.71 * y_sign, (side == 'axis' and 1 or -1) * y_sign
    local x, y, z_min = 1.5 * x_sign, 0.1 * (1 + y_sign) + y_inc / 2
    local z_min = self.positionToLocal(self.stances.land[side].bomber.strategic.getPosition()).z
    local start = self.commands.snaps[side == 'axis' and 'italy' or 'uk'].position + vector(0.5 * x_sign, 0.1, 0)
    while dice > 0 do if bomb then
        table.insert(counters, self:setHotspotCounter(start, vector(x, y, 6 * 0.173 + z_min), 4))
        dice, y = dice - 4, y + y_inc
    else
        local value = (dice - 1) % 10 + 1
        table.insert(counters, self:setHotspotCounter(start, vector(x, y, (30 - dice) % 10 * 0.173 + z_min), value))
        if dice % 10 == 0 then dice, y = dice - 10, y + y_inc else dice = dice - dice % 10 end
    end end
    return Promise.all(counters)
end

function Battle:setHotspotCounter(start, position, value)
    local p = Promise()
    Bags.hotspot.takeObject({
        position = self.positionToWorld(start), smooth = false,
        callback_function = function (obj)
            obj.setPositionSmooth(self.positionToWorld(position), false, true)
            Wait.condition(|| p:resolve({value = value, obj = obj}), || not obj.isSmoothMoving())
    end})
    return p
end

function Battle:getTargets(side, force)
    local targets, fun = {}, 'Global/Battle(' .. self.hand
    if force ~= 'bomb' then for unit, stances in pairs(self.stances[self:mode()][side]) do if Units[unit].force == force then
        local die_color, clr = Units[unit].color, Color[unit]
        for label, stance in pairs(stances) do if rawget(stance, 'stacks') ~= nil then
            targets[die_color] = targets[die_color] or {hp = 0}
            targets[die_color][label] = stance
            targets[die_color].hp = targets[die_color].hp + stance.hp * #stance.units
            local repair_fun = table.concat({fun, side, unit, label}, '-') .. ')'
            for stack, obj in pairs(stance.stacks) do
                local pos, rot = '0 0 ' .. (obj.is_face_down and 2 or -29)
                local rot = '0 ' .. math.round(obj.getRotation().z) .. ' ' .. math.round(obj.getRotation().y)
                local scale = obj.getName() == 'cfighter' and '2 2' or '1 1'
                obj.UI.setCustomAssets(self.RepairAssets)
                obj.UI.setXmlTable({{tag = 'Button', attributes = {id = 'hit',
                    position = pos, rotation = rot, scale = scale, height = 48, width = 72, active = false,
                    colors = table.concat({clr:lerp(Color.white, 0.3):toXml(), 'white', clr:toXml(), 'clear'}, '|'),
                    fontSize = 36, text = 'Hit', onClick = table.concat({fun, die_color, label, stack}, '-') .. ')'
                }}, {tag = 'Panel', attributes = {id = 'repair',
                    position = pos, rotation = rot, scale = scale, height = 112, width = 188, active = false
                }, children = {
                    {tag = 'Image', attributes = {image = obj.nation, height = 40, width = 40}},
                    {tag = 'Button', attributes = {id = 'casualty',
                        height = 50, width = 50, rectAlignment = 'Middle' .. (side == 'axis' and 'Left' or 'Right'),
                        text = 'X', fontSize = 36, textColor = 'white', colors = 'black|#606060|#c00000|clear',
                        onClick = repair_fun
                    }},
                    self.XML:repairs(side == 'axis' and 'Right' or 'Left', repair_fun)
                }}})
    end end end end end else
        debug('Determining bomb targets')
        self.UI.show(side .. '-targets')
        targets = Map.regions[self.combat.hotspot.region]:bombTargets()
        local x, delta = side == 'axis' and 500 or 824, side == 'axis' and -70 or 70
        for _, t in ipairs(Combat.BombOrder) do if targets[t.color] and targets[t.color][t.target] then
            self:updateTarget(t.color, t.target, {
                offsetXY = x .. ' 0', text = targets[t.color][t.target],
                image = t.target, active = true, interactable = false
            })
            x = x + delta
        else self.UI.setAttribute(t.color .. '-' .. t.target, 'active', false) end end
    end
    return targets
end

----#include battle/stage
----#include battle/hits
function Battle:assignHits(stage, side, roll, targets, fd)
    debug('=== Assigning ', side, ' ', stage, ' dice ===')
    debug(tostring(roll))
    fd = fd and stage ~= 'air'
    local sets, t = {}
    for _, die in ipairs(roll) do
        local value = die:getColor()
        if not t or value ~= t.color then
            t = {die, color = value, active = (value == 'black' or value == 'white') and not fd or targets[value]}
            table.insert(sets, t)
        else table.insert(t, die) end
        if not t.active then die.setColorTint(color(1, 1, 1, 0.4)) end
    end
    local pending, hit_unit, pos = {}
    for _, set in ipairs(sets) do if set.active then
        debug('Assigning ', #set, ' ', set.color, ' hits')
        local wild, white = set.color == 'black', set.color == 'white'
        local eligible, hp, autohit, escorts, cap_ships = 0, 0, false, false, false
        if targets.blue and targets.blue.escort then for stack, _ in pairs(targets.blue.escort.stacks) do
            if stack ~= 'casualty' then escorts = true break end
        end end
        for clr, stances in pairs(targets) do if white or wild or set.color == clr then
            hp = hp + stances.hp
            for label, stance in pairs(stances) do if label ~= 'hp' then
                if stance.stacks.damaged or stance.stacks.sustained or stance.stacks.damaged2 then
                    if not white or (not stance.stacks.sustained and label ~= 'dive') then eligible = eligible + 1 end
                    cap_ships = cap_ships or escorts and (clr == 'red' or clr == 'green')
                elseif not white then for stack, _ in pairs(stance.stacks) do if stack ~= 'casualty' and stack ~= 'escaped' then
                    eligible = eligible + 1 debug('Adding eligible ', stance.unit)
                    cap_ships = cap_ships or escorts and (clr == 'red' or clr == 'green')
        end end end end end end end
        if white then autohit = #set >= eligible else autohit = hp > 0 and #set >= hp end
        autohit = autohit and not cap_ships
        for _, die in ipairs(set) do if eligible > 0 then
            debug('Assigning ', set.color, ' hit, ', eligible, ' targets remaining', autohit and ' (autohit active)' or '')
            local buttons, hit = {}
            for clr, stances in pairs(targets) do if white and not bombing or wild or clr == set.color then
                for label, stance in pairs(stances) do
                    if label ~= 'hp' then
                        local priority = nil
                        for stack, _ in pairs(stance.stacks) do if stack:match('[^p]ed2?$') then priority = stack break end end
                        if priority and (not white or label ~= 'dive' and priority ~= 'sustained') then
                            if not autohit and eligible > 1 then table.insert(buttons, stance.stacks[priority]) debug('Eligible target: ', priority, ' ', stance.unit, ' in ', label, ' stance')
                            else hit = {color = clr, stance = label, stack = priority, unit = stance.stacks[priority]} break end
                        elseif not white then
                            if autohit or eligible == 1 then
                                hit = {color = clr, stance = label}
                                repeat hit.stack, hit.unit = next(stance.stacks, hit.stack) until hit.stack ~= 'casualty'
                            else for stack, unit in pairs(stance.stacks) do
                                if stack ~= 'casualty' then table.insert(buttons, unit) debug('Eligible target: ', stack, ' ', stance.unit, ' in ', label, ' stance') end
                    end end end end
                    if hit and hit.stack then
                        self.UI.setAttributes(side .. '-confirm', {text = 'Assigning hits', textColor = 'white'})
                        break
                end end
                if hit then break end
            end end
            if hit_unit and (not hit or hit_unit.guid ~= hit.unit.guid) then
                self:moveHitUnit(hit_unit, pos, pending)
                hit_unit = nil
            end
            hit = hit or self:getHitAssignment(die, buttons, side, bombing)
            local stance = targets[hit.color][hit.stance]
            local unit, casualty = hit.unit or stance.stacks[hit.stack]
            debug('Hit', hit.unit and ' auto-' or ' ', 'assigned to ', hit.stack, ' ', stance.unit, ' in ', hit.stance, ' stance')
            if targets.blue and targets.blue.escort and (stance.unit == 'carrier' or stance.unit == 'battleship') then
                local escorts = {}
                for stack, unit in pairs(targets.blue.escort.stacks) do if stack == 'damaged' then
                    escorts = {unit} break
                elseif stack ~= 'casualty' then table.insert(escorts, unit) end end
                if #escorts > 0 then
                    if hit_unit then
                        self:moveHitUnit(hit_unit, pos, pending)
                        hit_unit = nil
                    end
                    hit = self:getEscortAssignment(die, unit, escorts, side)
                    stance = targets[hit.color][hit.stance]
                    unit = stance.stacks[hit.stack]
                    debug('Hit assigned to ', hit.stack, ' ', stance.unit, ' in ', hit.stance, ' stance')
            end end
            if unit.UI.getAttribute('hit', 'active') == 'true' then
                Wait.condition(|| self.combat.resume(), || unit.UI.getAttribute('hit', 'active') == 'false')
                coroutine.yield()
            end
            local escorted = hit.stance == 'escort' and (set.color == 'red' or set.color == 'green')
            table.insert(pending, die)
            if targets[hit.color].hp == 1 then targets[hit.color] = nil
            else targets[hit.color].hp = targets[hit.color].hp - 1 end
            stance.stacks[hit.stack], unit.next = rawget(unit, 'next'), nil
            if stance.stacks[hit.stack] then
                local xml, next_unit = unit.UI.getXmlTable(), stance.stacks[hit.stack]
                if next_unit.getName() ~= unit.getName() then
                    xml[1].attributes.colors = table.concat({Color.cfighter:lerp(Color.white, 0.3):toXml(), 'white', Color.cfighter:toXml(), 'clear'}, '|')
                    for _, tag in ipairs(xml) do
                        tag.attributes.scale = '2 2'
                        tag.attributes.position = '0 0 ' .. (next_unit.is_face_down and 2 or -29)
                        tag.attributes.rotation = '0 ' .. math.round(next_unit.getRotation().z) .. ' ' .. math.round(next_unit.getRotation().y)
                end end
                next_unit.UI.setXmlTable(xml)
            end
            if hit.stack:match('damaged') then casualty, eligible = true, eligible - (escorted and 0 or 1)
            elseif hit.stack == 'sustained' then
                unit.UI.setAttribute('hit', 'onClick', unit.UI.getAttribute('hit', 'onClick'):gsub('%a+%)', 'damaged2)'))
                stance.stacks.damaged2, pos = unit, stance.snaps.damaged2.position
            elseif stance.hp > 1 then
                local next_stack = stance.hp > 2 and 'sustained' or 'damaged'
                unit.UI.setAttribute('hit', 'onClick', unit.UI.getAttribute('hit', 'onClick'):gsub('%a+%)', next_stack .. ')'))
                stance.stacks[next_stack], pos = unit, stance.snaps[next_stack].position
                if not escorted then for stack, _ in pairs(stance.stacks) do
                    if stack ~= hit.stack and Nations[stack] then eligible = eligible - 1 end
                end end
            else casualty, eligible = true, eligible - 1 end
            if casualty then
                debug('Unit is eliminated')
                if not white and not escorted then for stack, _ in pairs(stance.stacks) do
                    if Nations[stack] then eligible = eligible + 1 end
                end end
                unit:clearUI()
                unit.addTag('casualty')
                unit.next, stance.stacks.casualty = stance.stacks.casualty, unit
                if rawget(unit, 'next') == nil then pos = stance.snaps.casualty.position
                else pos = self.positionToLocal(unit.next.getPosition() + vector(0, unit.next.is_face_down and 0 or 0.21, 0)) end
                self:moveHitUnit(unit, pos, pending)
                hit_unit = nil
            else hit_unit = unit end
        else die.destruct() end end
    else for _, die in ipairs(set) do die.destruct() end end end
    if hit_unit then self:moveHitUnit(hit_unit, pos, pending) end
    if stage == 'surface' and targets.yellow then
        local stance = targets.yellow.dive
        local sub = stance.stacks.damaged
        if sub then
            debug('Submarine diving to escape')
            if targets.yellow.hp == 1 then targets.yellow = nil
            else targets.yellow.hp = targets.yellow.hp - 1 end
            sub.next, stance.stacks.escaped, stance.stacks.damaged = stance.stacks.escaped, sub, nil
            pos = stance.snaps.escaped.position
            if rawget(sub, 'next') then pos = self.positionToLocal(sub.next.getPosition() + vector(0, 0.21, 0)) end
            sub.addTag('escaped')
            sub:clearUI()
            sub.setRotationSmooth(stance.snaps.escaped.rotation + self.getRotation())
            self:moveHitUnit(sub, pos, {})
    end end
end

function Battle:getHitAssignment(die, buttons, side)
    debug('Showing hit buttons')
    local player, hit
    for _, unit in ipairs(buttons) do
        setGlow(unit)
        unit.UI.show('hit')
    end
    setGlow(die)
    self.UI.setAttributes(side .. '-confirm', {text = 'Assign hit', textColor = 'white'})
    repeat player, hit = coroutine.yield() debug(player.color, ' clicked ', tostring(hit)) until Vis[side]:match(player.color)
    for _, unit in ipairs(buttons) do
        stopGlow(unit)
        unit.UI.hide('hit')
    end
    stopGlow(die)
    return hit
end

function Battle:getEscortAssignment(die, unit, escorts, side)
    local other = Nations.other[side]
    local unit_color, escort_color = unit.UI.getAttribute('hit', 'colors'), escorts[1].UI.getAttribute('hit', 'colors')
    for _, escort in ipairs(escorts) do escort.UI.setAttribute('hit', 'colors', unit_color) end
    unit.highlightOn(Color.white)
    self.UI.hide(side .. '-confirm-panel')
    self.UI.show(other .. '-confirm-panel')
    local hit = self:getHitAssignment(die, {unit, table.unpack(escorts)}, other)
    for _, escort in ipairs(escorts) do escort.UI.setAttribute('hit', 'colors', escort_color) end
    unit.highlightOff()
    self.UI.show(side .. '-confirm-panel')
    self.UI.hide(other .. '-confirm-panel')
    return hit
end

function Battle:moveHitUnit(unit, pos, dice)
    while #dice > 0 do fadeOut(table.remove(dice)) end
    unit.setLock(false)
    unit.setPositionSmooth(self.positionToWorld(pos) + vector(0, unit.is_face_down and 0.21 or 0, 0))
    Wait.condition(function ()
        Wait.frames(|| unit.setLock(true), 5)
        self.combat.resume()
    end, || not unit.isSmoothMoving())
    coroutine.yield()
end

----#include battle/hits
----#include battle/cleanup
function Battle:repairs()
    debug('Setting up unit repairs')
    local moves, repairs = {}, {}
    for side, units in pairs(self.stances[self:mode()]) do
        local count = 0
        for unit, stances in pairs(units) do for label, stance in pairs(stances) do if rawget(stance, 'stacks') then
            for stack, target in pairs(stance.stacks) do if stack:match('[ng]ed2?$') then
                if stack == 'sustained' or target.force == 'fleet' and self.advantage[side].port then
                    debug('Repairing ', target.nation, ' ', unit, ' automatically')
                    table.insert(moves, self:repairUnit(stance, stack))
                else
                    debug('Showing repair buttons for ', target.nation, ' ', unit)
                    count = count + 1
                    local p = Promise()
                    repairs[table.concat({side, unit, label}, '-')] = {unit = target, promise = p}
                    table.insert(moves, p:finally(function (casualty)
                        if count == 1 then self.UI.hide(side .. '-confirm-panel')
                        else count = count - 1 end
                        stopPulse(target)
                        return self:repairUnit(stance, stack, casualty)
                    end))
                    setPulse(target)
                    if target.nation == 'china' then target.UI.hide('oil') end
                    target.UI.show('repair')
                    for resource, value in pairs(Orders[target.nation].resources.current) do
                        if value == 0 then target.UI.setAttribute(resource, 'interactable', false) end
        end end end end end end end
        if count > 0 then
            self.UI.setAttributes(side .. '-confirm', {text = 'Repair units', textColor = 'white'})
            self.UI.show(side .. '-confirm-panel')
    end end
    while next(repairs) do
        local player, resource, key = coroutine.yield()
        if repairs[key] then if resource == 'casualty' then
            repairs[key].promise:reject()
            repairs[key] = nil
        else
            local nation = repairs[key].unit.nation
            local supply = Orders[nation].resources.current[resource]
            if supply < 2 then for _, t in pairs(repairs) do if t.unit.nation == nation then
                t.unit.UI.setAttribute(resource, 'interactable', false)
            end end end
            if supply > 0 then
                Resources[repairs[key].unit.nation]:add({[resource] = -1})
                repairs[key].promise:resolve()
                repairs[key] = nil
    end end end end
    Promise.all(moves):next(|| self.combat.resume())
    coroutine.yield()
end

function Battle:repairUnit(stance, stack, casualty)
    local unit, pos = stance.stacks[stack]
    local target, offset = casualty and 'casualty' or unit.nation, unit.is_face_down and 0.21 or 0
    unit:clearUI()
    if stance.stacks[target] then
        unit.next = stance.stacks[target]
        offset = offset + (unit.next.is_face_down and 0 or 0.21)
        pos = unit.next.getPosition()
    else pos = self.positionToWorld(stance.snaps[target].position) end
    stance.stacks[target] = unit
    unit.setLock(false)
    unit.setPositionSmooth(pos + vector(0, offset, 0))
    return unit:notMoving():skip(5):next(function ()
        stance.stacks[stack] = nil
        unit.setLock(true)
    end)
end

function Battle:losses()
    local ps = {}
    for side, zone in pairs(self.casualties) do
        local units = zone.getObjects()
        for i = #units, 1, -1 do
            local unit = self.guids[units[i].guid]
            if unit.getName() == 'cfighter' then unit.obj.memo = nil end
            if not unit or unit.hasTag('escaped') then table.remove(units, i)
            elseif unit.hasTag('free') then stash(table.remove(units, i))
            else
                units[i] = unit
                unit.setLock(false)
        end end
        if #units > 0 then table.insert(ps, Morale:casualties(units)) end
    end
    return #ps > 0 and Promise.all(ps) or Promise():resolve()
end

function Battle:replaceCommands()
    local ps, commands, extras = {}, {}
    for _, obj in ipairs(self.commands.getObjects()) do
        table.insert(commands, {command = self.guids[obj.guid], units = {}})
        self.guids[obj.guid] = #commands
    end
    for _, unit_types in pairs(self.stances[self:mode()]) do for _, stances in pairs(unit_types) do for label, stance in pairs(stances) do
        local units = stance:getUnits()
        if label == 'dive' and rawget(stance, 'stacks') then while stance.stacks.escaped ~= nil do
            table.insert(units, stance.stacks.escaped)
            stance.stacks.escaped = rawget(stance.stacks.escaped, 'next')
        end end
        for _, obj in ipairs(units) do
            local unit = self.guids[obj.guid]
            unit:clearUI()
            if unit then if unit.getName() == 'cfighter' then
                unit.setPositionSmooth(unit.origin.pos)
                unit.setRotationSmooth(unit.origin.rot)
                unit.origin = nil
                table.insert(ps, unit:notMoving():skip(5):next(|| unit.setLock(false)))
                table.insert(commands, {cfighter = unit})
            elseif unit.hasTag('standing') then
                extras = extras or {}
                table.insert(extras, unit)
                unit.removeTag('free')
                setGlow(unit, Color[unit.nation])
                unit.setLock(false)
                unit.setPositionSmooth(unit.stack.origin.pos + vector(0, #extras * 0.21, 0))
                unit.setRotationSmooth(unit.stack.origin.rot)
            else table.insert(commands[self.guids[unit.stack.guid]].units, unit) end end
    end end end end
    for i = #commands, 1, -1 do if commands[i].command then
        local stack, units = commands[i].command, Units:sort(commands[i].units)
        if stack.force == 'fleet' then for j = #units, 1, -1 do if units[j].hasTag('escaped') then
            setGlow(units[j], Color._blue)
            units[j].setLock(false)
            units[j].setPositionSmooth(stack.origin.pos + vector(0, #units * 0.21 + 0.3, 0))
            units[j].setRotationSmooth(stack.origin.rot)
            extras = extras or {}
            table.insert(extras, table.remove(units, j))
        end end end
        if #units > 0 then
            table.insert(units, stack)
            table.insert(ps, Units.stack(units, stack.origin.pos, stack.origin.rot)
                :next(|| table.remove(units):attach(units)))
            commands[i], stack.origin = stack, nil
        else table.insert(ps, table.remove(commands, i).command:stash()) end
    else commands[i] = commands[i].cfighter end end
    return Promise.all(ps):next(|| {forces = Commands.Forces(commands), extras = extras})
end

function Battle:reset()
    self.UI.hide('status-panel')
    for side, t in pairs(self.advantage) do
        self.UI.show(side .. '-roller')
        for _, arrow in pairs(t) do stash(arrow) end
        for unit, stances in pairs(self.stances[self:mode()][side]) do for _, stance in pairs(stances) do
            stance.stacks, stance.units = nil
    end end end
    self.advantage, self.dice, self.combat = nil
end

----#include battle/cleanup

----#include components/battle
----#include components/morale
Morale = {Zones = {
    {name = 'White', label = 'Acceptable Stress', color = 'fbfcfc'},
    {name = 'Blue', label = 'Labor and Civil Unrest', color = 'aed6f1'},
    {name = 'Yellow', label = 'Dysfunctional Infrastructure', color = 'f7dc6f'},
    {name = 'Orange', label = 'Supply Lines Disrupted', color = 'e59866'},
    {name = 'Red', label = 'Economic Collapse', color = 'f1948a'},
    {name = 'Grey', label = 'Mass Desertions', color = 'abb2b9'}
}}

function Morale:initialize(board, scenario)
    setmetatable(getmetatable(self).__index, {__index = board})
    self.stacks, self.stress, self.medals, self.snaps = {}, {}, {}, {}
    local origin, flip = self.getPosition(), scenario ~= 'global' and scenario ~= 'eastern' and not self.is_face_down
    local snaps, nations, nation, unit = self.getSnapPoints(), Nations:moraleOrder()
    for i, snap in ipairs(snaps) do
        if (i - 1) % 11 == 0 then
            nation = table.remove(nations)
            self.snaps[nation], unit = {}, 'medal_goods'
        elseif unit ~= 'medal_goods' then
            unit = next(Units, unit ~= 'stress' and unit:gsub('fighter', 'c%0') or nil)
        else unit = 'stress' end
        if flip then snap.position, snap.rotation.z = snap.position:rotateOver('z', 180) + vector(0, 0.2, 0), (snap.rotation.z + 180) % 360 end
        self.snaps[nation][unit] = snap.position
    end
    if flip then
        self.setLock(false)
        self.flip()
        self.setSnapPoints(snaps)
        Wait.condition(|| self.setLock(true), || self.resting)
    end
    self:loadUI(scenario)
    log('Morale board initialized')
end

----#include ../ui/morale
function Morale:loadUI(scenario)
    local sign = scenario ~= 'global' and scenario ~= 'eastern' and -1 or 1
    local assets, children = {}, {}
    for _, asset in ipairs(UI.getCustomAssets()) do if asset.name:match('stress') then table.insert(assets, asset) end end
    local pos = |x, y| table.concat({x * sign, y, -10.1 * sign - 10}, ' ')
    local rot = '180 ' .. 90 * (1 + sign) .. ' 0'
    for _, nation in ipairs(Nations:moraleOrder()) do
        local active = Scenarios[state.scenario].nations[nation] ~= nil
        table.insert(children, {tag = 'Panel', attributes = {padding = '9 9 10 10'}, children = {
            {tag = 'VerticalLayout', attributes = {id = nation .. '-casualties'}, children = {
                {tag = 'Image', attributes = active and {id = nation .. '-level'} or {color = 'clear'}},
                {tag = 'Text', value = active and 0 or ' ', attributes = {id = nation .. '-count',
                    verticalOverflow = 'Overflow', outline = '#600000', color = '#d06040', fontSize = 36
            }}}},
            {tag = 'Text', value = active and '/' or ' ', attributes = {id = nation .. '-stress',
                ignoreLayout = true, alignment = 'MiddleRight', offsetXY = '10 -3', horizontalOverflow = 'Overflow',
                color = '#ffe0d0', fontSize = 60, fontStyle = 'Bold', outline = 'black'
    }}}}) end
    self.UI.setCustomAssets(assets)
    self.UI.setXmlTable({
        {tag = 'Defaults', children = {
            {tag = 'Image', attributes = {image = 'stress-level0', color = '#ffffffc0'}},
            {tag = 'Text', attributes = {shadow = '#00000080', shadowDistance = '-2 -2'}},
            {tag = 'Button', attributes = {rotation = rot, scale = '0.2 0.2', color = '#ffffff33', onClick = 'click', active = false}}
        }},
        {tag = 'Button', attributes = {id = 'convert',
            height = 118, width = 178, position = pos(11.4, -86.3), colors = 'white|red|black|clear'
        }},
        {tag = 'Button', attributes = {id = 'spend',
            height = 96, width = 115, position = pos(140.5, -65), colors = 'white|green|black|clear'
        }},
        {tag = 'VerticalLayout', attributes = {id = 'casualties',
            height = 770, width = 80, scale = '0.2 0.2', position = pos(120, 20.5), rotation = rot, active = false
        }, children = children}
    })
end

function Morale:medalButtons(nation, obj, n)
    n = n or 1
    local xml = {}
    for id, attr in pairs{
        medal = {z = -10.6, rot = '0 180', clr = Color.medal},
        cg = {z = 10.6, rot = '180 180', clr = Color._green}
    } do table.insert(xml, {tag = 'VerticalLayout', attributes = {id = id,
        position = '0 0 ' .. attr.z, rotation = '0 ' .. attr.rot, height = 100, width = 120
    }, children = {
        {tag = 'Button', attributes = {id = nation,
            colors = table.concat({attr.clr:toXml(), attr.clr:lerp(Color.white, 0.3):toXml(), 'white', 'clear'}, '|'),
            text = 'Spend ' .. n, fontSize = 28, fontStyle = 'Bold', onClick = 'Global/Morale'}},
        {tag = 'Button', attributes = {id = 'done',
            text = 'Done', fontSize = 28, colors = '#ffffff80|white|white|clear',
            onClick = 'Global/Morale(' .. nation .. ')'}}
    }}) end
    obj.UI.setXmlTable(xml)
end

----#include ../ui/morale

function Morale:casualties(units)
    debug('Stacking casualties on the morale board')
    if not rawget(units, 1) then units = {units} end
    local ps, casualties = {}, {}
    while #units > 0 do
        local unit = table.remove(units)
        local name = unit.getName():gsub('cfighter', 'fighter')
        casualties[unit.nation] = casualties[unit.nation] or {}
        casualties[unit.nation][name] = casualties[unit.nation][name] or {}
        table.insert(casualties[unit.nation][name], unit)
        self.stacks[unit.nation] = self.stacks[unit.nation] or {}
    end
    for nation, names in pairs(casualties) do for name, units in pairs(names) do
        debug('Stacking ', #units, ' ', nation, ' ', name, ' casualties')
        self.stacks[nation][name] = self:stackUnits(nation, name, units)
        table.insert(ps, self.stacks[nation][name])
    end end
    return Promise.all(ps)
end

function Morale:sunkConvoys(nation, value)
    debug('Stacking ', value, ' convoy tokens on the morale board')
    local units = {}
    for _ = 1, value do table.insert(units, 'convoy_dive') end
    self.stacks[nation] = self.stacks[nation] or {}
    self.stacks[nation].submarine = self:stackUnits(nation, 'submarine', units)
    return self.stacks[nation].submarine
end

function Morale:stackUnits(nation, name, units)
    local p = self.stacks[nation][name]
    if not p then
        local stack = self:getStack(nation, name)
        p = Promise():resolve(#stack > 0
            and table.remove(stack).getPosition() + vector(0, 0.21, 0)
            or self.positionToWorld(self.snaps[nation][name]))
    end
    return p:next(function (pos)
        local q = Promise()
        for i, unit in ipairs(units) do Wait.frames(function ()
            if type(unit) ~= 'string' then
                unit.setPositionSmooth(pos + vector(0, unit.is_face_down and 0.21 or 0, 0))
                unit.setRotationSmooth(unit.getRotation():setAt('x', 0):setAt('y', self.getRotation().y))
                if i == #units then Wait.condition(|| q:resolve(pos), || not unit.isSmoothMoving()) end
            else Bags[unit].takeObject({
                position = pos, rotation = vector(0, self.getRotation().y, 0),
                callback_function = i == #units and (|| q:resolve(pos)) or nil
            }) end
            pos = pos + vector(0, 0.21, 0)
        end, i * 5 - 4) end
        return q
    end)
end

function Morale:getStack(nation, name)
    local objs = {}
    for _, obj in ipairs(Physics.cast({
        origin = self.positionToWorld(self.snaps[nation][name]) - vector(0, 0.1, 0), direction = {0, 1, 0}, max_distance = 5
    })) do if not obj.hit_object.isSmoothMoving() and (obj.hit_object.getName():match(name)
            or name == 'submarine' and obj.hit_object.getName() == 'convoy_dive') then
        table.insert(objs, obj.hit_object)
    end end
    table.sort(objs, function (a, b)
        return a.getPosition().y + a.getBounds().size.y * (a.is_face_down and -0.5 or 0.5)
            < b.getPosition().y + b.getBounds().size.y * (b.is_face_down and -0.5 or 0.5)
    end)
    debug('Found ', #objs, ' ', nation, ' ', name)
    return objs
end

function Morale:addGoods(nation, value) self:addMedals(nation, value, true) end
function Morale:addMedals(nation, value, is_goods)
    debug('Giving ', value, ' ', is_goods and 'consumer goods' or 'medals', ' to ', nation)
    if not is_goods then alert(string.format('%s was awarded %s medal',
        Nations[nation]:colorized(), string.colorize(value, 'medal')) .. (value > 1 and 's' or '')) end
    if not self.medals[nation] or coroutine.status(self.medals[nation]) == 'dead' then
        self.medals[nation] = coroutine.create(function (stack, remaining) repeat
            remaining = remaining - 1
            Bags.medal_goods.takeObject({
                position = self.positionToWorld(self.snaps[nation].medal_goods) + vector(0, 2.5, 0),
                rotation = vector(0, self.getRotation().y, is_goods and 180 or 0),
                callback_function = function (obj)
                    obj.addTag(nation)
                    obj.registerCollisions()
            end})
            repeat
                value = coroutine.yield()
                if value then remaining = remaining + value end
            until value == nil
        until remaining == 0 end)
        coroutine.resume(self.medals[nation], self:getStack(nation, 'medal_goods'), value)
    else coroutine.resume(self.medals[nation], value) end
end

function Morale:addStress(nation, value)
    debug('Giving ', value, ' stress to ', nation)
    if not self.stress[nation] or coroutine.status(self.stress[nation]) == 'dead' then
        self.stress[nation] = coroutine.create(function (stack, remaining) repeat
            local size, value, first, second = 1, 1
            for i, obj in ipairs(stack) do if obj.getName():match('1') then
                first, second = first or i, first and i
                if first and second then
                    fadeOut(table.remove(stack, second), 0.5)
                    fadeOut(table.remove(stack, first), 0.5)
                    size = 3 break
            end end end
            if not first and remaining > 2 then size, value = 3, 3 end
            debug('Stacking ', value, ' stress on ', nation)
            remaining = remaining - value
            table.insert(stack, Bags.stress[size].takeObject({
                position = self.positionToWorld(self.snaps[nation].stress) + vector(0, 2.5, 0),
                rotation = vector(0, self.getRotation().y, 0),
                callback_function = function (obj)
                    obj.addTag(nation)
                    obj.registerCollisions()
            end}))
            repeat
                value = coroutine.yield()
                if value then debug('Added an additional ', value, ' stress to ', nation) remaining = remaining + value end
            until value == nil
            debug('Stress token landed on ', nation, ' stack')
        until remaining == 0 end)
        coroutine.resume(self.stress[nation], self:getStack(nation, 'stress'), value)
    else debug('Adding stress to ', nation, ' coroutine') coroutine.resume(self.stress[nation], value) end
end

function Morale:removeStress(stress, total)
    local ps = {}
    while total > 0 do
        local obj = table.remove(stress)
        local value, p, pos = tonumber(obj.getName():match('%d')), fadeOut(obj), obj.getPosition()
        for i = 1, value - total do p = p:next(function () table.insert(stress, Bags.stress[1].takeObject({
            position = pos + vector(0, 0.21 * (i - 1), 0), rotation = {0, 180, 0}, smooth = false
        })) end) end
        table.insert(ps, p)
        total = total - value
    end
    return Promise.all(ps)
end

function Morale:collisionHandler(obj, collider)
    for _, label in ipairs{'medal', 'stres'} do if obj.getName():match(label) then
        if (collider.getName():match(label) or collider.guid == self.guid) then
            for nation, co in pairs(self[label .. 's']) do if obj.hasTag(nation) then
                obj.unregisterCollisions()
                obj.removeTag(nation)
                coroutine.resume(co)
                break
    end end end end end
end

function Morale.stressZone(nation)
    local angle = Map:rotationToCenter(Map.positionToLocal(Tokens.homeland[nation].getPosition()))
    if angle > 276.25 then return 6 else return math.floor((angle - 0.5) / 45) end
end

function Morale.updateZone(nation, delta)
    debug('Updating stress zone for ', nation)
    local token = Tokens.homeland[nation]
    local pos, snap_index = Map.positionToLocal(token.getPosition())
    for i, snap in ipairs(Map.snaps) do if pos == snap.position then snap_index = i + 7 * delta break end end
    token.setPositionSmooth(Map.positionToWorld(Map.snaps[snap_index].position))
    token.setRotationSmooth(Map.snaps[snap_index].rotation + Map.rotation)
    local zone = Morale.Zones[math.floor((snap_index - 1) / 7)]
    alert(string.format('%s has %s to the %s', Nations[nation]:colorized(),
        delta > 0 and 'advanced' or 'recovered', string.colorize(zone.name .. ' Zone', Color.fromHex(zone.color))))
    return Promise.condition(|| not token.isSmoothMoving())
end

----#include components/morale

----#include saveload
function onSave()
    if not state.phase then return ''
    else return JSON.encode(state) end
end

function onLoad(saved_state)
    for _, obj in Tags.forAllObjects('components') do if #obj.getObjects() == 0 then obj.interactable = false end end
    for _, obj in Tags.forAllObjects('static') do obj.interactable = false end
    for _, label in ipairs{'left', 'right'} do
        Battle[label] = Battle(Tags.getObject({'Battle', label}), label):initialize()
    end
    Bags = {}
    for _, obj in Tags.forAllObjects('supply') do
        local item, key = nil
        for _, tag in ipairs(obj.getTags()) do
            if Nations[tag] then key = tag
            elseif tag == 'stress' then item, key = tag, obj.value
            elseif tag ~= 'supply' then item = tag
        end end
        if key then
            Bags[item] = Bags[item] or {}
            Bags[item][key] = obj
        elseif item == 'dice' then Bags[item] = Dice(obj)
        else Bags[item] = obj end
    end
    Hotspot:initAssets()
    if saved_state == '' then
        state = {}
        UI.setXmlTable(HUD.XML:initial())
    else
        state = JSON.decode(saved_state)
        UI.setXmlTable(HUD.XML:scenario(state.scenario))
        HUD.loaded():next(loadState)
    end
end

function loadState()
    Setup.initialize()
    -- Identify tokens, commands, construction stacks, cfighters, and hotspots
    for _, obj in ipairs(getObjects()) do
        local name, region = obj.getName():lower(), Map:getRegion(obj)
        region = region and Map.regions[region]
        if #name > 0 and region then
            if name == 'hotspot' then
                local hotspot = Hotspot(obj, region.id)
                Map.regions[hotspot.region].hotspot = hotspot
            elseif name:match('flag') then region.flag = obj
            elseif name == 'cfighter' and obj.memo ~= '' then
                table.insert(Commands.cfighters, Command(obj, obj.memo))
            elseif name:match('construction') then
                region.construction = Construction(obj):restoreUnits()
            elseif name == 'bomb_industry' and obj.is_face_down then
                if region.bombs then table.insert(region.bombs, obj) else region.bombs = {obj} end
            elseif name:match('standing army') then
                region.flag, Commands.standing[region.id] = obj, Standing(obj)
        end end
        if obj.name == 'Card' then
            local card = Card(obj, name:match('^%b[](%a%d+)%b[]'))
            Cards[card.id] = card
            Map.regions[card.id].card = card
        else
            local nation, token, id = name:match('(%a+) (%a+) token')
            if nation and token then Tokens[token][nation] = obj end
            nation, id = name:match('^%b[](%a+)%b[] (%d+)%a+ %a+')
            if nation and id then
                Commands[nation] = Commands[nation] or {}
                Commands[nation][tonumber(id)] = Command(obj):restoreUnits():updateContextMenu()
                if #obj.getJoints() > 0 then
                    getObjectFromGUID(obj.getJoints()[1].joint_object_guid).interactable = false
    end end end end
    log('Commands loaded')
    Setup.initNations()
    for i, nation in turnOrder() do
        UI.setAttributes('tracker' .. i, {image = nation, active = true})
        UI.show('status' .. i)
        for resource in Resources() do UI.show('frame-' .. resource .. i) end
    end
    Orders:loaded():next(function ()
        for nation in pairs(Scenarios[state.scenario].nations) do
            local cards, rack = Cards[nation]:sort()
            if #cards > 0 then
                Cards[nation].first = cards[1]
                for i = 2, #cards do cards[i - 1].next, cards[i].prev = cards[i], cards[i - 1] end
                Cards[nation].origin = {position = cards[1].getPosition(), rotation = cards[1].getRotation():setAt('z', 0)}
            else
                for _, obj in Tags.forAllObjects({nation, 'cardholder'}) do if obj.value == 1 then rack = obj break end end
                Cards[nation].origin = {position = rack.positionToWorld({0, 0, 0.7075}), rotation = rack.getRotation()}
            end
            if not Tokens.turn[nation] then
                Orders[nation].UI.setXml('')
                Orders[nation], Resources[nation], Commands.trays[nation] = nil
                for id, region in pairs(Map.regions) do if id:match('^' .. Nations[nation].prefix) then
                    region.collapsed = true
                end end
            else Resources[nation]:loaded() end
        end
        if state.scenario == 'global' and not state.pact_broken then
            Orders.japan.UI.show('pact')
            Orders.ussr.UI.show('pact')
        end
        Setup.zoneEvents()
        Round()
    end)
end

----#include saveload
----#include hud
Vis = {
    all = 'White|Green|Orange|Blue|Brown|Red|Yellow|Grey|Black|Pink',
    allies = 'Blue|Brown|Red|Yellow|Black',
    axis = 'White|Green|Orange|Black',
    none = 'Pink'
}

function reloadUI() UI.setXmlTable(UI.getXmlTable()) end

function toggleDebug()
    Debug = not Debug
    UI.setAttributes('debug', {
        image = Debug and 'log-push' or 'log',
        tooltip = (Debug and 'Disable' or 'Enable') ..  ' debug logging'
    })
end

HUD = {Tooltips = {orders = 'movement orders', combat = 'hotspot details', production = 'production orders'}}

----#include ui/hud
HUD.XML = {Defaults = {
    Image = {
        default = {height = 35, width = 35},
        slash = {image = 'order-slash', ignoreLayout = true},
        disabled = {active = false}
    },
    Text = {
        default = {color = '#ffffff'},
        outline = {outline = 'black', outlineSize = '1 1'},
        status = {fontSize = 30, outline = 'black', outlineSize = '1.5 1.5', active = false},
        tracker = {alignment = 'middleLeft'},
        label = {fontSize = 12},
        region_id = {fontStyle = 'Bold'},
        region_name = {fontSize = 10, horizontalOverflow = 'Wrap', verticalOverflow = 'Overflow'},
        purchase = {fontSize = 28},
        oil = {color = '#9a2829'},
        iron = {color = '#4276bb'},
        osr = {color = '#ddb426'}
    },
    InputField = {
        default = {colors = '#ffffff20|#ffffff40|#ffffff20|clear', placeholder = ' '},
        order = {fontSize = 24},
        bid = {fontSize = 20},
        command = {characterValidation = 'Integer', characterLimit = 3},
        target = {characterLimit = 4}
    },
    Button = {
        disabled = {interactable = false},
        hide = {image = 'minimize', highlightedSprite = 'minimize-hover', transition = 'SpriteSwap'},
        display = {transition = 'SpriteSwap', visibility = Vis.all},
        resolve = {fontSize = 8, position = '-156 0'},
        scenario = {fontSize = 28, onClick = 'Setup'}
    },
    Panel = {
        shade = {color = '#000000b0'},
        draggable = {allowDragging = true, returnToOriginalPositionWhenReleased = false},
        tracker = {padding = '4 0 0 0'},
        hud = {width = 316, padding = '2 2 2 0', ignoreLayout = true, active = false},
        resolve = {height = 35, width = 78, padding = '2 2 2 2', rectAlignment = 'UpperLeft', ignoreLayout = true},
        order = {padding = '5 5 0 0', color = '#fdf2e960'}
    },
    HorizontalLayout = {
        scenario = {height = 35, spacing = 3, ignoreLayout = true},
        axis = {rectAlignment = 'UpperCenter', offsetXY = '0 -12'},
        allies = {rectAlignment = 'LowerCenter', offsetXY = '0 12'}
    },
    VerticalLayout = {order = {image = 'order-arrow'}},
    TableLayout = {
        hud = {cellPadding = '2 2 2 2', cellBackgroundColor = 'clear'},
        orders = {cellPadding = '2 2 2 2', cellBackgroundColor = '#000000b0'}
    }
}}

function HUD.XML:default(tag, class)
    local attr = self.Defaults[tag][class]
    if class ~= 'default' then attr.class = class end
    return {tag = tag, attributes = attr}
end

function HUD.XML:defaults()
    local children = {}
    for tag, classes in pairs(self.Defaults) do for class, _ in pairs(classes) do table.insert(children, self:default(tag, class)) end end
    return children
end

function HUD.XML.upperTracker()
    local cells = {
        {tag = 'Cell', children = {{tag = 'Button', attributes = {class = 'display', id = 'help-button',
            image = 'question', highlightedSprite = 'question-hover', pressedSprite = 'question-push',
            onClick = 'showHUD(help)', tooltip = 'Show help text', tooltipPosition = 'Above'
        }}}},
        {tag = 'Cell'},
        {tag = 'Cell', attributes = {columnSpan = 6}, children = {
            {tag = 'Text', attributes = {class = 'outline', id = 'scenario', fontSize = 26}}
        }},
        {tag = 'Cell', attributes = {columnSpan = 2}, children = {{tag = 'Panel', attributes = {class = 'shade'}, children = {
            {tag = 'Text', value = 'CURRENT PHASE', attributes = {class = 'label'}}
        }}}},
        {tag = 'Cell', attributes = {columnSpan = 8}, children = {{tag = 'Panel', attributes = {class = 'tracker'}, children = {
            {tag = 'Text', attributes = {class = 'tracker outline', id = 'phase', fontSize = 22}}
        }}}},
        {tag = 'Cell', children = {{tag = 'Button', attributes = {class = 'display', id = 'resources-button',
            image = 'resources', highlightedSprite = 'resources-hover', pressedSprite = 'resources-push',
            onClick = 'showHUD(resources)', tooltip = 'Show resource totals', tooltipPosition = 'Above'
        }}}}
    }
    for i = 1, 7 do table.insert(cells, {tag = 'Cell', children = {
        {tag = 'Image', attributes = {class = 'disabled', id = 'tracker' .. i}}
    }}) end
    return cells
end

function HUD.XML.lowerTracker()
    local cells = {
        {tag = 'Cell', children = {{tag = 'Button', attributes = {id = 'debug',
            image = 'log', highlightedSprite = 'log-hover', pressedSprite = 'log-push', transition = 'SpriteSwap',
            tooltip = 'Enable debug logging', tooltipPosition = 'Below', onClick = 'toggleDebug', visibility = 'Host'
        }}}},
        {tag = 'Cell', children = {{tag = 'Button', attributes = {id = 'reload',
            image = 'reload', highlightedSprite = 'reload-hover', pressedSprite = 'reload-push', transition = 'SpriteSwap',
            tooltip = 'Reload UI', tooltipPosition = 'Below', visibility = 'Host', onClick = 'reloadUI'
        }}}},
        {tag = 'Cell', attributes = {columnSpan = 3}, children = {{tag = 'Text', value = 'ROUND', attributes = {alignment = 'MiddleRight', class = 'label'}}}},
        {tag = 'Cell', attributes = {columnSpan = 2}, children = {{tag = 'Text', attributes = {id = 'round', fontSize = 28}}}},
        {tag = 'Cell'},
        {tag = 'Cell', attributes = {columnSpan = 2}, children = {{tag = 'Panel', attributes = {class = 'shade'}, children = {
            {tag = 'Text', value = 'CURRENT STEP', attributes = {class = 'label'}}
        }}}},
        {tag = 'Cell', attributes = {columnSpan = 8}, children = {{tag = 'Panel', attributes = {class = 'tracker'}, children = {
            {tag = 'Text', attributes = {class = 'tracker', id = 'step', fontSize = 18}}
        }}}},
        {tag = 'Cell', children = {{tag = 'Button', attributes = {class = 'display', id = 'hud-button',
            onClick = 'showHUD', tooltipPosition = 'Below', active = false
        }}}}
    }
    for i = 1, 7 do table.insert(cells, {tag = 'Cell', attributes = {id = 'status-cell' .. i}, children = {
        {tag = 'Text', attributes = {class = 'status', id = 'status' .. i}}
    }}) end
    return cells
end

function HUD.XML.resources()
    local rows = {{tag = 'Row', children = {
        {tag = 'Cell'},
        {tag = 'Cell', attributes = {columnSpan = 3}, children = {{tag = 'Panel', attributes = {class = 'shade'}, children = {
            {tag = 'Text', value = 'RESOURCE SUMMARY', attributes = {class = 'label'}}
        }}}},
        {tag = 'Cell', attributes = {columnSpan = 3}},
        {tag = 'Cell', children = {{tag = 'Button', attributes = {class = 'hide', onClick = 'hideHUD(resources)'}}}}
    }}}
    for resource in Resources() do
        local cells = {{tag = 'Cell', children = {{tag = 'Image', attributes = {image = resource}}}}}
        for i = 1, 7 do table.insert(cells, {tag = 'Cell', children = {
            {tag = 'Panel', attributes = {class = 'shade', id = 'frame-' .. resource .. i, active = false}, children = {
                {tag = 'Text', attributes = {class = 'purchase outline ' .. resource, id = resource .. i}}
        }}}}) end
        table.insert(rows, {tag = 'Row', children = cells})
    end
    return rows
end

function HUD.XML.orders()
    local rows = {{tag = 'Row', children = {
        {tag = 'Cell'},
        {tag = 'Cell', attributes = {columnSpan = 3}, children = {{tag = 'Panel', attributes = {class = 'shade'}, children = {
            {tag = 'Text', value = 'MOVEMENT SUMMARY', attributes = {class = 'label'}}
        }}}},
        {tag = 'Cell', attributes = {columnSpan = 3}},
        {tag = 'Cell', children = {{tag = 'Button', attributes = {class = 'hide', onClick = 'hideHUD(orders)'}}}}
    }}}
    for j = 1, 9 do
        local cells = {{tag = 'Cell'}}
        for i = 1, 7 do table.insert(cells, {tag = 'Cell', children = {{tag = 'Panel', attributes = {class = 'shade', id = 'order' .. i .. j}, children = {
            {tag = 'VerticalLayout', attributes = {class = 'order'}, children = {
                {tag = 'Text', attributes = {id = 'command' .. i .. j}},
                {tag = 'Text', attributes = {id = 'target' .. i .. j}}
            }},
            {tag = 'Image', attributes = {class = 'slash disabled', id = 'slash' .. i .. j}}
        }}}}) end
        table.insert(rows, {tag = 'Row', children = cells})
    end
    return rows
end

function HUD.XML.combat()
    local rows = {{tag = 'Row', children = {
        {tag = 'Cell', children = {{tag = 'Image', attributes = {image = 'hotspot'}}}},
        {tag = 'Cell', attributes = {columnSpan = 6}, children = {{tag = 'Panel', attributes = {class = 'shade'}, children = {
            {tag = 'Text', value = 'COMBAT SUMMARY', attributes = {class = 'label'}}
        }}}},
        {tag = 'Cell', attributes = {columnSpan = 5}},
        {tag = 'Cell', children = {{tag = 'Button', attributes = {class = 'hide', onClick = 'hideHUD(combat)'}}}}
    }}}
    for i = 1, 24 do table.insert(rows, {tag = 'Row', attributes = {id = 'hotspot' .. i}, children = {
        {tag = 'Cell', attributes = {columnSpan = 6}, children = {
            {tag = 'Panel', attributes = {class = 'shade', minWidth = 36}, children = {
                {tag = 'Text', attributes = {class = 'region_id', id = 'combat-id' .. i}}
            }},
            {tag = 'Panel', attributes = {id = 'name-panel' .. i, minWidth = 104}, children = {
                {tag = 'Text', attributes = {class = 'region_name', id = 'combat-name' .. i}}
            }}
        }},
        {tag = 'Cell', attributes = {columnSpan = 5}, children = {
            {tag = 'Panel', attributes = {id = 'combatants' .. i .. '-axis', color = '#600000b0'}, children = {{tag = 'HorizontalLayout', children = {
                {tag = 'image', attributes = {id = 'combatants' .. i .. '-axis1'}},
                {tag = 'image', attributes = {id = 'combatants' .. i .. '-axis2'}},
                {tag = 'image', attributes = {id = 'combatants' .. i .. '-axis3'}}
            }}}},
            {tag = 'Panel', attributes = {id = 'combatants' .. i .. '-allies', color = '#000060b0'}, children = {{tag = 'HorizontalLayout', children = {
                {tag = 'image', attributes = {id = 'combatants' .. i .. '-allies1'}},
                {tag = 'image', attributes = {id = 'combatants' .. i .. '-allies2'}},
                {tag = 'image', attributes = {id = 'combatants' .. i .. '-allies3'}}
            }}}}
        }},
        {tag = 'Cell', attributes = {columnSpan = 2}, children = {{tag = 'Panel', attributes = {id = 'combat-status' .. i}, children = {
            {tag = 'Text', attributes = {id = 'combat-status-label' .. i, fontSize = 12}}
        }}}}
    }}) end
    return rows
end

function HUD.XML.production()
    local rows = {{tag = 'Row', children = {
        {tag = 'Cell', children = {{tag = 'Image', attributes = {image = 'production'}}}},
        {tag = 'Cell', attributes = {columnSpan = 3}, children = {{tag = 'Panel', attributes = {class = 'shade'}, children = {
            {tag = 'Text', value = 'PRODUCTION SUMMARY', attributes = {class = 'label'}}
        }}}},
        {tag = 'Cell', attributes = {columnSpan = 3}},
        {tag = 'Cell', children = {{tag = 'Button', attributes = {class = 'hide', onClick = 'hideHUD(production)'}}}}
    }}}
    for _, unit in ipairs{'cg', 'infantry', 'artillery', 'armor', 'fighter', 'bomber', 'submarine', 'cruiser', 'carrier', 'battleship'} do
        local cells = {{tag = 'Cell', children = {{tag = 'Image', attributes = {image = unit}}}}}
        for i = 1, 7 do table.insert(cells, {tag = 'Cell', children = {{tag = 'Panel', attributes = {class = 'shade'}, children = {
            {tag = 'Text', attributes = {class = 'purchase', id = unit .. i}}
        }}}}) end
        table.insert(rows, {tag = 'Row', children = cells})
    end
    return rows
end

function HUD.XML.popouts(scenario)
    local popouts = {}
    for nation, _ in pairs(Scenarios[scenario].nations or CommandSetup) do
        local row_count, guid = 3, getObjectsWithAllTags({nation, 'orders'})[1].guid
        if nation == 'china' or nation == 'italy' or scenario ~= 'global' and (nation == 'usa' or nation == 'uk') then row_count = 2 end
        local rows = {{tag = 'HorizontalLayout', attributes = {minHeight = 40}, children = {
            {tag = 'TableLayout', attributes = {class = 'orders', minWidth = 170}, children = {{tag = 'Row', children = {{tag = 'Cell', children = {
                {tag = 'Panel', attributes = {padding = '0 0 0 0', color = Color[nation]:setAt('a', 0.4):toXml()}, children = {
                    {tag = 'Image', attributes = {image = nation, minWidth = 36}},
                    {tag = 'Text', value = Nations[nation].name:upper(), attributes = {minWidth = 130, fontSize = 16, fontStyle = 'Bold'}}
            }}}}}}}},
            {tag = 'Panel', attributes = {minWidth = 40, padding = '4 4 4 4', color = '#000000b0'}, children = {
                {tag = 'Button', attributes = {class = 'hide', id = nation .. '-hide', onClick = 'closePopout'}}
            }}
        }}}
        if nation ~= 'china' then
            table.insert(rows[1].children, {tag = 'Panel', attributes = {minWidth = 90, padding = '0 16 0 0', color = '#000000b0'}, children = {
                {tag = 'Text', value = 'OIL BID', attributes = {fontSize = 16, fontStyle = 'Bold'}}
            }})
            table.insert(rows[1].children, {tag = 'TableLayout', attributes = {class = 'orders', minWidth = 60}, children = {{tag = 'Row', children = {
                {tag = 'Cell', children = {{tag = 'Panel', attributes = {padding = '12 0 0 0', color = '#fdf2e960'}, children = {
                    {tag = 'InputField', attributes = {class = 'bid', id = nation .. '-bid', onEndEdit = guid .. '/bidInput'}}
            }}}}}}}})
        else table.insert(rows[1].children, {tag = 'Panel', attributes = {minWidth = 150, color = '#000000b0'}}) end
        for row = 1, row_count do
            local cells = {}
            for col = 1, 3 do table.insert(cells, {tag = 'Cell', children = {{tag = 'Panel', attributes = {class = 'order'}, children = {
                {tag = 'VerticalLayout', attributes = {image = 'order-arrow'}, children = {
                    {tag = 'Panel', attributes = {padding = '20 20 4 9'}, children = {
                        {tag = 'InputField', attributes = {class = 'order command', id = nation .. '-command' .. (row - 1) * 3 + col, onEndEdit = guid .. '/moveInput'}}
                    }},
                    {tag = 'Panel', attributes = {padding = '15 15 9 4'}, children = {
                        {tag = 'InputField', attributes = {class = 'order target', id = nation .. '-target' .. (row - 1) * 3 + col, onEndEdit = guid .. '/moveInput'}}
            }}}}}}}}) end
            table.insert(rows, {tag = 'TableLayout', attributes = {class = 'orders', minHeight = 110}, children = {{tag = 'Row', children = cells}}})
            if row < row_count then table.insert(rows, {tag = 'Panel', attributes = {minHeight = 20, color = '#000000b0'}}) end
        end
        local elements = {{tag = 'VerticalLayout', children = rows}}
        if nation ~= 'china' then table.insert(elements, {tag = 'Image', attributes = {
            image = 'oil', height = 32, width = 32, ignoreLayout = true, rectAlignment = 'UpperRight', offsetXY = '-44 -4'
        }}) end
        table.insert(popouts, {tag = 'Panel', attributes = {class = 'draggable', id = nation .. '-popout',
            height = tostring(20 + row_count * 130), width = 360, padding = '0 0 0 0', position = '720 -296', active = false
        }, children = elements})
    end
    return table.unpack(popouts)
end

function HUD.XML:initial() return {
    {tag = 'Defaults', children = {
        self:default('Image', 'default'),
        self:default('Text', 'default'),
        self:default('Button', 'scenario'),
        self:default('Button', 'disabled'),
        self:default('HorizontalLayout', 'scenario'),
        self:default('HorizontalLayout', 'axis'),
        self:default('HorizontalLayout', 'allies')
    }},
    {tag = 'VerticalLayout', attributes = {id = 'scenarios',
        position = '0 180', height = 272, width = 960, padding = '10 10 10 10', color = '#000000b0',
        allowDragging = true, returnToOriginalPositionWhenReleased = false
    }, children = {
        {tag = 'Text', value = 'Choose a scenario:', attributes = {minHeight = 80, fontSize = 48, outline = 'black', outlineSize = '1.5 1.5'}},
        {tag = 'HorizontalLayout', attributes = {minHeight = 172, spacing = 20}, children = {
            {tag = 'Panel', children = {
                {tag = 'Button', value = 'Global War', attributes = {class = 'scenario', id = 'global'}},
                {tag = 'HorizontalLayout', attributes = {class = 'scenario axis', width = 105}, children = {
                    {tag = 'Image', attributes = {image = 'germany'}},
                    {tag = 'Image', attributes = {image = 'italy'}},
                    {tag = 'Image', attributes = {image = 'japan'}}
                }},
                {tag = 'HorizontalLayout', attributes = {class = 'scenario allies', width = 140}, children = {
                    {tag = 'Image', attributes = {image = 'usa'}},
                    {tag = 'Image', attributes = {image = 'uk'}},
                    {tag = 'Image', attributes = {image = 'ussr'}},
                    {tag = 'Image', attributes = {image = 'china'}}
                }}
            }},
            {tag = 'Panel', children = {
                {tag = 'Button', value = 'War in Europe', attributes = {class = 'scenario', id = 'europe'}},
                {tag = 'HorizontalLayout', attributes = {class = 'scenario axis', width = 70}, children = {
                    {tag = 'Image', attributes = {image = 'germany'}},
                    {tag = 'Image', attributes = {image = 'italy'}}
                }},
                {tag = 'HorizontalLayout', attributes = {class = 'scenario allies', width = 105}, children = {
                    {tag = 'Image', attributes = {image = 'usa'}},
                    {tag = 'Image', attributes = {image = 'uk'}},
                    {tag = 'Image', attributes = {image = 'ussr'}}
                }}
            }},
            {tag = 'Panel', children = {
                {tag = 'Button', value = 'North Africa', attributes = {class = 'scenario', id = 'nafrica'}},
                {tag = 'HorizontalLayout', attributes = {class = 'scenario axis', width = 70}, children = {
                    {tag = 'Image', attributes = {image = 'germany'}},
                    {tag = 'Image', attributes = {image = 'italy'}}
                }},
                {tag = 'HorizontalLayout', attributes = {class = 'scenario allies', width = 70}, children = {
                    {tag = 'Image', attributes = {image = 'usa'}},
                    {tag = 'Image', attributes = {image = 'uk'}}
                }}
            }},
            {tag = 'Panel', children = {
                {tag = 'Button', value = 'War in the Pacific', attributes = {class = 'scenario', id = 'pacific'}},
                {tag = 'HorizontalLayout', attributes = {class = 'scenario axis', width = 35}, children = {
                    {tag = 'Image', attributes = {image = 'japan'}}
                }},
                {tag = 'HorizontalLayout', attributes = {class = 'scenario allies', width = 105}, children = {
                    {tag = 'Image', attributes = {image = 'usa'}},
                    {tag = 'Image', attributes = {image = 'uk'}},
                    {tag = 'Image', attributes = {image = 'china'}}
                }}
            }},
            {tag = 'Panel', children = {
                {tag = 'Button', value = 'Eastern Front', attributes = {class = 'scenario', id = 'eastern'}},
                {tag = 'HorizontalLayout', attributes = {class = 'scenario axis', width = 35}, children = {
                    {tag = 'Image', attributes = {image = 'germany'}}
                }},
                {tag = 'HorizontalLayout', attributes = {class = 'scenario allies', width = 35}, children = {
                    {tag = 'Image', attributes = {image = 'ussr'}}
                }}
            }}
    }}}}
} end

function HUD.XML:scenario(scenario) return {
    {tag = 'Defaults', children = self:defaults()},
    {tag = 'Panel', attributes = {class = 'draggable shade', id = 'tracker',
        position = '0 -460', height = 82, width = 1018, padding = '2 2 2 2'
    }, children = {
        {tag = 'Panel', attributes = {id = 'turn',
            height = 43, width = 43, position = '214.5 19', ignoreLayout = true, color = '#cccccc', active = false
        }},
        {tag = 'Panel', attributes = {class = 'shade', id = 'help',
            visibility = 'Pink', height = 235, width = 702, position = '-158 158', padding = '38 2 2 0', ignoreLayout = true
        }, children = {
            {tag = 'Panel', attributes = {class = 'shade', padding = '2 2 2 2'}, children = {
                {tag = 'VerticalScrollView', attributes = {color = 'clear'}, children = {{tag = 'Panel', attributes = {padding = '4 6 4 4'}, children = {
                    {tag = 'Text', attributes = {id = 'help-text', fontSize = 15, alignment = 'UpperLeft'}}
            }}}}}},
            {tag = 'Image', attributes = {image = 'question', ignoreLayout = true, rectAlignment = 'UpperLeft', offsetXY = '2 -2'}},
            {tag = 'Button', attributes = {class = 'hide',
                height = 35, width = 35, ignoreLayout = true, rectAlignment = 'UpperLeft', offsetXY = '2 -41', onClick = 'hideHUD(help)'}}
        }},
        {tag = 'Panel', attributes = {class = 'shade hud', id = 'resources',
            height = 158, position = '351 120', visibility = Vis.none, active = true
        }, children = {{tag = 'TableLayout', attributes = {class = 'hud'}, children = self.resources()}}},
        {tag = 'Panel', attributes = {class = 'shade hud', id = 'orders', height = 392, position = '351 237'}, children = {
            {tag = 'Panel', attributes = {id = 'orders-highlight',
                height = 396, width = 43, rectAlignment = 'UpperLeft', ignoreLayout = true
            }},
            {tag = 'TableLayout', attributes = {class = 'hud'}, children = self.orders()},
            {tag = 'Panel', attributes = {class = 'resolve shade', id = 'confirm-panel'}, children = {
                {tag = 'Button', attributes = {class = 'resolve', id = 'confirm', colors = '#ffffffc0|#c0ffc0c0|green|grey', onClick = 'confirmOrder'}}
            }},
            {tag = 'Panel', attributes = {class = 'resolve shade', id = 'cancel-panel'}, children = {
                {tag = 'Button', attributes = {class = 'resolve', id = 'cancel', colors = '#ffffffc0|#ffd0d0c0|red|grey', onClick = 'cancelOrder'}}
            }}
        }},
        {tag = 'Panel', attributes = {class = 'shade hud', id = 'combat', height = 602, position = '351 342'}, children = {
            {tag = 'TableLayout', attributes = {class = 'hud'}, children = self.combat()}
        }},
        {tag = 'Panel', attributes = {class = 'shade hud', id = 'production', height = 431, position = '351 256'}, children = {
            {tag = 'TableLayout', attributes = {class = 'hud'}, children = self.production()}
        }},
        {tag = 'TableLayout', attributes = {cellPadding = '2 2 2 2', cellBackgroundColor = 'clear'}, children = {
            {tag = 'Row', children = self.upperTracker()}, {tag = 'Row', children = self.lowerTracker()}
        }},
        {tag = 'Button', attributes = {id = 'start',
            position = '30 0', height = 64, width = 240, ignoreLayout = true,
            text = 'Start round', fontSize = 36, onClick = 'Round', active = false
        }}
    }},
    {tag = 'Panel', attributes = {class = 'draggable', id = 'movement',
        height = 41, width = 960, position = '0 400', color = '#000000b0', active = false
    }, children = {
        {tag = 'Image', attributes = {id = 'movement-nation', rectAlignment = 'MiddleLeft', offsetXY = '3 0', raycastTarget = false}},
        {tag = 'Text', attributes = {id = 'movement-order', fontSize = 32}}
    }},
    self.popouts(scenario)
} end

----#include ui/hud

function HUD.loaded() return Promise.condition(|| UI.getAttribute('help-button', 'image') ~= nil) end

function HUD.updateTracker(step, phase, help)
    if type(step) == 'table' then step, phase, help = table.unpack(step) end
    if phase then
        UI.setValue('phase', phase)
        if phase:match('%d') then broadcastToAll('Phase ' .. phase) end
    end
    UI.setValue('step', step)
    if help then UI.setValue('help-text', HelpText[help]) end
end

function HUD.updateStatus(nation, value, tint, image, turn)
    if tint then if type(tint) == 'table' then tint = tint:toXml(false) else tint = '#' .. tint end end
    turn = turn or turnOrder[nation]
    local id, cell_id = 'status' .. turn, 'status-cell' .. turn
    if image then UI.setAttributes(cell_id, {dontUseTableCellBackground = true, image = image})
    else UI.setAttribute(cell_id, 'dontUseTableCellBackground', false) end
    if tint then UI.setAttribute(id, 'color', tint) end
    UI.setValue(id, value and (value == true and '✓' or value) or '')
end

function HUD.resetStatus()
    for _, nation in turnOrder() do HUD.updateStatus(nation, nil, Color.white) end
end

function HUD.updateTurn(nation, order)
    if nation then UI.setAttributes('turn', {
        offsetXY = (order or turnOrder[nation]) * 39 .. ' 0',
        color = Color[nation]:toXml(false), active = true
    }) else UI.hide('turn') end
end

function HUD.setResources(nation, data)
    local id = turnOrder[nation]
    for resource in Resources() do UI.setValue(resource .. id, data[resource] or '') end
end

function HUD.open(id)
    UI.setAttributes(id, {visibility = Vis.all, active = true})
    if id ~= 'resources' then
        UI.setAttribute('resources', 'visibility', Vis.none)
        UI.setAttribute('resources-button', 'visibility', Vis.all)
        UI.setAttributes('hud-button', {
            image = id, highlightedSprite = id .. '-hover', pressedSprite = id .. '-push',
            visibility = Vis.none, tooltip = 'Show ' .. HUD.Tooltips[id], active = true
        })
    else UI.setAttribute('resources-button', 'visibility', Vis.none) end
end

function HUD.close(id)
    UI.hide(id)
    UI.hide('hud-button')
end

function HUD.show(player, id, button)
    if id == 'resources' then
        local hud_type = UI.getAttribute('hud-button', 'image')
        if hud_type then HUD.hide(player, hud_type) end
    elseif id ~= 'help' then HUD.hide(player, 'resources') end
    HUD.showElement(player, id)
    HUD.hideElement(player, button)
end

function HUD.hide(player, id)
    HUD.hideElement(player, id)
    if id ~= 'resources' and id ~= 'help' then id = 'hud' end
    HUD.showElement(player, id .. '-button')
end

function HUD.openPopout(nation, player)
    UI.setAttributes(nation .. '-popout', {visibility = player, active = true})
end

function HUD.closePopout(nation)
    Orders[nation]:minimize()
    UI.hide(nation .. '-popout')
end

function HUD.showElement(player, id)
    if id == '-1' then id = UI.getAttribute('hud-button', 'image') end
    UI.setAttribute(id, 'visibility', player .. '|' .. UI.getAttribute(id, 'visibility'))
end

function HUD.hideElement(player, id)
    UI.setAttribute(id, 'visibility', UI.getAttribute(id, 'visibility'):gsub('(|?)' .. player .. '(|?)', function (l, r)
        if l == '|' and r == '|' then return '|' else return '' end
    end))
end

-- Combat HUD
HUD.Combat = {}
function HUD.Combat.setStatus(i, label, textColor, cellColor)
    UI.setValue('combat-status-label' .. i, label)
    UI.setAttribute('combat-status-label' .. i, 'color', textColor)
    UI.setAttribute('combat-status' .. i, 'color', cellColor)
end

function HUD.Combat:active(i)
    self.setStatus(i, 'ACTIVE', Color.white:toXml(), Color.orange:setAt('a', 0.5):toXml(true))
end

function HUD.Combat:done(i)
    self.setStatus(i, 'DONE', Color.grey:toXml(), '#000000b0')
end

function HUD.Combat:passive(i)
    self.setStatus(i, '', Color.white:toXml(), '#00000000')
end

-- Button receiver functions
function showHUD(player, value, id) HUD.show(player.color, value, id) end
function hideHUD(player, value) HUD.hide(player.color, value) end
function closePopout(_, _, id) HUD.closePopout(id:match('^%a+')) end

----#include hud
----#include round
Round = {}
setmetatable(Round, {__call = function (t, ...)
    if t.resume == nil then
        t.resume = coroutine.wrap(|...| t:main(...))
        t.resume(...)
    else t.resume() end
end})

function Round:main()
    if state.phase < 1 then
        HUD.updateTracker('', '', 'start')
        HUD.resetStatus()
        UI.show('start')
        coroutine.yield()
        UI.hide('start')
        state.round = state.round + 1
        if state.round > 1 then HUD.close('production') end
        for i, nation in turnOrder() do
            Tokens.turn[nation].setPositionSmooth(Map.positionToWorld(Map.snaps[i].position:lerp(Map.center, 0.225)))
            Tokens.turn[nation].setRotationSmooth(Map.snaps[i].rotation + Map.rotation)
            Orders[nation]:newRound(state.round)
    end end
    UI.setValue('round', state.round)
    for nation, orders in ipairs(Orders) do
        orders.UI.setValue('round', state.round)
        if orders.not_china then orders.UI.hide('bid') end
    end
    if state.phase < 2 then Economy(self.resume) end
    Planning(self.resume)
    Movement(self.resume)
    if state.phase < 5 then Combat(self.resume) end
    if state.phase < 6 then Refit(self.resume) end
    if state.phase < 7 then Morale(self.resume) end
    Production(self.resume)
    Cleanup(self.resume)
    state.phase, self.resume = 0, nil
    Wait.time(|| Round(), 1)
end

Phase = {}
setmetatable(Phase, {__call = function (t, meta)
    local p = {}
    meta = meta or {}
    meta.__call = t.main
    setmetatable(p, meta)
    return p
end})

function Phase.main(t, co, ...)
    if rawget(t, 'resume') == nil then
        t.resume = co
        t:main(...)
    else t.resume(...) end
end

function Phase.readyLoop(readied, initial, fun)
    local all_ready = initial or false
    while not all_ready do
        local nation, ready = coroutine.yield()
        if fun == nil or fun(nation, ready) ~= false then
            readied[nation], all_ready = ready, true
            HUD.updateStatus(nation, ready)
            for _, r in pairs(readied) do all_ready = all_ready and r end
        else Wait.frames(|| Orders[nation]:toggleReady(false), 1) end
    end
    for nation, _ in pairs(readied) do Orders[nation].UI.hide('ready') end
end

turnOrder = {get = function ()
    local turns = {}
    for nation, token in pairs(Tokens.turn) do table.insert(turns, {
        nation = nation, angle = (Map:rotationToCenter(Map.positionToLocal(token.getPosition())) + 60) % 360
    }) end
    table.sort(turns, |a, b| a.angle > b.angle)
    for i = 1, #turns do turns[turns[i].nation], turns[i] = i, turns[i].nation end
    return turns
end}
setmetatable(turnOrder, {
    __call = |t| ipairs(t.get()),
    __index = |t, k| t.get()[k]
})

----#include round

----#include phases/setup
-- Game and Scenario Setup

Setup = {}
setmetatable(Setup, {__call = function (self, _, value, id)
    local options = {take_her_down = true}
    if id ~= 'global' then Global.setDecals({{
        name = 'mask', url = 'http://cloud-3.steamusercontent.com/ugc/' .. Scenarios[id].decal .. '/',
        position = {0.05, 6.605, -0.05}, rotation = {90, 0, 0}, scale = {83, 83, 83}
    }}) end
    UI.setXmlTable(HUD.XML:scenario(id))
    HUD.loaded():next(function ()
        state = {scenario = id or 'global', options = options, round = 0, phase = 0, orders = {}}
        self.initialize()
        self.initNations()
        HUD.updateTracker('Unpacking components', 'Game setup', 'setup')
        return self.unpack(id)
    end):next(function ()
        self.hotspots()
        if state.scenario == 'global' then
            Orders.japan.UI.show('pact')
            Orders.ussr.UI.show('pact')
        end
        self.zoneEvents()
        Round()
    end)
end})

function Setup.initialize()
    UI.setValue('scenario', Scenarios[state.scenario].label)
    UI.setValue('round', state.round == 0 and '-' or state.round)
    Map:initialize(Tags.getObject('Map'), state.scenario)
    Morale:initialize(Tags.getObject('Morale'), state.scenario)
    Tokens = {homeland = {}, turn = {}}
    Cards.neutral = Tags.getObject('neutrals')
end

function Setup.initNations()
    for nation in pairs(Scenarios[state.scenario].nations) do
        Orders[nation] = OrdersChart(Tags.getObject({nation, 'orders'}), nation):initialize(state.scenario)
        Resources[nation] = ResourceChart(Tags.getObject({nation, 'resources'}), nation):initialize()
        Cards[nation] = Cards(getObjectFromGUID(CardZones[nation]), nation)
        Commands.trays[nation] = {}
        for _, obj in Tags.forAllObjects({nation, 'static'}) do for _, tag in ipairs(obj.getTags()) do
            if tag ~= nation and tag ~= 'static' then Commands.trays[nation][tag] = obj break end
    end end end
end

function Setup.unpack(scenario)
    local delay, ready, i = Promise.frames(1), {}, 1
    for _, nation in ipairs(Nations:inOrder()) do if Scenarios[scenario].nations[nation] then
        local turn = i
        for resource in Resources() do UI.show('frame-' .. resource .. i) end
        local components = Tags.getObject({nation, 'components'})
        Tokens.homeland[nation] = Setup.homelandToken(components, i)
        Tokens.turn[nation] = Setup.turnToken(components, i)
        Wait.condition(|| Resources[nation]:loaded(), || Tokens.turn[nation].resting)
        table.insert(ready, delay:next(|| Setup.unpackNation(nation, components, turn)))
        delay, i = delay:next(|| Promise.time(0.5)), i + 1
    end end
    return Promise.all(ready)
end

function Setup.unpackNation(nation, components, turn)
    Setup.resourcePegs(components, Resources[nation], nation == 'china')
    local p = Promise.all(Setup.cards(components, nation), Setup.commands(components, nation))
    Wait.condition(function ()
        components.interactable = false
        components.setPositionSmooth(components.getPosition():setAt('y', 3))
    end, || #components.getObjects() == 0)
    UI.setAttributes('tracker' .. turn, {image = nation, active = true})
    UI.show('status' .. turn)
    p:next(|| HUD.updateStatus(nation, true))
    return p
end

function Setup.homelandToken(components, order)
    local point = Map.snaps[order + 7]
    return components.takeObject({
        position = Map.positionToWorld(point.position) + vector(0, 0.2, 0),
        rotation = point.rotation + Map.rotation
    })
end

function Setup.turnToken(components, order)
    local point = Map.snaps[order]
    return components.takeObject({
        position = Map.positionToWorld(point.position) + vector(0, 0.2, 0),
        rotation = point.rotation + Map.rotation
    })
end

function Setup.resourcePegs(components, resources, is_china)
    local snaps, up = resources.getSnapPoints(), vector(0, 0.2, 0)
    if not is_china then components.takeObject({position = resources.positionToWorld(snaps[1].position) + up}) end
    components.takeObject({position = resources.positionToWorld(snaps[22].position) + up})
    components.takeObject({position = resources.positionToWorld(snaps[43].position) + up})
end

function Setup.cards(components, nation)
    local prefix, racks, p, rack = Nations[nation].prefix, {}, Promise()
    for _, obj in ipairs(getObjectsWithAllTags({nation, 'cardholder'})) do
        if obj.value == 1 then rack = obj else racks[obj.value - 1] = obj end
    end
    local co = coroutine.create(function (resume)
        components.takeObject({
            position = rack.positionToWorld({0, 0, 0.7075}) + vector(0, 0.4, 0),
            callback_function = |obj| coroutine.resume(resume, obj)
        })
        local deck = coroutine.yield()
        local max, points, card, prev, last = #deck.getObjects(), {}
        if state.scenario ~= 'global' then for i = max, 1, -1 do if not Map.regions[prefix .. i] then deck.takeObject({
            position = deck.getPosition() + vector(0, 0.5, 0), smooth = false,
            index = i - 1, callback_function = |obj| obj.destruct()
        }) end end end
        for i = 0, #deck.getObjects() - 1 do
            if i > 11 and i % 12 == 0 then rack = table.remove(racks, 1) end
            table.insert(points, rack.positionToWorld({0, 0, 0.7075 - 0.1425 * (i % 12)}) + vector(0, 0.08, 0))
        end
        for i = max, 1, -1 do
            local id = prefix .. i
            if Map.regions[id] then
                if not last then
                    card = Card(deck.takeObject({position = table.remove(points)}), id)
                    if prev then card.next, prev.prev = prev, card end
                    prev, last = card, deck.remainder
                    Wait.frames(|| coroutine.resume(resume), 5)
                    coroutine.yield()
                else card = Card(last, id) end
                Cards[id], Map.regions[id].card = card, card
                card.setName(card:colorizedName())
        end end
        Cards[nation].first, card.next, prev.prev = card, prev, card
        card.setLock(true)
        card.translate(vector(0, 0.12, 0))
        Promise.condition(|| not prev.isSmoothMoving()):skip(3):next(|| card.setLock(false)):when(|| card.resting):next(function ()
            Cards[nation].origin = {position = card.getPosition(), rotation = card.getRotation()}
            p:resolve()
        end)
    end)
    coroutine.resume(co, co)
    return p
end

function Setup.filterCards(deck, prefix)
    local removed = 1
    for i = 1, #deck.getObjects() do if not Map.regions[prefix .. i] then
        deck.takeObject({
            position = deck.getPosition() + vector(0, 0.5, 0), smooth = false,
            index = i - removed, callback_function = |obj| obj.destruct()
        })
        removed = removed + 1
    end end
end

function Setup.commands(components, nation)
    local forward, right = components.getTransformForward(), components.getTransformRight() * 1.273
    local position = components.getPosition() - forward + right * 5.5 + vector(0, 1, 0)
    local commands, ps, co = {}, {}
    Commands[nation] = {}
    for i, command in ipairs(components.getObjects()) do
        ps[i] = Promise()
        local id = tonumber(command.name:match(' (%d+)%a%a '))
        local entry = {index = i - 1, id = id, data = CommandSetup[nation][id]}
        if not (entry.data and Map.regions[entry.data.region]) then entry.data, entry.stash = nil, true end
        table.insert(commands, entry)
    end
    table.sort(commands, |a, b| (a.stash ~= b.stash and a.stash) or (a.stash == b.stash and a.index > b.index))
    coroutine.resume(coroutine.create(function () for i, entry in ipairs(commands) do
        local resume = coroutine.running()
        local p, loaded, pos = ps[i], Promise()
        if entry.stash then
            pos = Commands.trays[nation][entry.id < 10 and 'fleet' or entry.id < 20 and 'air' or 'army'].getPosition()
            pos = pos + vector(math.random() * 3 - 1.5, math.random() * 2 + 3, math.random() * 3 - 1.5)
        else
            pos = Map.positionToWorld({entry.data.position.x, 0.62, entry.data.position.z})
            for _, count in pairs(entry.data.units) do pos = pos + vector(0, 0.21, 0) * count end
        end
        components.takeObject({
            position = pos, index = entry.stash and entry.index or nil,
            callback_function = function (obj) Promise.condition(|| not obj.loading_custom):next(function ()
                local command = Command(obj)
                command.setTags({'command', nation})
                Commands[nation][command.id] = command
                if not entry.stash then command.setLock(true) end
                loaded:resolve(command)
        end) end})
        if entry.stash then loaded:next(|command| command:updateContextMenu()):next(p) else
            Wait.frames(|| coroutine.resume(resume), nation == 'japan' and 20 or 25)
            Promise.all(loaded,
                Units:buildStack(entry.data.units, pos:setAt('y', 6.74), components.getRotation())
            ):next(function (command, ...)
                command.setLock(false)
                return command, ...
            end):skip(20):next(|command, ...| command:attach({...})):next(p)
            coroutine.yield()
    end end end))
    return Promise.all(ps)
end

function Setup.hotspots()
    if Map.regions.j25 then Bags.hotspot.takeObject({
        position = Map.positionToWorld({-6.58, 0.7, -2.22}), rotation = {0, 270, 180},
        callback_function = function (obj) Map.regions.j25.hotspot = Hotspot(obj, 'j25') end
    }) end
end

function Setup.zoneEvents()
    tryObjectEnterContainer = |container, obj| not (obj.type == 'Card' and container.type == 'Card')
    function onObjectEnterScriptingZone(zone, obj)
        if obj.type == 'Card' then
            zone = Cards[zone.guid]
            if zone then zone:add(Cards[obj.guid]) end
        elseif state.phase == 4 then Battle.diceHandler(zone, 1) end
    end
    function onObjectLeaveScriptingZone(zone, obj)
        if obj.type == 'Card' then
            zone = Cards[zone.guid]
            if zone then zone:remove(Cards[obj.guid]) end
        elseif state.phase == 4 then Battle.diceHandler(zone, -1) end
    end
end

----#include phases/setup
----#include phases/economy
Economy = Phase()

function Economy:main()
    state.phase, state.step = 1, 0
    HUD.updateTracker('Tallying resource income', '1 - Direct National Economy')
    HUD.resetStatus()
    HUD.open('resources')
    for i, nation in turnOrder() do if i > state.step then
        state.step = i
        self:resourceIncome(nation)
        HUD.updateStatus(nation, true)
        Wait.time(|| self.resume(), 0.5)
        coroutine.yield()
    end end
    self.resume = nil
end

function Economy:resourceIncome(nation)
    local totals = {oil = 0, iron = 0, osr = 0}
    for _, card in Cards[nation]:cards() do
        for resource, value in pairs(Map.regions[card.id]:income()) do
            totals[resource] = totals[resource] + value
    end end
    if nation == 'china' then totals.oil = nil end
    local msg = Nations[nation]:colorized()
    if Morale.stressZone(nation) < 5 then
        msg = msg .. ' gained '
        if (totals.oil or 0) + totals.iron + totals.osr > 0 then
            Resources[nation]:add(totals)
            for resource, value in pairs(totals) do if value > 0 then
                msg = string.format('%s%s %s, ', msg, string.colorize(value, resource), resource)
            end end
            msg = msg:sub(1, -3)
        else msg = msg .. 'no resources' end
    else msg = msg .. ' cannot gain resources due to [ff4040]economic collapse[-]' end
    alert(msg)
end

----#include phases/economy
----#include phases/planning
Planning = Phase()

function Planning:main()
    if state.phase >= 2 then
        for nation, orders in pairs(Orders) do orders:restoreOrders() end
        if state.phase > 2 then self.resume = nil return end
    else state.phase, state.step = 2, 0 end
    HUD.updateTracker('Write orders and bids', '2 - Strategic Planning', 'orders')
    HUD.resetStatus()
    if state.step < 2 then
        local readied = {}
        for nation, orders in pairs(Orders) do
            readied[nation] = false
            orders:writeOrders(|...| self.resume(...), Morale.stressZone(nation) > 3, state.step == 1)
            if state.scenario == 'global' and not state.pact_broken then orders.UI.setAttribute('pact', 'interactable', true) end
        end
        state.step = 1
        Phase.readyLoop(readied)
    end
    self:setTurnOrder(self:revealBids())
    for i, nation in turnOrder() do
        UI.setAttribute('tracker' .. i, 'image', nation)
        if nation ~= 'china' and Orders[nation].bid > 0 then Resources[nation]:add({oil = -Orders[nation].bid})
        else Resources[nation]:updateUI() end
    end
    HUD.updateTurn()
    HUD.resetStatus()
    self.resume = nil
end

function Planning:revealBids()
    HUD.updateTracker('Reveal bids')
    HUD.resetStatus()
    local bids = {}
    for nation, orders in pairs(Orders) do
        if nation ~= 'china' then
            orders.UI.setAttribute('bid', 'visibility', '')
            bids[nation] = orders.bid
            broadcastToAll(string.format('%s bid %s oil', Nations[nation]:colorized(), string.colorize(bids[nation], 'oil')))
        else bids[nation] = 0 end
        HUD.updateStatus(nation, bids[nation], Color.oil)
        Wait.time(|| self.resume(), 0.5)
        coroutine.yield()
    end
    return bids
end

function Planning:setTurnOrder(bids)
    state.step = 2
    HUD.updateTracker('Establish turn order', nil, 'turn_order')
    local order, spots, total, token = {}, {}, 0
    for nation, bid in pairs(bids) do
        Tokens.turn[nation].setLock(true)
        table.insert(order, {bid = bid + math.random(), nation = nation, turn = turnOrder[nation]})
        total = total + 1
    end
    table.sort(order, |a, b| a.bid < b.bid)
    for i = 1, #order do spots[i] = Map.positionToWorld(Map.snaps[i].position) end
    onObjectDrop = function (_, obj) if obj.guid == token.guid then Wait.frames(function () for i = 1, total do
        if spots[i] and obj.getPosition():setAt('y', spots[i].y) == spots[i] then self.resume(i) break end
    end end, 5) end end
    while #order > 0 do
        local data = table.remove(order)
        token = Tokens.turn[data.nation]
        HUD.updateTurn(data.nation, data.turn)
        setGlow(token)
        token.setLock(false)
        local prev, spot = token, coroutine.yield()
        stopGlow(token)
        Wait.condition(|| prev.setLock(true), || prev.resting)
        HUD.updateStatus(data.nation, ({'①', '②', '③', '④', '⑤', '⑥', '⑦'})[spot], Color.white, nil, data.turn)
    end
    onObjectDrop = nil
end

----#include phases/planning
----#include phases/movement
Movement = Phase()

function Movement:main()
    if state.phase < 3 then
        state.phase, state.step = 3, 0
        for _, region in pairs(Map.regions) do if region.hotspot then
            region.hotspot.flip()
            region.hotspot.setTags({'active'})
        end end
        Commands:verifyStacks():delay(1):next(|| self.resume())
        coroutine.yield()
    end
    if state.phase == 3 then
        HUD.updateTracker('Resolve movement orders', '3 - Movement Operations', 'movement')
        if state.step < #turnOrder.get() * 10 then
            UI.show('movement')
            UI.show('orders-highlight')
        end
        for i = 1, 7 do for j = 1, 9 do UI.setAttribute('order' .. i .. j, 'active', false) end end
        HUD.open('orders')
        self.rails = {}
        for _, nation in turnOrder() do self.rails[nation] = Morale.stressZone(nation) < 3 end
    end
    for i, nation in turnOrder() do if state.phase == 3 and state.step < i * 10 then
        self.commands = Commands:byRegion()
        Orders[nation]:resolveMovement(state.step % 10)
        state.step = i * 10
    else Orders[nation]:resolveMovement(9) end end
    UI.hide('movement')
    UI.hide('confirm-panel')
    UI.hide('cancel-panel')
    UI.hide('orders-highlight')
    if state.phase == 3 then self:deployCarrierFighters() end
    self.resume = nil
end

function Movement:evaluateMove(nation, command, target)
    local is_axis, paths, partial_pin = Nations[nation]:isAxis(), {}
    if command.memo == 'landing' or command.memo == nil then return 'invalid' end
    local region = Map.regions[command.memo]
    debug('Checking for valid path from ', region.id, ' to ', target.id)
    if command.id > 19 and not (region.is_sea and target.is_sea) then
        paths = self:armyMovement(nation, region, target)
    elseif command.id > 9 then paths = self:airMovement(nation, region, target)
    else paths = self:fleetMovement(nation, region, target) end
    debug('Found ', #paths, ' valid path(s)')
    if #paths == 0 then return 'invalid' end
    if command.id < 10 then
        local free = self.netPin(nation, region:commands(), 'fleet')
        if free <= 0 then return 'pinned' elseif free < command.units() then partial_pin = true end
    elseif command.id > 19 then
        if not region.is_sea then
            local free = self.netPin(nation, region:commands(), 'army')
            if free <= 0 then return 'pinned' elseif free < command.units() then partial_pin = true end
        elseif target.is_sea or Nations[nation].side ~= Nations[target:owner()].side then
            if self.netPin(nation, region:commands(), 'fleet') < 0 then return 'pinned' end
    end end
    if state.scenario == 'global' and not state.pact_broken and command.id > 9 then
        local ally, other, has_path = is_axis and 'japan' or 'ussr', is_axis and 'ussr' or 'japan', false
        for _, path in ipairs(paths) do
            local blocked = false
            for _, waypoint in ipairs(path) do blocked = blocked or Map.regions[waypoint]:owner() == other end
            has_path = has_path or not blocked
        end
        if not has_path and (nation == ally or region:owner() == ally) then return 'pact' end
    end
    if target:owner() == 'neutral' and command.id > 19 and (is_axis or not target.allied) then return 'neutral' end
    if partial_pin then return 'partial' end
end

function Movement:fleetMovement(nation, region, target, escaped)
    debug('Checking fleet pathing')
    return Map:search(region.id, |_, to| Map.regions[to:match('%a%d+')].is_sea ~= nil, function (d, from, to, v)
        local id, flag = to:match('(%a%d+)(.?)')
        if flag == '@' and not self.canalCheck(nation, from, id) then return false end
        if id == target.id then table.insert(v.result, d == 1 and {id} or {from, id}) end
        return d < 2
    end, {})
end

function Movement.canalCheck(nation, from, to)
    for _, id in ipairs(Map.regions[from].canals[to]) do
        local region = Map.regions[id]
        local owner = region and region:owner() or Nations[id:sub(1,1)]
        if owner == 'neutral' then if Nations[nation]:isAxis() or not region.allied then return false end
        elseif Nations[owner].side ~= Nations[nation].side then return false end
    end
    return true
end

function Movement:airMovement(nation, region, target)
    debug('Checking air pathing')
    return Map:search(region.id, |d, to| d == 0 or not to:match('%^'), function (d, from, to, v)
        local id, flag = to:match('(%a%d+)(.?)')
        if d == 1 and id == target.id then table.insert(v.result, {id})
        elseif d == 2 and id == target.id then table.insert(v.result, {from, id}) end
        if d > 1 or flag == '^' then return false else return true end
    end, {})
end

function Movement:armyMovement(nation, region, target)
    debug('Checking army pathing')
    local rail_ok = not region.is_sea and Nations[nation].side == region:side()
    debug('Rail movement', rail_ok and ' ' or ' in', 'eligible')
    return Map:search(region.id, function (d, to)
        local flag = to:match('%a%d+(.?)')
        if flag == '^' then return false else return flag == '#' or d < 2 end
    end, function (d, from, to, v)
        debug('Checking path step ', from, ' --> ', to)
        local id, flag = to:match('(%a%d+)(.?)')
        if v[id] or d > 1 and (Map.regions[from].is_sea ~= Map.regions[id].is_sea) then return false
        elseif id == target.id and d == 1 then
            table.insert(v.result, {id})
            v[id] = true
        elseif Map.regions[id].is_sea or rail_ok and flag == '#'
        and not v[target.id] and self:railCheck(nation, Map.regions[id]) then
            if id == target.id then
                table.insert(v.result, Map.regions[id].is_sea and {from, id} or {id})
            else v[id] = true end
            return id ~= target.id
        end
        return false
    end, {})
end

function Movement:railCheck(nation, region) return
    region:owner() ~= 'neutral' and Morale.stressZone(region:owner()) < 3
    and not region.bombs and Nations[nation].side == region:side()
    and not (self.commands[region.id] and self.commands[region.id][Nations[nation].other].army)
end

function Movement.netPin(nation, commands, force)
    debug('Checking for ', force, ' pinning')
    local totals, is_axis = {axis = 0, allies = 0, japan = 0, ussr = 0}, Nations[nation]:isAxis()
    for side, forces in pairs(commands) do for _, command in ipairs(forces[force] or {}) do
        local n, count = command.nation, command.units()
        if not state.pact_broken and n == 'japan' then totals.japan = totals.japan + count
        elseif not state.pact_broken and n == 'ussr' then totals.ussr = totals.ussr + count
        else totals[side] = totals[side] + count end
    end end
    debug('Unit counts: axis ', totals.axis, ', allies ', totals.allies, ', japan ', totals.japan, ', ussr ', totals.ussr)
    if state.scenario ~= 'global' or state.pact_broken or nation == 'japan' or nation == 'ussr' then
        return (totals[nation] or 0) + (totals.allies - totals.axis) * (is_axis and -1 or 1)
    elseif is_axis then return math.min(totals.japan - totals.allies, 0) + totals.axis - totals.ussr
    else return math.min(totals.ussr - totals.axis, 0) + totals.allies - totals.japan end
end

function Movement.breakPact(nation)
    if not state.pact_broken then if nation then
        state.pact_broken = Nations[nation]:isAxis() and 'japan' or 'ussr'
        Morale:addStress(state.pact_broken, 6)
        broadcastToAll(Nations[state.pact_broken]:colorized() .. ' has broken the Soviet-Japanese Non-Aggression Pact! (+6 stress)')
    else
        state.pact_broken = true
        broadcastToAll('The Soviet-Japanese Non-Aggression Pact is no longer in force!')
    end end
    Orders.japan.UI.hide('pact')
    Orders.ussr.UI.hide('pact')
end

function Movement.invadeNeutral(invader, region)
    debug('Neutral ', region.id, ' was invaded by ', invader)
    local commands, other, min, defender = Commands:byRegion(), Nations[invader].other
    for _, nation in ipairs(Map:search(region.id, |_, to| to:match('%a%d+(.?)') ~= '^', function (d, _, to, v)
        local id = to:match('%a%d+')
        if v[id] or v.d and d > v.d then return false else v[id] = true end
        debug('Checking commands in ', id)
        if commands[id] then for _, command in ipairs(commands[id][other].army or {}) do
            local nation = command.nation
            if state.pact_broken or (invader ~= 'japan' or nation ~= 'ussr') and (invader ~= 'ussr' or nation ~= 'japan') then
                table.insert(v.result, nation)
                v.d = d
        end end end
        return true
    end, {})) do if turnOrder[nation] < (min or 8) then defender, min = nation, turnOrder[nation] end end
    debug(defender, ' assumes control of ', region.id)
    broadcastToAll(string.format('%s invades %s! (+1 stress)\n%s has assumed control of the defense forces',
        Nations[invader]:colorized(), region:colorizedName(), Nations[defender]:colorized()))
    Morale:addStress(invader, 1)
    local card_p, units_p, flag_p = Promise(), Promise(), Promise()
    local deck = Cards.neutral
    for _, card in ipairs(deck.getObjects()) do if card.name:find(region:displayID()) then deck.takeObject({
        index = card.index, position = deck.getPosition() + vector(0, 3, 0),
        callback_function = function (obj)
            region.card = Card(obj, region.id)
            Cards[region.id] = region.card
            region.card:giveTo(defender):next(card_p)
    end}) break end end
    local pos = Map.positionToWorld((region.centroid or region.circle.c):copy():setAt('y', 0.6))
    if region.army then Units:buildStack(region.army, pos):next(function (...)
        pos = pos + vector(0, 0.21 * #{...}, 0)
        units_p:resolve(...)
    end) else units_p:resolve() end
    units_p:next(function (...)
        local units = {...}
        Bags.flag[defender].takeObject({position = pos, callback_function = function (obj)
            region.flag = obj
            if #units == 0 then flag_p:resolve() else
                local army = Standing(region.flag, true)
                Commands.standing[region.id] = army
                army:attach(units):next(flag_p)
    end end}) end)
    return Promise.all(card_p, flag_p)
end

function Movement:deployCarrierFighters()
    HUD.updateTracker('Carrier fighter movement', nil, 'cfighters')
    local readied = {}
    if state.step == #turnOrder.get() * 10 then
        for nation, commands in pairs(Commands) do for i = 1, 9 do
            if not commands[i] then break elseif commands[i].units.carrier > 0 then
                local rotation, bump = commands[i].getRotation(), 0
                if Nations[nation]:isAxis() then rotation, bump = rotation + vector(0, 0, 180), 0.22 end
                readied[nation] = false
                for j = 1, commands[i].units.carrier do
                    Wait.frames(|| self.resume(), 3)
                    coroutine.yield()
                    Bags.cfighter.takeObject({
                        position = commands[i].getPosition() + vector(0, j * 0.25 + bump, 0),
                        rotation = rotation,
                        callback_function = function (obj)
                            setGlow(obj, Color[nation])
                            obj.memo = nation
                            table.insert(Commands.cfighters, Command(obj, nation))
        end}) end end end end
        state.step = state.step + 1
    else for _, cfighter in ipairs(Commands.cfighters) do
        readied[cfighter.nation] = false
        setGlow(cfighter, Color[cfighter.nation])
    end end
    for _, nation in turnOrder() do if readied[nation] == false then
        HUD.updateStatus(nation, false)
        Orders[nation]:enableReady(|...| self.resume(...))
    else HUD.updateStatus(nation, true) end end
    Phase.readyLoop(readied, next(readied) == nil, function (nation, ready)
        for _, cfighter in ipairs(Commands.cfighters) do if cfighter.nation == nation then
            if ready then stopGlow(cfighter) else setGlow(cfighter, Color[nation]) end
    end end end)
end

----#include phases/movement
----#include phases/combat
-- TODO:
---- 1. Dependencies between combats: raids spawning or canceling, change in port advantage, etc.
---- 2. Multiple battles due to pact, or due to ownership reversion

Combat = Phase()

function Combat:main()
    HUD.updateTracker('Resolve hotspots', '4 - Combat Operations', 'combat')
    HUD.resetStatus()
    local commands
    if state.phase < 4 then
        HUD.close('orders')
        if state.scenario == 'global' and not state.pact_broken then
            debug('Checking for Article 4 violations')
            local destroyed = {}
            for nation, other in pairs{japan = 'ussr', ussr = 'japan'} do for id, command in pairs(Commands[nation]) do if id > 19 then
                local region = command:region()
                if region and Map.regions[region]:owner() == other then table.insert(destroyed, command) end
            end end end
            if #destroyed > 0 then
                for i = 1, #destroyed do destroyed[i] = destroyed[i]:destroy() end
                Promise.all(destroyed):next(|| self.resume())
                coroutine.yield()
        end end
        debug('Placing new hotspots')
        commands = Commands:byRegion()
        local ps = {}
        for id, commands in pairs(commands) do
            local region, action = Map.regions[id], Hotspot.action({region = id}, commands)
            if action then
                debug(id, ' is a ', action, ' hotspot')
                if not region.hotspot then
                    debug('Placing new hotspot in ', id)
                    local p, pos = Promise(), region.centroid or region.circle.c
                    table.insert(ps, region:placeHotspot():next(function (obj)
                        obj.addTag('active')
                        Wait.condition(|| obj.setRotationSmooth({0, region:angle(), 0}), || obj.resting)
                    end))
                else region.hotspot.UI.show('region') end
            else
                debug('No hotspot action in ', id)
                for side, forces in pairs(commands) do for _, command in ipairs(forces.air or {}) do
                    if command.hasTag('landing') then table.insert(ps, command:placeArrow()) end
                end end
                if region.hotspot then
                    debug('Removing invalid hotspot')
                    table.insert(ps, region:removeHotspot())
        end end end
        state.phase, state.step = 4, #turnOrder.get()
        if #ps > 0 then
            Promise.all(ps):next(|| self.resume())
            coroutine.yield()
    end else state.step = state.step == 1 and #turnOrder.get() or state.step - 1 end
    debug('Setting up combat HUD')
    commands = commands or Commands:byRegion()
    local regions, combatants = {}, {}
    for id, region in pairs(Map.regions) do if region.hotspot then
        table.insert(regions, {angle = (160 - region:angle()) % 360, region = region})
        combatants[id] = region.hotspot:getCombatants(commands[id])
    end end
    table.sort(regions, |a, b| a.angle < b.angle)
    for i, data in ipairs(regions) do
        local hotspot = data.region.hotspot
        hotspot.hud = i
        debug('Displaying hotspot ', i)
        local clr, region, name = data.region:colorizedName():match('%[(%w+)%](%a%-?%d+)%b[](.*)')
        UI.setValue('combat-id' .. i, region)
        UI.setAttribute('combat-id' .. i, 'color', '#' .. clr)
        if name ~= '' then
            UI.setValue('combat-name' .. i, name:sub(4))
            UI.setAttribute('name-panel' .. i, 'color', '#000000b0')
        else UI.setAttribute('name-panel' .. i, 'color', 'clear') end
        local total = {axis = 0, allies = 0}
        for nation, _ in pairs(combatants[data.region.id]) do
            local side = Nations[nation].side
            total[side] = total[side] + 1
            UI.setAttributes('combatants' .. i .. '-' .. side .. total[side], {image = nation, active = true})
        end
        for side, count in pairs(total) do
            debug(count, ' ', side, ' combatants')
            if count < 3 then for j = count + 1, 3 do UI.hide('combatants' .. i .. '-' .. side .. j) end end
            UI.setAttribute('combatants' .. i .. '-' .. side, 'padding', 29 - 9 * count .. ' ' .. 29 - 9 * count .. ' 1 1')
        end
        if hotspot.hasTag('inactive') then HUD.Combat:done(i)
        elseif hotspot.hasTag('busy') then HUD.Combat:active(i)
        else HUD.Combat:passive(i) end
        UI.show('hotspot' .. i)
    end
    UI.setAttributes('combat', {height = 26 + 24 * #regions, offsetXY = '0 ' .. -12 * (24 - #regions)})
    Wait.frames(function () if #regions < 24 then for j = #regions + 1, 24 do UI.hide('hotspot' .. j) end end end, 1)
    HUD.open('combat')
    state.battle_queue = {}
    local resume, all_clear = coroutine.wrap(function () while self:nextTurn() do coroutine.yield() end end)
    tryObjectRandomize = |obj, player| self:tryRandomize(obj, player, resume)
    resume()
    repeat
        all_clear = true
        for _, region in pairs(Map.regions) do if region.hotspot and not region.hotspot.hasTag('inactive') then
            all_clear = false break
        end end
    until all_clear or coroutine.yield()
    self.resume, state.battle_queue, tryObjectRandomize = nil
end

function Combat:tryRandomize(obj, player, resume)
    local hotspot
    if obj ~= nil and obj.getName() == 'hotspot' then
        for _, region in pairs(Map.regions) do if region.hotspot and region.hotspot.guid == obj.guid then
            if obj.hasTag('raid') then region.hotspot.resume()
            elseif obj.hasTag('active') and region.hotspot:getCombatants()[turnOrder[state.step]] then
                if player == 'Black' or Nations[turnOrder[state.step]].side == Nations:byPlayer(player).side then
                    if region.hotspot:activate() then resume() end
        end end end end
        return false
    end
    return true
end

function Combat:nextTurn()
    debug('Advancing to next combat turn')
    local turn_order, next_turn, counts, nation = turnOrder.get(), state.step, {}
    HUD.updateStatus(turn_order[state.step])
    for id, commands in pairs(Commands:byRegion()) do
        local hotspot = Map.regions[id].hotspot
        if hotspot and hotspot.hasTag('active') then for nation, _ in pairs(hotspot:getCombatants(commands)) do
            counts[nation] = (counts[nation] or 0) + 1
    end end end
    repeat
        next_turn = next_turn % #turn_order + 1
        nation = turn_order[next_turn]
    until counts[nation] or next_turn == state.step
    HUD.updateTurn(nation)
    if counts[nation] then HUD.updateStatus(nation, counts[nation], nil, 'hotspot') else HUD.updateStatus(nation) end
    state.step = next_turn
    return counts[nation] ~= nil
end

-- Hotspot helper functions

function Combat.nationOnly(nation, ...)
    local commands = {}
    for _, list in pairs({...}) do if list then
        for _, item in ipairs(list) do table.insert(commands, item) end
    end end
    for _, command in ipairs(commands) do if command.nation ~= nation then return false end end
    return true
end

function Combat.convoyOnly(nation, convoys)
    local owner
    for _, cluster in ipairs(convoys) do for origin, _ in pairs(cluster) do
        owner = Map.regions[origin:find('-') and origin:match('^%w+') or origin]:owner()
        if owner ~= nation then return false end
    end end
    return true
end

-- -- Combat actions

Combat.Action = {__call = function (T, hotspot, commands)
    local t = {hotspot = hotspot}
    setmetatable(t, {__index = T})
    t.resume = coroutine.wrap(|...| t:main(...))
    hotspot.resume = t.resume
    t.resume(commands)
end, __index = Combat}
setmetatable(Combat.Action, {__call = function (T)
    local t = {}
    setmetatable(t, T)
    return t
end})

----#include combat/battle
Combat.Battle = Combat.Action()

function Combat.Battle:main(commands)
    local region, board = Map.regions[self.hotspot.region]
    local mode = region.is_sea and 'sea' or 'land'
    setGlow(self.hotspot, Color.red)
    repeat
        if not rawget(Battle.left, 'combat') then board = Battle.left end
        if not rawget(Battle.right, 'combat') and (not board or Battle.right:mode() == mode) then board = Battle.right end
        if board == nil then
            table.insert(state.battle_queue, region.id)
            coroutine.yield()
        end
    until board ~= nil
    board:initializeCombat(self)
    local aux_data, initiative, i = board:placeUnits(commands), {}, 0
    Commands.standing[region.id] = nil
    board:setAdvantages()
    for side, forces in pairs(commands) do
        initiative[side] = 0
        for force, commands in pairs(forces) do for _, command in ipairs(commands) do
            initiative[side] = math.max(initiative[side], turnOrder[command.nation])
    end end end
    initiative = initiative.axis > initiative.allies and 'allies' or 'axis'
    debug(initiative .. ' has initiative')
    for _, side in ipairs{initiative, Nations.other[initiative]} do
        board.UI.setAttributes(side .. '-confirm', {text = 'Ready', textColor = 'white'})
        board.UI.show(side .. '-confirm-panel')
        debug('Waiting for ready button...')
        local glow = Wait.time(function ()
            local tint = Color.black:lerp(color(0.4, 0.4, 0.4), (i < 10 and i or 20 - i) / 10)
            i = (i + 1) % 20
            board.UI.setAttribute(side .. '-confirm-panel', 'color', tint:toXml(false))
        end, 0.08, -1)
        board:lockStances(coroutine.yield())
        board.UI.setAttribute(side .. '-confirm', 'interactable', false)
        Wait.stop(glow)
        board.UI.setAttribute(side .. '-confirm-panel', 'color', '#404040')
    end
    board:stage('air', initiative)
    board.zones_active = false
    if mode == 'land' then
        board:stage('bomb', initiative)
        board:stage('ground', initiative)
    else board:stage('surface', initiative) end
    board:repairs()
    Promise.all(board:replaceCommands(), board:losses()):next(function (data)
        local commands, extras = data.forces, data.extras
        stopGlow(self.hotspot)
        for side, forces in pairs(commands) do if forces.air then for i = #forces.air, 1, -1 do
            if forces.air[i].getName() == 'cfighter' and forces.air[i].memo == nil then table.remove(forces.air, i) end
        end end end
        if mode == 'sea' and aux_data then for side, force in pairs(aux_data) do commands[side].army = force end end
        if not extras then self.resume(commands) else if mode == 'sea' then
            for _, unit in ipairs(extras) do
                unit.removeTag('escaped')
                unit.addContextMenuItem('Form dived command', || self.diveSub(region, unit, extras))
            end
            Wait.condition(|| self.resume(Commands:region(region.id)), function ()
                for i = #extras, 1, -1 do if extras[i].obj == nil then table.remove(extras, i) end end
                return #extras == 0
        end) elseif #extras == 1 and extras[1].getName() == 'fighter' then
            Commands:getNew(
                extras[1].nation, 'air', extras[1].getPosition() + vector(0, 0.21, 0), extras[1].getRotation()
            ):skip(3):next(|c| c:attach(extras)):next(|| self.resume(Commands:region(region.id)))
        else
            region.flag.setPositionSmooth(region.flag.getPosition() + vector(0, #extras * 0.21, 0))
            Promise.condition(|| not region.flag.isSmoothMoving()):next(function ()
                local army = Standing(region.flag)
                Commands.standing[region.id] = army
                return army:attach(extras)
            end):next(|| self.resume(Commands:region(region.id)))
    end end end):when(|| board.UI.getAttribute('status-panel', 'active') == 'false'):next(function ()
        if #(state.battle_queue or {}) > 0 then Map.regions[table.remove(state.battle_queue, 1)].hotspot.resume() end
    end)
    board:reset()
    self:debrief(coroutine.yield(), mode == 'land' and aux_data or nil)
end

function Combat.Battle.diveSub(source, sub, subs)
    local dest = Map.regions[Map:getRegion(sub)]
    if source.id ~= dest.id then for _, adj in ipairs(source.adjacent) do
        if adj:match(dest.id) and (adj:sub(-1) ~= '@' or Movement.canalCheck(nation, source.id, dest.id)) then
            local units = {}
            for i = #subs, 1, -1 do if subs[i].obj == nil then table.remove(subs, i)
            elseif subs[i].nation == sub.nation and Map:getRegion(subs[i]) == dest.id then table.insert(units, subs[i]) end end
            local pos, rot = sub.getPosition() + vector(0, #units * 0.21, 0), sub.getRotation()
            Commands:getNew(sub.nation, 'fleet', pos, rot):next(function (command)
                local p = Promise()
                Bags.convoy_dive.takeObject({
                    position = pos + vector(0, 0.42, 0), rotation = rot:setAt('z', 180),
                    callback_function = |obj| p:resolve(command, obj)
                })
                return p
            end):skip(10):next(function (command, token)
                command.addTag('escaped')
                command.jointTo(token, {type = 'Fixed'})
                token.interactable = false
                command:attach(units)
            end)
    end end end
end

----#include combat/battle
----#include combat/uncontested
Combat.Uncontested = Combat.Action()

function Combat.Uncontested:main(commands)
    local region, combatants = Map.regions[self.hotspot.region]
    if region.collapsed and region:owner() == Nations[region.id:sub(1, 1)] then
        for side, forces in pairs(commands) do if forces.army then
            combatants = {}
            for _, command in ipairs(forces.army) do
                local nation = command.nation
                if not combatants[nation] then table.insert(combatants, nation) end
                combatants[nation] = true
        end break end end
    elseif not region.is_sea then
        self.hotspot.resume = self.resume
        local side = Nations[region:owner()].other
        if commands[side].air then
            local bombers = 0
            for _, command in ipairs(commands[side].air) do bombers = bombers + command.units.bomber end
            if bombers > 0 then
                local targets = region:bombTargets()
                if next(targets) then self:bombing(bombers, targets) end
        end end
        if commands[side].army then
            combatants = {}
            for _, force in pairs(commands[side]) do for _, command in ipairs(force) do
                local nation = command.nation
                if not combatants[nation] then table.insert(combatants, nation) end
                combatants[nation] = true
            end end
            self:garrison(commands[side].army)
            if #commands[side].army == 0 then commands[side].army = nil end
    end end
    self:debrief(commands, combatants)
end

function Combat.Uncontested:bombing(bombers, targets)
    self.hotspot:bombButtons(bombers, targets)
    bombers = tonumber(coroutine.yield())
    self.hotspot.UI.hide('bombers')
    if bombers > 0 then
        debug('Resolving strategic bombing in ', self.hotspot.region, ' with ', bombers, ' bombers')
        self.hotspot.UI.show('targets')
        local offset = Map:radialVector(self.hotspot.getPosition()) * math.sqrt(2)
        local shift, positions = offset:copy():rotateOver('y', -90), {}
        local anchor = self.hotspot.getPosition() + vector(0, 1.8, 0) + offset  - shift * 2.5
        for i = 1, 4 do table.insert(positions, anchor + shift * i) end
        for _ = 1, bombers do
            debug('Rolling next bomber')
            Bags.dice:roll(positions):delay(1):next(|dice| dice:arrange(positions[1], positions[4])):next(|dice| self.resume(dice))
            self:assignBombs(coroutine.yield(), targets, self.hotspot.UI)
        end
        self.hotspot.UI.hide('targets')
    end
end

function Combat.Uncontested:garrison(army)
    local pos, max_y = self.hotspot.getPosition(), 0
    for _, hit_object in ipairs(Physics.cast({
        origin = pos + vector(0, 5, 0), direction = {0, -1, 0}, max_distance = 5, type = 3,
        size = {2.5, 1, 1.5}, orientation = {0, Map:rotationToCenter(pos) + 180, 0}
    })) do max_y = math.max(max_y, hit_object.point.y) end
    local anchor = pos:setAt('y', max_y + math.sqrt(2) / 2)
    Bags.dice:roll(Dice.positions(2, anchor, Map:radialVector(anchor))):delay(1):next(|dice| self.resume(dice))
    local dice, pair = coroutine.yield()
    for i, die in ipairs(dice) do if dice[i]:getColor() == 'black' then pair = dice[3 - i]:getColor() end end
    if dice[1]:getColor() == dice[2]:getColor() then pair = dice[1]:getColor() end
    for _, die in ipairs(dice) do fadeOut(die) end
    if pair then
        local p, targets, unique = Promise(), {}
        for _, command in ipairs(army) do for unit, t in pairs(Units) do
            if t.force == 'army' and command.units[unit] > 0 and (pair == 'black' or pair == t.color) then
                debug('Found target: ', command.nation, ' ', unit)
                targets[unit] = targets[unit] or {}
                targets[unit][command.nation] = command
                if unique == nil then unique = {command = command, unit = unit}
                else unique = false end
        end end end
        if unique ~= nil then if unique == false then
            self.hotspot:hitButtons(targets)
            local nation, unit = coroutine.yield():match('(%a+)%-(%a+)')
            self.hotspot.UI.hide('hits')
            targets[nation][unit]:destroyUnit(unit):next(|c| self.resume(c))
        else unique.command:destroyUnit(unique.unit):next(|c| self.resume(c)) end
        local command = coroutine.yield()
        if command.units() == 0 then for i = #army, 1, -1 do
            if army[i].guid == command.guid then table.remove(army, i) break end
    end end end end
end

----#include combat/uncontested
----#include combat/raid
Combat.Raid = Combat.Action()

function Combat.Raid:main(commands)
    -- TODO: Check if hotspots in convoy regions are currently being resolved, then wait until they are done to proceed
    local region = Map.regions[self.hotspot.region]
    local raiders, clusters, targets = {}, {}, {}
    local axis = commands.axis.fleet or commands.axis.air
    debug('Resolving ', axis and 'axis' or 'allies', ' convoy raid in region ', region.id)
    for force, objs in pairs(commands[axis and 'axis' or 'allies']) do if force ~= 'army' then
        for _, obj in ipairs(objs) do table.insert(raiders, obj) end
    end end
    debug('Raid involves ', #raiders, ' commands')
    for _, cluster in ipairs(region:activeConvoys()[axis and 'allies' or 'axis']) do
        local resources = {}
        for origin, values in pairs(cluster) do
            local owner = Map.regions[origin:match('^%w%d+')]:owner()
            if origin:find('-') then for resource in Resources() do
                if values[resource] then resources[resource] = {[owner] = values[resource]} end
            end else for resource in Resources() do if values[resource] then
                local loss = math.min(Map.regions[origin]:income()[resource] or 0, values[resource])
                if loss > 0 then
                    resources[resource] = resources[resource] or {}
                    resources[resource][owner] = (resources[resource][owner] or 0) + loss
            end end end end
            table.insert(targets, {position = Map.positionToWorld({values.x, 0.6, values.z}), cluster = #clusters + 1})
        end
        table.insert(clusters, {resources = resources, raiders = {}})
    end
    debug('Raid involves ', #clusters, ' convoy clusters')
    if #clusters > 1 then
        local pids = {}
        for _, raider in ipairs(raiders) do self:updateTarget(raider, pids, function (command)
            self.setTarget(command, targets, clusters)
            debug('Updated raid target for ', command.guid)
        end, |command| command.setVectorLines()) end
        self.hotspot.addTag('raid')
        coroutine.yield()
        self.hotspot.removeTag('raid')
        UI.setValue('combat-status' .. self.hotspot.hud, '♦')
        debug('Confirming convoy raid in ', region.id)
        for _, pid in pairs(pids) do Wait.stop(pid) end
    else clusters[1].raiders = raiders end
    for _, cluster in ipairs(clusters) do for _, command in ipairs(cluster.raiders) do command.setVectorLines() end end
    for _, cluster in ipairs(clusters) do if #cluster.raiders > 0 then self:rollConvoyCluster(cluster) end end
    self:debrief()
end

function Combat.Raid:updateTarget(command, pids, set_fun, clear_fun)
    local fun, condition
    if command.getVectorLines() then fun, condition = clear_fun, || not command.resting
    else fun, condition = set_fun, || command.resting end
    pids[command.guid] = Wait.condition(function ()
        fun(command)
        self:updateTarget(command, pids, set_fun, clear_fun)
    end, condition)
end

function Combat.Raid.setTarget(command, targets, clusters)
    debug('Updating raid target for ', command.guid)
    local pos, distance, target = command.getPosition(), 1000
    for _, t in ipairs(targets) do if pos:distance(t.position) < distance then
        distance, target = pos:distance(t.position), t
    end end
    command.setVectorLines({{
        points = {vector(0, 0, 0), command.positionToLocal(target.position)},
        color = {0.9, 0.5, 0.2}, thickness = 0.1
    }})
    local moved = true
    debug('Checking if command changed targets')
    for i, cluster in ipairs(clusters) do
        for j, raider in ipairs(cluster.raiders) do if raider.guid == command.guid then
            moved = i ~= target.cluster
            if moved then table.remove(cluster.raiders, j) break end
        end end
        if i == target.cluster and moved then table.insert(cluster.raiders, command) end
    end
end

function Combat.Raid:rollConvoyCluster(cluster)
    debug('Rolling convoy cluster in region ', self.hotspot.region)
    local count, height, anchor = 0, 1, vector(0, 0, 0)
    for _, command in ipairs(cluster.raiders) do
        debug('Inspecting command ', command.guid)
        anchor = anchor + command.getPosition()
        if command.getName() == 'cfighter' then count = count + 1
        else count, height = count + command.units(), math.max(height, command.units()) end
    end
    debug('Found ', count, ' units raiding this cluster')
    anchor = (anchor * (1 / #cluster.raiders)):setAt('y', 7.75 + 0.21 * height)
    local hits, offset = {wild = {}}, Map:radialVector(anchor)
    Bags.dice:roll(Dice.positions(count, anchor, offset)):delay(1):next(|dice| self.resume(dice))
    for _, die in ipairs(coroutine.yield()) do
        local clr = die:getColor()
        if clr == 'red' and cluster.resources.oil and not hits.oil then hits.oil = die
        elseif clr == 'blue' and cluster.resources.iron and not hits.iron then hits.iron = die
        elseif clr == 'yellow' and cluster.resources.osr and not hits.osr then hits.osr = die
        elseif clr == 'black' then table.insert(hits.wild, die)
        else die.destruct() end
    end
    if #hits.wild > 0 then
        local missed = {}
        for resource in Resources() do if cluster.resources[resource] and not hits[resource] then
            table.insert(missed, resource)
            missed[resource] = true
        end end
        if #hits.wild < #missed then
            debug('Need to assign black dice')
            local offset = anchor - self.hotspot.getPosition()
            self.hotspot:raidButtons(missed, offset)
            for _, die in ipairs(hits.wild) do
                setGlow(die)
                local id = coroutine.yield()
                stopGlow(die)
                hits[id:match('%-(%a+)')] = die
                die:setColor(id:match('(%a+)%-'))
                self.hotspot.UI.hide(id)
            end
            self.hotspot:regionLabel()
        else
            debug('Black dice assigned automatically')
            for i, die in ipairs(hits.wild) do if i <= #missed then
                hits[missed[i]] = die
                die:setColor(Resources.Colors[missed[i]])
            else die.destruct() end end
    end end
    hits.wild, count = nil, 0
    for _, _ in pairs(hits) do count = count + 1 end
    if count > 0 then self:assessHits(count, hits, cluster, anchor) end
end

function Combat.Raid:assessHits(count, hits, cluster, pos)
    debug('Assessing convoy hits')
    local offset = Map:radialVector(pos):rotateOver('y', 90) * math.sqrt(2)
    pos = pos - offset * 0.5 * (count - 1)
    for resource in Resources() do if hits[resource] then
        hits[resource].setPositionSmooth(pos)
        pos = pos + offset
    end end
    Promise.condition(function ()
        for _, die in pairs(hits) do if die.isSmoothMoving() then return false end end
        return true
    end):skip(5):next(|| self.resume())
    coroutine.yield()
    local losses = {}
    for res, die in pairs(hits) do
        die.destruct()
        for nation, value in pairs(cluster.resources[res]) do
            local current, t = Resources[nation]:totals(), losses[nation] or {resources = {}, total = 0}
            t.resources[res] = -math.min(value, current[res])
            losses[nation], t.total = t, t.total - t.resources[res]
    end end
    for nation, loss in pairs(losses) do if loss.total > 0 then
        Resources[nation]:add(loss.resources)
        if state.options and state.options.take_her_down then Morale:sunkConvoys(nation, loss.total) end
        local msg = Nations[nation]:colorized() .. ' lost'
        for res, value in pairs(loss.resources) do msg = string.format('%s %s %s,', msg, string.colorize(-value, res), res) end
        msg = string.format('%s from convoy raid in %s', msg:sub(1, -2), Map.regions[self.hotspot.region]:colorizedName())
        alert(msg)
    end end
end

----#include combat/raid
----#include combat/debrief
function Combat:debrief(commands, combatants)
    self.commands = commands or Commands:region(self.hotspot.region)
    local naval = Map.regions[self.hotspot.region].is_sea
    if naval then self:checkTransports() end
    self:checkAirCommands()
    if not naval and combatants then self:checkControl(combatants) end
    local force = naval and 'fleet' or 'army'
    self.hotspot:finalize(self.commands.axis[force] and self.commands.allies[force])
end

function Combat:checkTransports()
    debug('Checking for unescorted transports')
    for side, other in pairs(Nations.other) do if self.commands[side].army and not self.commands[side].air then
        local sunk = self.commands[side].army
        if self.commands[other].air then
            if self.commands[side].fleet then for _, fleet in ipairs(self.commands[side].fleet) do
                if fleet.units() > fleet.units.submarine then sunk = nil break end
            end end
        elseif self.commands[side].fleet or self.commands[other].fleet == nil then sunk = nil end
        if sunk then
            debug('Destroying unescorted transports')
            self.commands[side].army = nil
            local ps = {}
            for _, command in ipairs(sunk) do table.insert(ps, command:destroy()) end
            Promise.all(ps):next(|| self.resume())
            coroutine.yield()
    end end end
end

function Combat:checkAirCommands()
    debug('Placing landing tags and removing carrier fighters')
    local ps, cfighters = {}, 0
    for _, forces in pairs(self.commands) do if forces.air then
        for _, command in ipairs(forces.air) do if command.getName() == 'cfighter' then
            table.insert(ps, command:stash())
            cfighters = cfighters + 1
        else debug('Placing landing arrow on ', command.guid) table.insert(ps, command:placeArrow()) end end
    end end
    if #ps > 0 then
        Promise.all(ps):next(|| self.resume())
        coroutine.yield()
        if cfighters > 0 then self.commands = Commands:region(self.hotspot.region) end
    end
end

function Combat:checkControl(combatants)
    local region = Map.regions[self.hotspot.region]
    debug('Checking for change of control in ', region.id)
    local owner, new_owner = region:owner()
    local collapsed = region.collapsed and owner == Nations[region.id:sub(1, 1)]
    local defender, invader = Nations[owner].side, Nations[owner].other
    if collapsed and not self.commands[invader].army then defender, invader = invader, defender end
    if self.commands[invader].army and not self.commands[defender].army then
        if region.occupied and Nations[region.occupied].side == invader then
            new_owner = region.occupied
        elseif Nations[Nations[region.id:sub(1, 1)]].side == invader then
            new_owner = Nations[region.id:sub(1, 1)]
        else
            local remaining = {}
            for _, command in ipairs(self.commands[invader].army) do
                if not remaining[command.nation] then table.insert(remaining, command.nation) end
                remaining[command.nation] = true
            end
            if #remaining > 1 then
                self.hotspot:nationButtons(remaining, 'Gains control', 'control')
                new_owner = coroutine.yield()
                self.hotspot.UI.hide('control')
            else new_owner = remaining[1] end
        end
        debug(new_owner, ' gains control')
        local p = region.card:giveTo(new_owner)
        if region.flag then stash(region.flag) end
        if Nations[new_owner].prefix ~= region.id:sub(1, 1) then
            local pos = (region.flag or self.hotspot).getPosition()
            Wait.condition(function () region.flag = Bags.flag[new_owner].takeObject({
                position = pos, rotation = {0, math.random(360), 0}
            }) end, || self.hotspot.isSmoothMoving())
        else region.flag = nil end
        broadcastToAll(string.format('%s has taken control of %s from %s',
            Nations[new_owner]:colorized(), region:colorizedName(), Nations[owner]:colorized()))
        if region.sv and not (region.collapsed and region:owner() == Nations[region.id:sub(1, 1)]) then Morale:addStress(owner, region.sv) end
        local medals, awardees = region.capital and 3 or 1, {}
        if not collapsed then for _, nation in ipairs(combatants) do
            if nation ~= state.pact_broken or owner ~= Nations[nation].pact then
                table.insert(awardees, nation)
        end end else table.insert(awardees, new_owner) end
        if not region.id:find('n') then if #awardees > 1 then
            self.hotspot:nationButtons(awardees, '+1 medal', 'medals')
            for i = 1, medals do Morale:addMedals(coroutine.yield(), 1) end
        elseif #awardees == 1 then Morale:addMedals(combatants[1], medals)
        else alert('No medals awarded due to breaking Soviet-Japanese non-aggression pact') end end
        self.hotspot.UI.hide('medals')
        if state.scenario == 'global' and (region.id == 'g1' or region.id == 'r1') then Movement.breakPact() end
        p:next(|| self.resume())
        coroutine.yield()
    end
end

----#include combat/debrief

Combat.BombOrder = {
    {color = 'white', target = 'bomb'},
    {color = 'yellow', target = 'osr'},
    {color = 'blue', target = 'iron'},
    {color = 'red', target = 'oil'},
    {color = 'yellow', target = 'infantry'},
    {color = 'blue', target = 'artillery'},
    {color = 'green', target = 'armor'},
    {color = 'green', target = 'fighter'},
    {color = 'red', target = 'bomber'},
    {color = 'yellow', target = 'submarine'},
    {color = 'blue', target = 'cruiser'},
    {color = 'green', target = 'carrier'},
    {color = 'red', target = 'battleship'}
}

function Combat:assignBombs(dice, targets, ui)
    local region = Map.regions[self.hotspot.region]
    local owner, p = region:owner()
    log(targets)
    for _, die in ipairs(dice) do
        local die_color = die:getColor()
        local wild = die_color == 'black'
        debug('Checking ', die_color, ' die')
        if wild or targets[die_color] then
            setGlow(die)
            for clr, ids in pairs(targets) do if wild or clr == die_color then
                for id, _ in pairs(ids) do ui.setAttributes(clr .. '-' .. id, {
                    interactable = true, textColor = ui.getAttribute(clr .. '-' .. id, 'textColor')
                }) end
            end end
            local hit_color, hit_id = coroutine.yield():match('(%a+)%-(%a+)')
            debug('Hitting ', hit_color, ' ', hit_id)
            stopGlow(die)
            p = fadeOut(die)
            for clr, ids in pairs(targets) do if wild or clr == die_color then for id, _ in pairs(ids) do
                ui.setAttribute(clr .. '-' .. id, 'interactable', false)
            end end end
            if targets[hit_color][hit_id] == 1 then targets[hit_color][hit_id] = nil
            else targets[hit_color][hit_id] = targets[hit_color][hit_id] - 1 end
            ui.setAttribute(hit_color .. '-' .. hit_id, 'text', targets[hit_color][hit_id] or '')
            if not next(targets[hit_color]) then targets[hit_color] = nil end
            if hit_id == 'osr' or hit_id == 'iron' or hit_id == 'oil' then
                Resources[owner]:add({[hit_id] = -1})
                alert(string.format('%s lost %s %s from bombing in %s',
                    Nations[owner]:colorized(), string.colorize(1, hit_id), hit_id, region:colorizedName()))
            else
                if hit_id == 'bomb' then
                    local bombs = region.bombs
                    local position, rotation = self.hotspot.getPosition() + vector(0, 1, 0), {180, math.random(360), 0}
                    if bombs then position, rotation = bombs[#bombs].getPosition() + vector(0, 0.25, 0), bombs[#bombs].getRotation() end
                    local bomb = Bags.bomb_industry.takeObject({
                        position = position, rotation = rotation,
                        callback_function = |obj| Wait.condition(|| self.resume(), || not obj.isSmoothMoving())
                    })
                    if bombs then table.insert(bombs, bomb) else region.bombs = {bomb} end
                    alert('Infrastructure was destroyed in ' .. region:colorizedName())
                else
                    region.construction:destroyUnit(hit_id):next(|| self.resume())
                    alert(string.format('%s under construction was destroyed by bombing in %s',
                        hit_id:proper():colorize(hit_id), region:colorizedName()))
                end
                coroutine.yield()
            end
        else p = fadeOut(die) end
    end
    p:next(|| self.resume())
    coroutine.yield()
end

----#include phases/combat
----#include phases/refit
Refit = Phase()

function Refit:main()
    HUD.updateTracker('Land air commands', '5 - Refit & Deploy', 'landing')
    HUD.updateTurn()
    HUD.resetStatus()
    local readied, ps, deploy = {}, {}, {}
    if state.phase < 5 or state.step < 2 then
        state.phase, state.step = 5, 1
        HUD.close('combat')
        for _, cfighter in ipairs(Commands.cfighters) do if cfighter.obj.memo ~= nil then stash(cfighter) end end
        Commands.cfighters = {}
        debug('Removed remaining carrier fighters')
        for command in Commands:all() do if command.force == 'fleet' and #command.getJoints() > 0 then
            debug('Removing dive token from ', command.nation, ' ', command.id)
            stash(getObjectFromGUID(command.getJoints()[1].joint_object_guid))
            command.jointTo()
            command.removeTag('escaped')
        elseif command.force == 'air' then
            if #command.getJoints() > 0 then
                debug('Removing arrow tag from ', command.nation, ' ', command.id)
                stash(getObjectFromGUID(command.getJoints()[1].joint_object_guid))
                command.jointTo()
                command.addTag('landing')
            end
            if command.hasTag('landing') then
                readied[command.nation] = false
                setGlow(command, Color[command.nation])
        end end end
        for _, nation in turnOrder() do if readied[nation] == false then
            HUD.updateStatus(nation, false)
            Orders[nation]:enableReady(|...| self.resume(...))
        else HUD.updateStatus(nation, true) end end
        Phase.readyLoop(readied, next(readied) == nil, function (nation, ready)
            local invalid
            for _, command in pairs(Commands[nation]) do if command.hasTag('landing') then if ready then
                if not command:region() then command.removeTag('landing') else
                    local dest = Map.regions[command:region()]
                    debug(command.nation, ' ', command.id, ' lands in ', dest.id)
                    if dest.is_sea or dest:side() ~= 'neutral' and dest:side() ~= Nations[command.nation].side
                            or dest:side() == 'neutral' and (Nations[command.nation]:isAxis() or not dest.allied) then
                        invalid = true
                        setPulse(command, Color.red)
                        Wait.time(|| stopPulse(command), 6)
                end end
                stopGlow(command)
            else setGlow(command, Color[nation]) end end end
            if invalid then return false end
        end)
    end
    for command in Commands:all() do command.removeTag('landing') end
    HUD.updateTracker('Deploy units and reorganize commands', nil, 'deploy')
    HUD.resetStatus()
    state.step, readied = 2, {}
    for _, nation in turnOrder() do
        readied[nation], deploy[nation] = false, {}
        HUD.updateStatus(nation, false)
        Orders[nation]:enableReady(|...| self.resume(...))
    end
    for id, region in pairs(Map.regions) do if region.construction ~= nil then
        local owner, p = region:owner(), Promise()
        coroutine.resume(coroutine.create(|| self:deployUnits(region):next(p)))
        table.insert(deploy[owner], p:next(function (units) deploy[owner][id] = units end))
    end end
    for _, nation in turnOrder() do debug('Checking for deployable ', nation, ' units') if #deploy[nation] > 0 then
        Orders[nation].UI.setAttribute('ready', 'interactable', false)
        Promise.all(deploy[nation]):next(function ()
            Orders[nation].UI.setAttribute('ready', 'interactable', true)
            for i = #deploy[nation], 1, -1 do deploy[nation][i] = nil end
    end) end end
    Phase.readyLoop(readied, next(readied) == nil, function (nation, ready) if ready then
        local ps = {}
        for id, units in pairs(deploy[nation]) do
            for i = #units, 1, -1 do if units[i].obj == nil then table.remove(units, i) end end
            local fails = {}
            while #units > 0 do
                local stack, fail = {table.remove(units)}
                local pos, force = stack[1].getPosition():setAt('y', 0), stack[1].force
                if force == 'fleet' then
                    local deploy_id = Map:getRegion(stack[1])
                    fail = string.format('Can\'t deploy fleet from %s to %s', id, deploy_id)
                    for _, port in ipairs(Map.regions[id].adjacent) do
                        if deploy_id .. '$' == port then fail = nil break end
                end end
                for i = #units, 1, -1 do if (units[i].getPosition():setAt('y', 0) - pos):magnitude() < 0.25 then
                    if units[i].force ~= force then fail = 'Can\'t form command with different unit types' end
                    table.insert(stack, table.remove(units, i))
                end end
                if fail then
                    for i = 1, #stack do table.insert(fails, stack[i]) end
                    table.insert(ps, Promise():reject(fail))
                else table.insert(ps, Commands:getNew(
                    nation, force, pos:setAt('y', #stack * 0.21 + 7), stack[1].getRotation()
                ):next(|c| Promise.condition(|| c.resting, c)):next(
                    |c| c:form(nil, table.pack(c, table.unpack(stack, 1, #stack)))
                ):catch(function (reason)
                    for _, unit in ipairs(stack) do table.insert(deploy[nation][id], unit) end
                    return Promise():reject(reason)
                end))
            end end
            if #fails > 0 then deploy[nation][id] = fails end
        end
        if #ps > 0 then Promise.all(ps):next(|| self.resume(nation, ready), || Orders[nation]:toggleReady(false)) end
    end end)
    self.resume = nil
end

function Refit:deployUnits(region)
    debug('Deploying units in ', region.id)
    local stack, co = region.construction, coroutine.running()
    if region:production() == 0 then
        debug('No production capacity! Destroying all constructed units')
        return Promise.all(Morale:casualties(stack:detach()), stack:stash())
    elseif stack.units() > region:production() then
        debug('Over production capacity! Select units to destroy')
        setGlow(stack, Color.red)
        repeat
            for unit in pairs(stack.units) do stack.addContextMenuItem('Destroy 1 ' .. unit:proper(), function ()
                stack.clearContextMenu()
                stack:destroyUnit(unit):next(|| coroutine.resume(co))
            end) end
            coroutine.yield()
        until stack.units() == region:production()
    end
    local units = stack:detach()
    for _, unit in ipairs(units) do setGlow(unit, Color[region:owner()]) end
    return stack:stash():next(|| units)
end

----#include phases/refit
----#include phases/morale
Morale = Phase({__index = Morale})
Morale.Levels = {[20] = 1, [36] = 2, [52] = 3, [70] = 4, [90] = 5}

function Morale:main()
    HUD.updateTracker('Convert casualties into stress', '6 - Morale', 'casualties')
    HUD.resetStatus()
    if state.scenario == 'global' and not state.pact_broken then
        Orders.japan.UI.setAttribute('pact', 'interactable', false)
        Orders.ussr.UI.setAttribute('pact', 'interactable', false)
    end
    state.pact_broken = state.pact_broken and true
    if state.phase < 6 or state.step < 2 then self:convert() end
    if state.step < 4 then self:cancel() end
    if state.step < 5 then self:homeland() end
    self:penalties()
    self.resume = nil
end

function Morale:convert()
    state.phase, state.step = 6, 1
    self.UI.show('convert')
    coroutine.yield()
    self.UI.hide('convert')
    self.UI.show('casualties')
    local casualties = {}
    for _, nation in turnOrder() do
        casualties[nation] = {units = {}, utimer = 1, total = 0, count= 0, ctimer = 1, level = 0}
        self.UI.show(nation .. '-casualties')
        self.UI.setValue(nation .. '-count', 0)
        self.UI.setAttribute(nation .. '-stress', 'image', 'stress-level0')
        self.UI.hide(nation .. '-stress')
    end
    local rows, right = Nations:moraleOrder(), self.getTransformRight() * (self.is_face_down and -1 or 1)
    for _, obj in ipairs(Physics.cast({
        origin = self.getPosition() + self.getTransformForward():scale(1.8):setAt('y', self.is_face_down and 2.5 or 2.7),
        type = 3, size = vector(25.5, 5, 13.2), orientation = vector(0, self.getRotation().y, 0),
        direction = {0, 1, 0}, max_distance = 0
    })) do
        local name, pos = obj.hit_object.getName(), self.positionToLocal(obj.hit_object.getPosition())
        local nation = rows[math.floor((pos.z + 0.5) / 0.225) + 1]
        if name == 'convoy_dive' or Units[name] then
            table.insert(casualties[nation].units, obj.hit_object)
    end end
    for _, t in pairs(casualties) do table.sort(t.units, function (a, b)
        local v = b.getPosition() - a.getPosition()
        if v:copy():setAt('y', 0):magnitude() < 0.5 then return v.y > 0
        else return v:copy():setAt('y', 0):dot(right) > 0 end
    end) end
    onUpdate = function () if self:countCasualties(casualties) then
        onUpdate = nil
        Wait.condition(|| self.resume(), function ()
            for _, co in pairs(self.stress) do if co and coroutine.status(co) ~= 'dead' then return false end end
            return true
    end) end end
    coroutine.yield()
    state.step = 2
end

function Morale:cancel()
    if state.step < 3 then
        self.UI.show('spend')
        coroutine.yield()
        self.UI.hide('spend')
        state.step = 3
    end
    HUD.updateTracker('Spend medals to cancel stress', nil, 'medals')
    HUD.resetStatus()
    local done = {}
    for _, nation in turnOrder() do
        self.UI.hide(nation .. '-casualties')
        self.UI.show(nation .. '-stress')
        self.medals[nation], self.stress[nation] = self:getStack(nation, 'medal_goods'), self:getStack(nation, 'stress')
        local total = 0
        for _, obj in ipairs(self.stress[nation]) do total = total + tonumber(obj.getName():match('%d')) end
        self:updateStress(nation, total)
        done[nation] = Promise()
        table.insert(done, done[nation])
        if #self.medals[nation] > 0 and #self.stress[nation] > 0 then
            self:medalButtons(nation, self.medals[nation][#self.medals[nation]])
        else done[nation]:resolve() end
    end
    Promise.all(done):next(|| self.resume('done'))
    while true do
        local nation, id = coroutine.yield()
        if nation == 'done' then break elseif id ~= 'done' then nation = id end
        local medals, stress = self.medals[nation], self.stress[nation]
        if id == 'done' then
            medals[#medals].UI.setXml('')
            done[nation]:resolve()
        else
            debug(nation, ' spent a medal')
            local medal = table.remove(medals)
            local xml = medal.UI.getXml()
            medal.UI.setXml('')
            self:updateStress(nation, -1)
            Promise.all(fadeOut(medal), self:removeStress(stress, 1)):next(function ()
                if #medals > 0 and #stress > 0 then
                    medals[#medals].UI.setXml(xml)
                else done[nation]:resolve() end
            end)
    end end
    state.step = 4
    self.UI.hide('casualties')
end

function Morale:homeland()
    HUD.updateTracker('Evaluate homeland stress levels')
    local thresholds, ps = {}, {}
    for _, nation in turnOrder() do
        self.medals[nation] = self.medals[nation] or self:getStack(nation, 'medal_goods')
        self.stress[nation] = self.stress[nation] or self:getStack(nation, 'stress')
        thresholds[nation] = Nations[nation].morale[self.is_face_down and 2 or 1]
        if self.stressZone(nation) < 6 then
            local total, penalty = 0, 1
            for _, obj in ipairs(self.stress[nation]) do total = total + tonumber(obj.getName():match('%d')) end
            debug(nation, ' has ', total, ' total stress')
            total = total - total % thresholds[nation]
            for _, command in pairs(Commands[nation]) do if command.units() > 0 then penalty = 0 break end end
            if total + penalty > 0 then
                local p = total > 0 and self:removeStress(self.stress[nation], total) or Promise():resolve()
                table.insert(ps, p:next(|| self.updateZone(nation, total / thresholds[nation] + penalty)))
    end end end
    if #ps > 0 then
        Promise.all(ps):next(|| self.resume())
        coroutine.yield()
    end
    HUD.updateTracker('Relieve homeland stress')
    for _, nation in turnOrder() do if self.stressZone(nation) > 1 and #self.medals[nation] >= thresholds[nation] then
        self:medalButtons(nation, self.medals[nation][#self.medals[nation]], thresholds[nation])
    else self.medals[nation] = nil end end
    ps = {}
    if next(self.medals) then repeat
        local nation, spent = coroutine.yield()
        if spent ~= 'done' then nation = spent end
        local medals = self.medals[nation]
        medals[#medals].UI.setXml('')
        if spent ~= 'done' then
            for i = 1, thresholds[nation] do fadeOut(medals[#medals - i + 1]) end
            table.insert(ps, self.updateZone(nation, -1))
        end
        self.medals[nation] = nil
    until next(self.medals) == nil end
    if #ps > 0 then
        Promise.all(ps):next(|| self.resume())
        coroutine.yield()
    end
    state.step = 5
end

function Morale:penalties()
    if state.step < 6 then
        HUD.updateTracker('Apply penalties: Lose 3 resources', nil, 'unrest')
        HUD.resetStatus()
        local ps = {}
        for _, nation in turnOrder() do if self.stressZone(nation) > 1 then
            debug(nation, ' loses 3 resources')
            local total = 0
            for _, value in pairs(Resources[nation]:totals()) do total = total + value end
            table.insert(ps, Promise.condition(function ()
                local current = 0
                for _, value in pairs(Resources[nation]:totals()) do current = current + value end
                return math.max(total - 3, 0) == current
            end):next(|| HUD.updateStatus(nation, true)))
        else HUD.updateStatus(nation, true) end end
        if #ps > 0 then
            Promise.all(ps):next(|| self.resume())
            coroutine.yield()
        end
        state.step = 6
    end
    HUD.updateTracker('Apply penalties: Mass desertions', nil, 'desertions')
    HUD.resetStatus()
    local readied = {}
    for _, nation in turnOrder() do if self.stressZone(nation) == 6 and #self.stress[nation] > 0 then
        debug(nation, ' suffers mass desertions')
        readied[nation] = false
        HUD.updateStatus(nation, false)
        Orders[nation]:enableReady(|...| self.resume(...))
    else
        self.stress[nation] = nil
        HUD.updateStatus(nation, true)
    end end
    Phase.readyLoop(readied, next(readied) == nil, function (nation) self.stress[nation] = nil end)
end

function Morale:countCasualties(casualties)
    local all_done = true
    for nation, data in pairs(casualties) do
        if (data.ltimer or 0) > 0 then
            data.ltimer = data.ltimer - 1
            self.UI.setAttribute(nation .. '-level', 'color', Color.oil:lerp(Color.white, 1 - data.ltimer / 10):setAt('a', 0.75):toXml())
        elseif data.ltimer == 0 then data.ltimer = nil end
        if not data.ready then
            all_done, data.utimer, data.ctimer = false, data.utimer - 1, data.ctimer - 1
            for _, timer in ipairs{'unit', 'count', 'shade'} do if data[timer .. '_timer'] then
                data[timer .. '_timer'] = data[timer .. '_timer'] - 1
            end end
            if #data.units > 0 and data.utimer < 1 then
                local unit = table.remove(data.units)
                local value = Units[unit.getName():gsub('convoy_dive', 'submarine')].casualties
                data.total, data.utimer = data.total + value, 2 + value
                unit.destruct()
            end
            if data.total > data.count and data.ctimer < 1 then
                data.count = data.count + 1
                self.UI.setValue(nation .. '-count', data.count)
                data.ctimer = math.ceil(8 / (data.total - data.count))
                if self.Levels[data.count] then
                    data.level, data.ltimer = self.Levels[data.count], 10
                    self:addStress(nation, 1)
                    self.UI.setAttributes(nation .. '-level', {color = Color.oil:setAt('a', 0.75):toXml(), image = 'stress-level' .. data.level})
            end end
            if #data.units == 0 and data.total == data.count then
                data.ready = true
                local shade = Color.white:lerp(Color.medal, math.min(data.level / 4, 1)):lerp(Color.oil, math.max((data.level - 2) / 3, 0))
                alert(string.format('%s received %s stress from casualties', Nations[nation]:colorized(), string.colorize(data.level, shade)))
    end elseif data.ltimer then all_done = false end end
    return all_done
end

function Morale:updateStress(nation, value)
    local id = nation .. '-stress'
    if value < 0 then value = tonumber(self.UI.getValue(id):match('%d+')) + value end
    self.UI.setValue(id, value == 0 and '' or value .. '/')
    self.UI.setAttribute(id, 'color', '#ff' .. (value >= Nations[nation].morale[self.is_face_down and 2 or 1] and '8040' or 'ffff'))
end

----#include phases/morale
----#include phases/production
Production = Phase()

function Production:main()
    HUD.updateTracker('Write unit purchase orders', '7 - Production', 'production')
    HUD.resetStatus()
    for nation, orders in pairs(Orders) do orders:restoreProduction() end
    local ps, new_units = {}, {}
    if state.scenario == 'global' and not state.pact_broken then
        Orders.japan.UI.setAttribute('pact', 'interactable', false)
        Orders.ussr.UI.setAttribute('pact', 'interactable', false)
    end
    if state.phase < 7 or state.step < 2 then
        local readied, trades = {}, {axis = {}, allies = {}}
        if state.scenario == 'global' then for _, region in pairs(Map.regions) do if region.trade then
            local owner = region:owner()
            if owner ~= 'neutral' then trades[Nations[owner].side][region.trade] = 'land'
            else for _, link in ipairs(region.adjacent) do
                local id, flag = link:match('(%a%d+)(.?)')
                owner = Map.regions[id]:owner()
                if flag == '$' then
                    local commands = Commands:region(id)
                    if not commands.axis.fleet then debug('Allies can trade by port') trades.allies[region.trade] = trades.allies[region.trade] or 'sea'
                    elseif commands.axis.fleet and not commands.allies.fleet and not region.allied then
                        trades.axis[region.trade] = trades.axis[region.trade] or 'sea'
                end elseif owner and owner ~= 'neutral' and not Cards[id].is_face_down then
                    trades[Nations[owner].side][region.trade] = 'land'
        end end end end end end
        for nation, orders in pairs(Orders) do
            readied[nation] = false
            local routes = {}
            if nation ~= 'china' then for resource, flag in pairs(trades[Nations[nation].side]) do
                if flag == 'land' or flag == 'sea' and Morale.stressZone(nation) < 3 then routes[resource] = true end
                debug(nation, ' can trade ', resource)
            end end
            orders:writeProduction(|...| self.resume(...), routes, state.phase == 7)
        end
        state.phase, state.step = 7, 1
        Phase.readyLoop(readied)
    else for _, unit in Tags.forAllObjects('production') do
        local nation
        for _, tag in ipairs(unit.getTags()) do if Nations[tag] then nation = tag break end end
        new_units[nation] = new_units[nation] or {}
        table.insert(new_units[nation], unit)
    end end
    HUD.updateTracker('Reveal purchases and update resources')
    HUD.open('production')
    for i, nation in turnOrder() do
        local purchases, cg = Orders[nation]:revealPurchases()
        if purchases.cg then
            cg, purchases.cg = purchases.cg
            if state.step == 1 then Morale:addGoods(nation, cg) end
            if state.step == 1 and i > 1 then
                UI.setValue('cg' .. i, '')
                Wait.time(|| UI.setValue('cg' .. i, cg), (i - 1) * 0.5)
            else UI.setValue('cg' .. i, cg) end
        else UI.setValue('cg' .. i, '') end
        if state.step == 1 and next(purchases) ~= nil then table.insert(ps, Units:buildStack(purchases,
            Orders[nation].getPosition() - Orders[nation].getTransformForward() * 10,
            Orders[nation].getRotation()
        ):next(function (...) new_units[nation] = {...} end)) end
        for unit, t in pairs(Units) do if t.cost then
            if purchases[unit] and state.step == 1 and i > 1 then
                UI.setValue(unit .. i, '')
                Wait.time(|| UI.setValue(unit .. i, purchases[unit]), (i - 1) * 0.5)
            else UI.setValue(unit .. i, purchases[unit] or '') end
    end end end
    if #ps > 0 then
        Promise.all(ps):next(|| self.resume())
        coroutine.yield()
        for nation, orders in pairs(Orders) do Resources[nation]:set(orders.resources.remaining) end
    end
    HUD.updateTracker('Transfer new units to industries', nil, 'transfer')
    state.step, ps = 2, {}
    local readied = {}
    for nation, orders in pairs(Orders) do if new_units[nation] then
        readied[nation] = false
        HUD.updateStatus(nation, false)
        orders:enableReady(|...| self.resume(...))
        orders.UI.setAttribute('ready', 'interactable', true)
        for _, unit in ipairs(new_units[nation]) do
            setGlow(unit, Color[nation])
            unit.addTag(nation)
            unit.addTag('production')
    end else HUD.updateStatus(nation, true) end end
    Phase.readyLoop(readied, next(readied) == nil, function (nation, ready) if ready then
        debug('Checking production placements for ', nation)
        local units, by_region, invalid, valid = new_units[nation], {}, {}, {Promise()}
        for i = #units, 1, -1 do if units[i] == nil then table.remove(units, i) end end
        for _, unit in ipairs(units) do
            local id = Map:getRegion(unit)
            if not id then table.insert(invalid, unit) debug('Invalid placement: unit not on map') else
                local region = Map.regions[id]
                if region:owner() ~= nation then table.insert(invalid, unit) debug('Invalid placement: unit not in region controlled by owner')
                elseif region.mobilization and unit.getName() ~= 'infantry' then table.insert(invalid, unit) debug('Invalid placement: only infantry can mobilize')
                elseif not region.port and Units[unit.getName()].force == 'fleet' then table.insert(invalid, unit) debug('Invalid placement: naval unit in region without port')
                else
                    by_region[id] = by_region[id] or {}
                    table.insert(by_region[id], unit)
        end end end
        local free_commands = Commands:free(nation)
        for id, produced in pairs(by_region) do
            local region = Map.regions[id]
            if (nation == 'china' and region.mobilization or region:production()) < #produced then
                debug('Invalid placement: units exceed production capacity in ', id)
                for _, unit in ipairs(produced) do table.insert(invalid, unit) end
            else if nation == 'china' and region.mobilization then debug('Mobilizing infantry in ', id)
                local new_command = #free_commands > 0 and table.remove(free_commands) or nil
                for _, command in pairs(Commands.china) do if command:region() == id then
                    local merge = {}
                    for i = #produced, 1, -1 do if (command.getPosition() - produced[i].getPosition()):setAt('y', 0):magnitude() < 0.5 then
                        table.insert(merge, table.remove(produced, i))
                    end end
                    if #merge > 0 then if command.units() + #merge < 9 then debug('Merging ', #merge, ' mobilized infantry into ', tostring(command))
                        table.insert(valid, valid[1]:next(function ()
                            self.clearTags(merge)
                            return command:combine(merge)
                        end))
                    else debug('Unable to merge, too many units') for _, unit in ipairs(merge) do table.insert(invalid, unit) end end end
                end end
                if #produced > 0 then if new_command then debug('Forming new command')
                    table.insert(valid, valid[1]:next(|| self:mobilization(new_command, produced)))
                else debug('No new commands available') for _, unit in ipairs(merge) do table.insert(invalid, unit) end end end
            else debug('Forming construction stack in ', id)
                table.insert(valid, valid[1]:next(|| self:construction(region, produced)))
        end end end
        if #invalid == 0 then
            new_units[nation] = {}
            table.insert(ps, Promise.all(valid))
            valid[1]:resolve()
            Orders[nation].UI.hide('ready')
        else
            debug('Failed to place new units')
            valid[1]:reject()
            return false
    end end end)
    if #ps > 0 then
        Promise.all(ps):next(|| self.resume())
        coroutine.yield()
    end
    self.resume = nil
end

function Production:construction(region, units)
    local p = Promise()
    self.clearTags(units)
    Bags.bomb_industry.takeObject({
        position = units[1].getPosition() + vector(0, 2, 0),
        callback_function = function (obj) Construction(obj):attach(units):next(function (c)
            region.construction = c
            p:resolve()
    end) end})
    return p
end

function Production:mobilization(command, units)
    self.clearTags(units)
    command.setPositionSmooth(units[1].getPosition() + vector(0, 1, 0))
    return command:notMoving():next(|c| c:attach(units))
end

function Production.clearTags(units) table.each(units, |unit| unit.setTags({unit.getName()})) end

----#include phases/production
----#include phases/cleanup
Cleanup = Phase()
Cleanup.CollapsedDecal = 'http://cloud-3.steamusercontent.com/ugc/1722038301663788671/DD247A5BB08A873579425E621346DDC86E13213F/'

function Cleanup:main()
    local turns = turnOrder.get()
    for i = #turns, 1, -1 do if Morale.stressZone(turns[i]) == 6 then
        local nation, collapsed = turns[i], true
        for _, command in pairs(Commands[nation]) do if command.units() > 0 then collapsed = false break end end
        if collapsed then for _, region in pairs(Map.regions) do
            if region.construction and region:owner() == nation then collapsed = false break end
        end end
        if collapsed then
            local components = Tags.getObject({nation, 'components'})
            components.interactable = true
            components.setPositionSmooth(components.getPosition():setAt('y', 6.53))
            Wait.condition(|| self.resume(), || not components.isSmoothMoving())
            coroutine.yield()
            if i < #turns then for j = #turns, i + 1, -1 do
                Tokens.turn[turns[j]].setPositionSmooth(Tokens.turn[turns[j-1]].getPosition())
                Tokens.turn[turns[j]].setRotationSmooth(Tokens.turn[turns[j-1]].getRotation())
            end end
            table.remove(turns, i)
            Wait.condition(|| self.resume(), || not Tokens.turn[turns[#turns]].isSmoothMoving())
            self:collapseNation(nation, components)
    end end end
    for i = 1, 7 do if not turnOrder[i] then
        UI.hide('tracker' .. i)
        UI.hide('status' .. i)
        for resource in Resources() do UI.setAttribute('frame-' .. resource .. i, 'active', false) end
    else UI.setAttribute('tracker' .. i, 'image', turnOrder[i]) end end
end

function Cleanup:collapseNation(nation, components)
    broadcastToAll(Nations[nation].name:colorize(nation) .. ' has collapsed!', Color._red)
    if state.scenario == 'global' and (nation == 'ussr' or nation == 'japan') then Movement.breakPact() end
    for _, medal in ipairs(Morale:getStack(nation, 'medal_goods')) do medal.destruct() end
    for _, stress in ipairs(Morale:getStack(nation, 'stress')) do stress.destruct() end
    Orders[nation].setDecals({{
        name = 'collapsed', position = {0, 0.61, 0}, rotation = {90, 150, 0}, scale = {16.8, 4.25, 1},
        url = self.CollapsedDecal
    }})
    Morale.setDecals(table.insert(Morale.getDecals() or {}, {
        name = 'collapsed-' .. nation, rotation = {90, 180, 0}, scale = {0.72, 0.18, 1},
        position = Morale.snaps[nation].medal_goods:lerp(Morale.snaps[nation].stress, 0.5) + vector(0, Morale.is_face_down and -0.01 or 0.01, 0),
        url = self.CollapsedDecal
    }))
    Resources[nation]:zero()
    components.putObject(Tokens.turn[nation])
    for resource in Resources() do if resource ~= 'oil' or nation ~= 'china' then
        components.putObject(Resources[nation][resource].peg)
    end end
    for _, command in pairs(Commands[nation]) do components.putObject(command.obj) end
    Orders[nation].UI.setXml()
    Tokens.turn[nation], Tokens.homeland[nation], Orders[nation], Commands[nation] = nil
    coroutine.yield()
    debug('Resuming after turn tokens moved')
    local commands = Commands:byRegion()
    for id, region in pairs(Map.regions) do
        if id:match('^' .. Nations[nation].prefix) then
            region.collapsed = true
            region.card:embattled(true)
        end
        if region:owner() == nation and commands[id] then
            local claimants = {}
            for _, force in pairs(commands[id][region:side()]) do for _, command in ipairs(force) do
                if not claimants[command.nation] then table.insert(claimants, command.nation) end
                claimants[command.nation] = true
            end end
            if #claimants > 1 then
                -- TODO: show buttons to choose new owner
                debug('Multiple nations can claim ', id)
            elseif #claimants == 1 then
                broadcastToAll(Nations[claimants[1]]:colorized() .. ' has claimed ' .. Map.regions[id]:colorizedName())
                Morale:addMedals(claimants[1], region.capital and 3 or 1)
                region.flag = Bags.flag[claimants[1]].takeObject({
                    position = region:center(), rotation = {0, math.random(360), 0}
                })
                region.card:giveTo(claimants[1]):next(|| self.resume())
                coroutine.yield()
    end end end
end

----#include phases/cleanup

-- Helper functions --
function stash(obj)
    obj.highlightOff()
    obj.setPositionSmooth(obj.getPosition() + vector(0, 3, 0))
    return Promise.condition(|| not obj.isSmoothMoving()):next(|| obj.destruct())
end

-- Global callbacks --
function onObjectCollisionEnter(obj, info)
    local name = obj.getName()
    if name:match('stress') or name == 'medal_goods' then Morale:collisionHandler(obj, info.collision_object) end
end

function tryObjectEnterContainer(container, obj) return obj.type ~= 'Card' or container.type ~= 'Card' end

